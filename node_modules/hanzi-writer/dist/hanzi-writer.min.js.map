{"version":3,"file":"hanzi-writer.min.js","sources":["../src/utils.ts","../src/RenderState.ts","../src/geometry.ts","../src/models/Stroke.ts","../src/models/Character.ts","../src/parseCharData.ts","../src/Positioner.ts","../src/strokeMatches.ts","../src/models/UserStroke.ts","../src/Mutation.ts","../src/characterActions.ts","../src/quizActions.ts","../src/Quiz.ts","../src/renderers/svg/svgUtils.ts","../src/renderers/StrokeRendererBase.ts","../src/renderers/svg/StrokeRenderer.ts","../src/renderers/svg/CharacterRenderer.ts","../src/renderers/svg/UserStrokeRenderer.ts","../src/renderers/RenderTargetBase.ts","../src/renderers/svg/RenderTarget.ts","../src/renderers/svg/index.ts","../src/renderers/svg/HanziWriterRenderer.ts","../src/renderers/canvas/canvasUtils.ts","../src/renderers/canvas/StrokeRenderer.ts","../src/renderers/canvas/CharacterRenderer.ts","../src/renderers/canvas/renderUserStroke.ts","../src/renderers/canvas/RenderTarget.ts","../src/renderers/canvas/index.ts","../src/renderers/canvas/HanziWriterRenderer.ts","../src/defaultCharDataLoader.ts","../src/defaultOptions.ts","../src/LoadingManager.ts","../src/HanziWriter.ts"],"sourcesContent":["import { ColorObject, RecursivePartial } from './typings/types';\n\n// hacky way to get around rollup not properly setting `global` to `window` in browser\nconst globalObj = typeof window === 'undefined' ? global : window;\n\nexport const performanceNow =\n  (globalObj.performance && (() => globalObj.performance.now())) || (() => Date.now());\nexport const requestAnimationFrame =\n  globalObj.requestAnimationFrame ||\n  ((callback) => setTimeout(() => callback(performanceNow()), 1000 / 60));\nexport const cancelAnimationFrame = globalObj.cancelAnimationFrame || clearTimeout;\n\n// Object.assign polyfill, because IE :/\nexport const _assign = function (target: any, ...overrides: any[]) {\n  const overrideTarget = Object(target);\n  overrides.forEach((override) => {\n    if (override != null) {\n      for (const key in override) {\n        if (Object.prototype.hasOwnProperty.call(override, key)) {\n          overrideTarget[key] = override[key];\n        }\n      }\n    }\n  });\n  return overrideTarget;\n};\n\nexport const assign = Object.assign || _assign;\n\nexport function arrLast<TValue>(arr: Array<TValue>) {\n  return arr[arr.length - 1];\n}\n\nexport function copyAndMergeDeep<T>(base: T, override: RecursivePartial<T> | undefined) {\n  const output = { ...base };\n  for (const key in override) {\n    const baseVal = base[key];\n    const overrideVal = override[key];\n    if (baseVal === overrideVal) {\n      continue;\n    }\n    if (\n      baseVal &&\n      overrideVal &&\n      typeof baseVal === 'object' &&\n      typeof overrideVal === 'object' &&\n      !Array.isArray(overrideVal)\n    ) {\n      output[key] = copyAndMergeDeep(baseVal, overrideVal);\n    } else {\n      // @ts-ignore\n      output[key] = overrideVal;\n    }\n  }\n  return output;\n}\n\n/** basically a simplified version of lodash.get, selects a key out of an object like 'a.b' from {a: {b: 7}} */\nexport function inflate(scope: string, obj: any): any {\n  const parts = scope.split('.');\n  const final: any = {};\n  let current = final;\n  for (let i = 0; i < parts.length; i++) {\n    const cap = i === parts.length - 1 ? obj : {};\n    current[parts[i]] = cap;\n    current = cap;\n  }\n  return final;\n}\n\nlet count = 0;\n\nexport function counter() {\n  count++;\n  return count;\n}\n\nexport function average(arr: number[]) {\n  const sum = arr.reduce((acc, val) => val + acc, 0);\n  return sum / arr.length;\n}\n\nexport function timeout(duration = 0) {\n  return new Promise((resolve) => setTimeout(resolve, duration));\n}\n\nexport function colorStringToVals(colorString: string): ColorObject {\n  const normalizedColor = colorString.toUpperCase().trim();\n  // based on https://stackoverflow.com/a/21648508\n  if (/^#([A-F0-9]{3}){1,2}$/.test(normalizedColor)) {\n    let hexParts = normalizedColor.substring(1).split('');\n    if (hexParts.length === 3) {\n      hexParts = [\n        hexParts[0],\n        hexParts[0],\n        hexParts[1],\n        hexParts[1],\n        hexParts[2],\n        hexParts[2],\n      ];\n    }\n    const hexStr = `${hexParts.join('')}`;\n    return {\n      r: parseInt(hexStr.slice(0, 2), 16),\n      g: parseInt(hexStr.slice(2, 4), 16),\n      b: parseInt(hexStr.slice(4, 6), 16),\n      a: 1,\n    };\n  }\n  const rgbMatch = normalizedColor.match(\n    /^RGBA?\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(?:\\s*,\\s*(\\d*\\.?\\d+))?\\)$/,\n  );\n  if (rgbMatch) {\n    return {\n      r: parseInt(rgbMatch[1], 10),\n      g: parseInt(rgbMatch[2], 10),\n      b: parseInt(rgbMatch[3], 10),\n      // @ts-expect-error ts-migrate(2554) FIXME: Expected 1 arguments, but got 2.\n      a: parseFloat(rgbMatch[4] || 1, 10),\n    };\n  }\n  throw new Error(`Invalid color: ${colorString}`);\n}\n\nexport const trim = (string: string) => string.replace(/^\\s+/, '').replace(/\\s+$/, '');\n\n// return a new array-like object with int keys where each key is item\n// ex: objRepeat({x: 8}, 3) === {0: {x: 8}, 1: {x: 8}, 2: {x: 8}}\nexport function objRepeat<T>(item: T, times: number) {\n  const obj: Record<number, T> = {};\n  for (let i = 0; i < times; i++) {\n    obj[i] = item;\n  }\n  return obj;\n}\n\nconst ua = globalObj.navigator?.userAgent || '';\n\nexport const isMsBrowser =\n  ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop = () => {};\n","import Character from './models/Character';\nimport { GenericMutation } from './Mutation';\nimport {\n  ColorObject,\n  OnCompleteFunction,\n  Point,\n  RecursivePartial,\n} from './typings/types';\nimport { copyAndMergeDeep, colorStringToVals, noop } from './utils';\n\nexport type StrokeRenderState = {\n  opacity: number;\n  displayPortion: number;\n};\n\nexport type CharacterRenderState = {\n  opacity: number;\n  strokes: Record<number | string, StrokeRenderState>;\n};\n\nexport type RenderStateObject = {\n  options: {\n    drawingFadeDuration: number;\n    drawingWidth: number;\n    drawingColor: ColorObject;\n    strokeColor: ColorObject;\n    outlineColor: ColorObject;\n    radicalColor: ColorObject;\n    highlightColor: ColorObject;\n  };\n  character: {\n    main: CharacterRenderState;\n    outline: CharacterRenderState;\n    highlight: CharacterRenderState;\n  };\n  userStrokes: Record<\n    string,\n    | {\n        points: Point[];\n        opacity: number;\n      }\n    | undefined\n  > | null;\n};\n\nexport type CharacterName = keyof RenderStateObject['character'];\n\ntype OnStateChangeCallback = (\n  nextState: RenderStateObject,\n  currentState: RenderStateObject,\n) => void;\n\ntype MutationChain = {\n  _isActive: boolean;\n  _index: number;\n  _resolve: OnCompleteFunction;\n  _mutations: GenericMutation[];\n  _loop: boolean | undefined;\n  _scopes: string[];\n};\n\nexport type RenderStateOptions = {\n  strokeColor: string;\n  radicalColor: string | null;\n  highlightColor: string;\n  outlineColor: string;\n  drawingColor: string;\n  drawingFadeDuration: number;\n  drawingWidth: number;\n  outlineWidth: number;\n  showCharacter: boolean;\n  showOutline: boolean;\n};\n\nexport default class RenderState {\n  _mutationChains: MutationChain[] = [];\n  _onStateChange: OnStateChangeCallback;\n\n  state: RenderStateObject;\n\n  constructor(\n    character: Character,\n    options: RenderStateOptions,\n    onStateChange: OnStateChangeCallback = noop,\n  ) {\n    this._onStateChange = onStateChange;\n\n    this.state = {\n      options: {\n        drawingFadeDuration: options.drawingFadeDuration,\n        drawingWidth: options.drawingWidth,\n        drawingColor: colorStringToVals(options.drawingColor),\n        strokeColor: colorStringToVals(options.strokeColor),\n        outlineColor: colorStringToVals(options.outlineColor),\n        radicalColor: colorStringToVals(options.radicalColor || options.strokeColor),\n        highlightColor: colorStringToVals(options.highlightColor),\n      },\n      character: {\n        main: {\n          opacity: options.showCharacter ? 1 : 0,\n          strokes: {},\n        },\n        outline: {\n          opacity: options.showOutline ? 1 : 0,\n          strokes: {},\n        },\n        highlight: {\n          opacity: 1,\n          strokes: {},\n        },\n      },\n      userStrokes: null,\n    };\n\n    for (let i = 0; i < character.strokes.length; i++) {\n      this.state.character.main.strokes[i] = {\n        opacity: 1,\n        displayPortion: 1,\n      };\n\n      this.state.character.outline.strokes[i] = {\n        opacity: 1,\n        displayPortion: 1,\n      };\n\n      this.state.character.highlight.strokes[i] = {\n        opacity: 0,\n        displayPortion: 1,\n      };\n    }\n  }\n\n  updateState(stateChanges: RecursivePartial<RenderStateObject>) {\n    const nextState = copyAndMergeDeep(this.state, stateChanges);\n    this._onStateChange(nextState, this.state);\n    this.state = nextState;\n  }\n\n  run(\n    mutations: GenericMutation[],\n    options: {\n      loop?: boolean;\n    } = {},\n  ) {\n    const scopes = mutations.map((mut) => mut.scope);\n\n    this.cancelMutations(scopes);\n\n    return new Promise((resolve: OnCompleteFunction) => {\n      const mutationChain: MutationChain = {\n        _isActive: true,\n        _index: 0,\n        _resolve: resolve,\n        _mutations: mutations,\n        _loop: options.loop,\n        _scopes: scopes,\n      };\n      this._mutationChains.push(mutationChain);\n      this._run(mutationChain);\n    });\n  }\n\n  _run(mutationChain: MutationChain) {\n    if (!mutationChain._isActive) {\n      return;\n    }\n\n    const mutations = mutationChain._mutations;\n    if (mutationChain._index >= mutations.length) {\n      if (mutationChain._loop) {\n        mutationChain._index = 0; // eslint-disable-line no-param-reassign\n      } else {\n        mutationChain._isActive = false; // eslint-disable-line no-param-reassign\n        this._mutationChains = this._mutationChains.filter(\n          (chain) => chain !== mutationChain,\n        );\n        // The chain is done - resolve the promise to signal it finished successfully\n        mutationChain._resolve({ canceled: false });\n        return;\n      }\n    }\n\n    const activeMutation = mutationChain._mutations[mutationChain._index];\n\n    activeMutation.run(this).then(() => {\n      if (mutationChain._isActive) {\n        mutationChain._index++; // eslint-disable-line no-param-reassign\n        this._run(mutationChain);\n      }\n    });\n  }\n\n  _getActiveMutations() {\n    return this._mutationChains.map((chain) => chain._mutations[chain._index]);\n  }\n\n  pauseAll() {\n    this._getActiveMutations().forEach((mutation) => mutation.pause());\n  }\n\n  resumeAll() {\n    this._getActiveMutations().forEach((mutation) => mutation.resume());\n  }\n\n  cancelMutations(scopesToCancel: string[]) {\n    for (const chain of this._mutationChains) {\n      for (const chainId of chain._scopes) {\n        for (const scopeToCancel of scopesToCancel) {\n          if (chainId.startsWith(scopeToCancel) || scopeToCancel.startsWith(chainId)) {\n            this._cancelMutationChain(chain);\n          }\n        }\n      }\n    }\n  }\n\n  cancelAll() {\n    this.cancelMutations(['']);\n  }\n\n  _cancelMutationChain(mutationChain: MutationChain) {\n    mutationChain._isActive = false;\n    for (let i = mutationChain._index; i < mutationChain._mutations.length; i++) {\n      mutationChain._mutations[i].cancel(this);\n    }\n\n    mutationChain._resolve?.({ canceled: true });\n\n    this._mutationChains = this._mutationChains.filter(\n      (chain) => chain !== mutationChain,\n    );\n  }\n}\n","import { Point } from './typings/types';\nimport { average, arrLast } from './utils';\n\nexport const subtract = (p1: Point, p2: Point) => ({ x: p1.x - p2.x, y: p1.y - p2.y });\n\nexport const magnitude = (point: Point) =>\n  Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\n\nexport const distance = (point1: Point, point2: Point) =>\n  magnitude(subtract(point1, point2));\n\nexport const equals = (point1: Point, point2: Point) =>\n  point1.x === point2.x && point1.y === point2.y;\n\nexport const round = (point: Point, precision = 1) => {\n  const multiplier = precision * 10;\n  return {\n    x: Math.round(multiplier * point.x) / multiplier,\n    y: Math.round(multiplier * point.y) / multiplier,\n  };\n};\n\nexport const length = (points: Point[]) => {\n  let lastPoint = points[0];\n  const pointsSansFirst = points.slice(1);\n  return pointsSansFirst.reduce((acc, point) => {\n    const dist = distance(point, lastPoint);\n    lastPoint = point;\n    return acc + dist;\n  }, 0);\n};\n\nexport const cosineSimilarity = (point1: Point, point2: Point) => {\n  const rawDotProduct = point1.x * point2.x + point1.y * point2.y;\n  return rawDotProduct / magnitude(point1) / magnitude(point2);\n};\n\n/**\n * return a new point, p3, which is on the same line as p1 and p2, but distance away\n * from p2. p1, p2, p3 will always lie on the line in that order\n */\nexport const _extendPointOnLine = (p1: Point, p2: Point, dist: number) => {\n  const vect = subtract(p2, p1);\n  const norm = dist / magnitude(vect);\n  return { x: p2.x + norm * vect.x, y: p2.y + norm * vect.y };\n};\n\n/** based on http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf */\nexport const frechetDist = (curve1: Point[], curve2: Point[]) => {\n  const longCurve = curve1.length >= curve2.length ? curve1 : curve2;\n  const shortCurve = curve1.length >= curve2.length ? curve2 : curve1;\n\n  const calcVal = (\n    i: number,\n    j: number,\n    prevResultsCol: number[],\n    curResultsCol: number[],\n  ): number => {\n    if (i === 0 && j === 0) {\n      return distance(longCurve[0], shortCurve[0]);\n    }\n\n    if (i > 0 && j === 0) {\n      return Math.max(prevResultsCol[0], distance(longCurve[i], shortCurve[0]));\n    }\n\n    const lastResult = curResultsCol[curResultsCol.length - 1];\n\n    if (i === 0 && j > 0) {\n      return Math.max(lastResult, distance(longCurve[0], shortCurve[j]));\n    }\n\n    return Math.max(\n      Math.min(prevResultsCol[j], prevResultsCol[j - 1], lastResult),\n      distance(longCurve[i], shortCurve[j]),\n    );\n  };\n\n  let prevResultsCol: number[] = [];\n  for (let i = 0; i < longCurve.length; i++) {\n    const curResultsCol: number[] = [];\n    for (let j = 0; j < shortCurve.length; j++) {\n      // we only need the results from i - 1 and j - 1 to continue the calculation\n      // so we only need to hold onto the last column of calculated results\n      // prevResultsCol is results[i-1][:] in the original algorithm\n      // curResultsCol is results[i][:j-1] in the original algorithm\n      curResultsCol.push(calcVal(i, j, prevResultsCol, curResultsCol));\n    }\n    prevResultsCol = curResultsCol;\n  }\n\n  return prevResultsCol[shortCurve.length - 1];\n};\n\n/** break up long segments in the curve into smaller segments of len maxLen or smaller */\nexport const subdivideCurve = (curve: Point[], maxLen = 0.05) => {\n  const newCurve = curve.slice(0, 1);\n\n  for (const point of curve.slice(1)) {\n    const prevPoint = newCurve[newCurve.length - 1];\n    const segLen = distance(point, prevPoint);\n    if (segLen > maxLen) {\n      const numNewPoints = Math.ceil(segLen / maxLen);\n      const newSegLen = segLen / numNewPoints;\n      for (let i = 0; i < numNewPoints; i++) {\n        newCurve.push(_extendPointOnLine(point, prevPoint, -1 * newSegLen * (i + 1)));\n      }\n    } else {\n      newCurve.push(point);\n    }\n  }\n\n  return newCurve;\n};\n\n/** redraw the curve using numPoints equally spaced out along the length of the curve */\nexport const outlineCurve = (curve: Point[], numPoints = 30) => {\n  const curveLen = length(curve);\n  const segmentLen = curveLen / (numPoints - 1);\n  const outlinePoints = [curve[0]];\n  const endPoint = arrLast(curve);\n  const remainingCurvePoints = curve.slice(1);\n\n  for (let i = 0; i < numPoints - 2; i++) {\n    let lastPoint: Point = arrLast(outlinePoints);\n    let remainingDist = segmentLen;\n    let outlinePointFound = false;\n    while (!outlinePointFound) {\n      const nextPointDist = distance(lastPoint, remainingCurvePoints[0]);\n      if (nextPointDist < remainingDist) {\n        remainingDist -= nextPointDist;\n        lastPoint = remainingCurvePoints.shift()!;\n      } else {\n        const nextPoint = _extendPointOnLine(\n          lastPoint,\n          remainingCurvePoints[0],\n          remainingDist - nextPointDist,\n        );\n        outlinePoints.push(nextPoint);\n        outlinePointFound = true;\n      }\n    }\n  }\n\n  outlinePoints.push(endPoint);\n\n  return outlinePoints;\n};\n\n/** translate and scale from https://en.wikipedia.org/wiki/Procrustes_analysis */\nexport const normalizeCurve = (curve: Point[]) => {\n  const outlinedCurve = outlineCurve(curve);\n  const meanX = average(outlinedCurve.map((point) => point.x));\n  const meanY = average(outlinedCurve.map((point) => point.y));\n  const mean = { x: meanX, y: meanY };\n  const translatedCurve = outlinedCurve.map((point) => subtract(point, mean));\n  const scale = Math.sqrt(\n    average([\n      Math.pow(translatedCurve[0].x, 2) + Math.pow(translatedCurve[0].y, 2),\n      Math.pow(arrLast(translatedCurve).x, 2) + Math.pow(arrLast(translatedCurve).y, 2),\n    ]),\n  );\n  const scaledCurve = translatedCurve.map((point) => ({\n    x: point.x / scale,\n    y: point.y / scale,\n  }));\n  return subdivideCurve(scaledCurve);\n};\n\n// rotate around the origin\nexport const rotate = (curve: Point[], theta: number) => {\n  return curve.map((point) => ({\n    x: Math.cos(theta) * point.x - Math.sin(theta) * point.y,\n    y: Math.sin(theta) * point.x + Math.cos(theta) * point.y,\n  }));\n};\n\n// remove intermediate points that are on the same line as the points to either side\nexport const _filterParallelPoints = (points: Point[]) => {\n  if (points.length < 3) return points;\n  const filteredPoints = [points[0], points[1]];\n  points.slice(2).forEach((point) => {\n    const numFilteredPoints = filteredPoints.length;\n    const curVect = subtract(point, filteredPoints[numFilteredPoints - 1]);\n    const prevVect = subtract(\n      filteredPoints[numFilteredPoints - 1],\n      filteredPoints[numFilteredPoints - 2],\n    );\n    // this is the z coord of the cross-product. If this is 0 then they're parallel\n    const isParallel = curVect.y * prevVect.x - curVect.x * prevVect.y === 0;\n    if (isParallel) {\n      filteredPoints.pop();\n    }\n    filteredPoints.push(point);\n  });\n  return filteredPoints;\n};\n\nexport function getPathString(points: Point[], close = false) {\n  const start = round(points[0]);\n  const remainingPoints = points.slice(1);\n  let pathString = `M ${start.x} ${start.y}`;\n  remainingPoints.forEach((point) => {\n    const roundedPoint = round(point);\n    pathString += ` L ${roundedPoint.x} ${roundedPoint.y}`;\n  });\n  if (close) {\n    pathString += 'Z';\n  }\n  return pathString;\n}\n\n/** take points on a path and move their start point backwards by distance */\nexport const extendStart = (points: Point[], dist: number) => {\n  const filteredPoints = _filterParallelPoints(points);\n  if (filteredPoints.length < 2) return filteredPoints;\n  const p1 = filteredPoints[1];\n  const p2 = filteredPoints[0];\n  const newStart = _extendPointOnLine(p1, p2, dist);\n  const extendedPoints = filteredPoints.slice(1);\n  extendedPoints.unshift(newStart);\n  return extendedPoints;\n};\n","import { subtract, distance, length } from '../geometry';\nimport { Point } from '../typings/types';\n\nexport default class Stroke {\n  path: string;\n  points: Point[];\n  strokeNum: number;\n  isInRadical: boolean;\n\n  constructor(path: string, points: Point[], strokeNum: number, isInRadical = false) {\n    this.path = path;\n    this.points = points;\n    this.strokeNum = strokeNum;\n    this.isInRadical = isInRadical;\n  }\n\n  getStartingPoint() {\n    return this.points[0];\n  }\n\n  getEndingPoint() {\n    return this.points[this.points.length - 1];\n  }\n\n  getLength(): number {\n    return length(this.points);\n  }\n\n  getVectors() {\n    let lastPoint = this.points[0];\n    const pointsSansFirst = this.points.slice(1);\n    return pointsSansFirst.map((point) => {\n      const vector = subtract(point, lastPoint);\n      lastPoint = point;\n      return vector;\n    });\n  }\n\n  getDistance(point: Point) {\n    const distances = this.points.map((strokePoint) => distance(strokePoint, point));\n    return Math.min(...distances);\n  }\n\n  getAverageDistance(points: Point[]) {\n    const totalDist = points.reduce((acc, point) => acc + this.getDistance(point), 0);\n    return totalDist / points.length;\n  }\n}\n","import Stroke from './Stroke';\n\nexport default class Character {\n  symbol: string;\n  strokes: Stroke[];\n\n  constructor(symbol: string, strokes: Stroke[]) {\n    this.symbol = symbol;\n    this.strokes = strokes;\n  }\n}\n","import Stroke from './models/Stroke';\nimport Character from './models/Character';\nimport { CharacterJson } from './typings/types';\n\nfunction generateStrokes({ radStrokes, strokes, medians }: CharacterJson) {\n  const isInRadical = (strokeNum: number) => (radStrokes?.indexOf(strokeNum) ?? -1) >= 0;\n  return strokes.map((path, index) => {\n    const points = medians[index].map((pointData) => {\n      const [x, y] = pointData;\n      return { x, y };\n    });\n    return new Stroke(path, points, index, isInRadical(index));\n  });\n}\n\nexport default function parseCharData(symbol: string, charJson: CharacterJson) {\n  const strokes = generateStrokes(charJson);\n  return new Character(symbol, strokes);\n}\n","import { Point } from './typings/types';\n\n// All makemeahanzi characters have the same bounding box\nconst CHARACTER_BOUNDS = [\n  { x: 0, y: -124 },\n  { x: 1024, y: 900 },\n];\nconst [from, to] = CHARACTER_BOUNDS;\nconst preScaledWidth = to.x - from.x;\nconst preScaledHeight = to.y - from.y;\n\nexport type PositionerOptions = {\n  /** Default: 0 */\n  width: number;\n  /** Default: 0 */\n  height: number;\n  /** Default: 20 */\n  padding: number;\n};\n\nexport default class Positioner {\n  padding: number;\n  width: number;\n  height: number;\n  xOffset: number;\n  yOffset: number;\n  scale: number;\n\n  constructor(options: PositionerOptions) {\n    const { padding, width, height } = options;\n    this.padding = padding;\n    this.width = width;\n    this.height = height;\n\n    const effectiveWidth = width - 2 * padding;\n    const effectiveHeight = height - 2 * padding;\n    const scaleX = effectiveWidth / preScaledWidth;\n    const scaleY = effectiveHeight / preScaledHeight;\n\n    this.scale = Math.min(scaleX, scaleY);\n\n    const xCenteringBuffer = padding + (effectiveWidth - this.scale * preScaledWidth) / 2;\n    const yCenteringBuffer =\n      padding + (effectiveHeight - this.scale * preScaledHeight) / 2;\n\n    this.xOffset = -1 * from.x * this.scale + xCenteringBuffer;\n    this.yOffset = -1 * from.y * this.scale + yCenteringBuffer;\n  }\n\n  convertExternalPoint(point: Point) {\n    const x = (point.x - this.xOffset) / this.scale;\n    const y = (this.height - this.yOffset - point.y) / this.scale;\n    return { x, y };\n  }\n}\n","import { average } from './utils';\nimport {\n  cosineSimilarity,\n  equals,\n  frechetDist,\n  distance,\n  subtract,\n  normalizeCurve,\n  rotate,\n  length,\n} from './geometry';\nimport { Point } from './typings/types';\nimport UserStroke from './models/UserStroke';\nimport Stroke from './models/Stroke';\nimport Character from './models/Character';\n\nconst AVG_DIST_THRESHOLD = 350; // bigger = more lenient\nconst COSINE_SIMILARITY_THRESHOLD = 0; // -1 to 1, smaller = more lenient\nconst START_AND_END_DIST_THRESHOLD = 250; // bigger = more lenient\nconst FRECHET_THRESHOLD = 0.4; // bigger = more lenient\nconst MIN_LEN_THRESHOLD = 0.35; // smaller = more lenient\n\nexport default function strokeMatches(\n  userStroke: UserStroke,\n  character: Character,\n  strokeNum: number,\n  options: {\n    leniency?: number;\n    isOutlineVisible?: boolean;\n  } = {},\n) {\n  const strokes = character.strokes;\n  const points = stripDuplicates(userStroke.points);\n\n  if (points.length < 2) {\n    return null;\n  }\n\n  const { isMatch, avgDist } = getMatchData(points, strokes[strokeNum], options);\n\n  if (!isMatch) {\n    return false;\n  }\n\n  // if there is a better match among strokes the user hasn't drawn yet, the user probably drew the wrong stroke\n  const laterStrokes = strokes.slice(strokeNum + 1);\n  let closestMatchDist = avgDist;\n\n  for (let i = 0; i < laterStrokes.length; i++) {\n    const { isMatch, avgDist } = getMatchData(points, laterStrokes[i], options);\n    if (isMatch && avgDist < closestMatchDist) {\n      closestMatchDist = avgDist;\n    }\n  }\n  // if there's a better match, rather that returning false automatically, try reducing leniency instead\n  // if leniency is already really high we can allow some similar strokes to pass\n  if (closestMatchDist < avgDist) {\n    // adjust leniency between 0.3 and 0.6 depending on how much of a better match the new match is\n    const leniencyAdjustment = (0.6 * (closestMatchDist + avgDist)) / (2 * avgDist);\n    const { isMatch } = getMatchData(points, strokes[strokeNum], {\n      ...options,\n      leniency: (options.leniency || 1) * leniencyAdjustment,\n    });\n    return isMatch;\n  }\n  return true;\n}\n\nconst startAndEndMatches = (points: Point[], closestStroke: Stroke, leniency: number) => {\n  const startingDist = distance(closestStroke.getStartingPoint(), points[0]);\n  const endingDist = distance(closestStroke.getEndingPoint(), points[points.length - 1]);\n  return (\n    startingDist <= START_AND_END_DIST_THRESHOLD * leniency &&\n    endingDist <= START_AND_END_DIST_THRESHOLD * leniency\n  );\n};\n\n// returns a list of the direction of all segments in the line connecting the points\nconst getEdgeVectors = (points: Point[]) => {\n  const vectors: Point[] = [];\n  let lastPoint = points[0];\n  points.slice(1).forEach((point) => {\n    vectors.push(subtract(point, lastPoint));\n    lastPoint = point;\n  });\n  return vectors;\n};\n\nconst directionMatches = (points: Point[], stroke: Stroke) => {\n  const edgeVectors = getEdgeVectors(points);\n  const strokeVectors = stroke.getVectors();\n  const similarities = edgeVectors.map((edgeVector) => {\n    const strokeSimilarities = strokeVectors.map((strokeVector) =>\n      cosineSimilarity(strokeVector, edgeVector),\n    );\n    return Math.max(...strokeSimilarities);\n  });\n  const avgSimilarity = average(similarities);\n  return avgSimilarity > COSINE_SIMILARITY_THRESHOLD;\n};\n\nconst lengthMatches = (points: Point[], stroke: Stroke, leniency: number) => {\n  return (\n    (leniency * (length(points) + 25)) / (stroke.getLength() + 25) >= MIN_LEN_THRESHOLD\n  );\n};\n\nconst stripDuplicates = (points: Point[]) => {\n  if (points.length < 2) return points;\n  const [firstPoint, ...rest] = points;\n  const dedupedPoints = [firstPoint];\n\n  for (const point of rest) {\n    if (!equals(point, dedupedPoints[dedupedPoints.length - 1])) {\n      dedupedPoints.push(point);\n    }\n  }\n\n  return dedupedPoints;\n};\n\nconst SHAPE_FIT_ROTATIONS = [\n  Math.PI / 16,\n  Math.PI / 32,\n  0,\n  (-1 * Math.PI) / 32,\n  (-1 * Math.PI) / 16,\n];\n\nconst shapeFit = (curve1: Point[], curve2: Point[], leniency: number) => {\n  const normCurve1 = normalizeCurve(curve1);\n  const normCurve2 = normalizeCurve(curve2);\n  let minDist = Infinity;\n  SHAPE_FIT_ROTATIONS.forEach((theta) => {\n    const dist = frechetDist(normCurve1, rotate(normCurve2, theta));\n    if (dist < minDist) {\n      minDist = dist;\n    }\n  });\n  return minDist <= FRECHET_THRESHOLD * leniency;\n};\n\nconst getMatchData = (\n  points: Point[],\n  stroke: Stroke,\n  options: { leniency?: number; isOutlineVisible?: boolean },\n) => {\n  const { leniency = 1, isOutlineVisible = false } = options;\n  const avgDist = stroke.getAverageDistance(points);\n  const distMod = isOutlineVisible || stroke.strokeNum > 0 ? 0.5 : 1;\n  const withinDistThresh = avgDist <= AVG_DIST_THRESHOLD * distMod * leniency;\n  // short circuit for faster matching\n  if (!withinDistThresh) {\n    return { isMatch: false, avgDist };\n  }\n  const startAndEndMatch = startAndEndMatches(points, stroke, leniency);\n  const directionMatch = directionMatches(points, stroke);\n  const shapeMatch = shapeFit(points, stroke.points, leniency);\n  const lengthMatch = lengthMatches(points, stroke, leniency);\n  return {\n    isMatch:\n      withinDistThresh && startAndEndMatch && directionMatch && shapeMatch && lengthMatch,\n    avgDist,\n  };\n};\n","import { Point } from '../typings/types';\n\nexport default class UserStroke {\n  id: number;\n  points: Point[];\n  externalPoints: Point[];\n\n  constructor(id: number, startingPoint: Point, startingExternalPoint: Point) {\n    this.id = id;\n    this.points = [startingPoint];\n    this.externalPoints = [startingExternalPoint];\n  }\n\n  appendPoint(point: Point, externalPoint: Point) {\n    this.points.push(point);\n    this.externalPoints.push(externalPoint);\n  }\n}\n","import {\n  cancelAnimationFrame,\n  requestAnimationFrame,\n  inflate,\n  performanceNow,\n} from './utils';\nimport RenderState from './RenderState';\nimport { RecursivePartial } from './typings/types';\n\n/** Used by `Mutation` & `Delay` */\nexport interface GenericMutation<\n  TRenderStateClass extends GenericRenderStateClass = RenderState\n> {\n  /** Allows mutations starting with the provided string to be cancelled */\n  scope: string;\n  /** Can be useful for checking whether the mutation is running */\n  _runningPromise: Promise<void> | undefined;\n  run(renderState: TRenderStateClass): Promise<void>;\n  pause(): void;\n  resume(): void;\n  cancel(renderState: TRenderStateClass): void;\n}\n\nexport type MutationChain = GenericMutation<any>[];\n\nclass Delay implements GenericMutation {\n  scope: string;\n  _runningPromise: Promise<void> | undefined;\n  _duration: number;\n  _startTime: number | null;\n  _paused: boolean;\n  _timeout!: NodeJS.Timeout;\n  _resolve: (() => void) | undefined;\n\n  constructor(duration: number) {\n    this._duration = duration;\n    this._startTime = null;\n    this._paused = false;\n    this.scope = `delay.${duration}`;\n  }\n\n  run() {\n    this._startTime = performanceNow();\n    this._runningPromise = new Promise((resolve) => {\n      this._resolve = resolve;\n      // @ts-ignore return type of \"setTimeout\" in builds is parsed as `number` instead of `Timeout`\n      this._timeout = setTimeout(() => this.cancel(), this._duration);\n    }) as Promise<void>;\n    return this._runningPromise;\n  }\n\n  pause() {\n    if (this._paused) return;\n    // to pause, clear the timeout and rewrite this._duration with whatever time is remaining\n    const elapsedDelay = performance.now() - (this._startTime || 0);\n    this._duration = Math.max(0, this._duration - elapsedDelay);\n    clearTimeout(this._timeout);\n    this._paused = true;\n  }\n\n  resume() {\n    if (!this._paused) return;\n    this._startTime = performance.now();\n    // @ts-ignore return type of \"setTimeout\" in builds is parsed as `number` instead of `Timeout`\n    this._timeout = setTimeout(() => this.cancel(), this._duration);\n    this._paused = false;\n  }\n\n  cancel() {\n    clearTimeout(this._timeout!);\n    if (this._resolve) {\n      this._resolve();\n    }\n    this._resolve = undefined;\n  }\n}\n\ntype GenericRenderStateClass<T = any> = {\n  state: T;\n  updateState(changes: RecursivePartial<T>): void;\n};\n\nexport default class Mutation<\n  TRenderStateClass extends GenericRenderStateClass,\n  TRenderStateObj = TRenderStateClass['state']\n> implements GenericMutation<TRenderStateClass> {\n  static Delay = Delay;\n\n  scope: string;\n  _runningPromise: Promise<void> | undefined;\n  _valuesOrCallable: any;\n  _duration: number;\n  _force: boolean | undefined;\n  _pausedDuration: number;\n  _startPauseTime: number | null;\n\n  // Only set on .run()\n  _startTime: number | undefined;\n  _startState: RecursivePartial<TRenderStateObj> | undefined;\n  _renderState: TRenderStateClass | undefined;\n  _frameHandle: number | undefined;\n  _values: RecursivePartial<TRenderStateObj> | undefined;\n  _resolve: ((_val?: any) => void) | undefined;\n\n  /**\n   *\n   * @param scope a string representation of what fields this mutation affects from the state. This is used to cancel conflicting mutations\n   * @param valuesOrCallable a thunk containing the value to set, or a callback which will return those values\n   */\n  constructor(\n    scope: string,\n    valuesOrCallable: any,\n    options: {\n      duration?: number;\n      /** Updates render state regardless if cancelled */\n      force?: boolean;\n    } = {},\n  ) {\n    this.scope = scope;\n    this._valuesOrCallable = valuesOrCallable;\n    this._duration = options.duration || 0;\n    this._force = options.force;\n    this._pausedDuration = 0;\n    this._startPauseTime = null;\n  }\n\n  run(renderState: TRenderStateClass): Promise<void> {\n    if (!this._values) this._inflateValues(renderState);\n    if (this._duration === 0) renderState.updateState(this._values!);\n    if (this._duration === 0 || isAlreadyAtEnd(renderState.state, this._values)) {\n      return Promise.resolve();\n    }\n    this._renderState = renderState;\n    this._startState = renderState.state;\n    this._startTime = performance.now();\n    this._frameHandle = requestAnimationFrame(this._tick);\n    return new Promise((resolve) => {\n      this._resolve = resolve;\n    });\n  }\n\n  private _inflateValues(renderState: TRenderStateClass) {\n    let values = this._valuesOrCallable;\n    if (typeof this._valuesOrCallable === 'function') {\n      values = this._valuesOrCallable(renderState.state);\n    }\n    this._values = inflate(this.scope, values);\n  }\n\n  pause() {\n    if (this._startPauseTime !== null) {\n      return;\n    }\n    if (this._frameHandle) {\n      cancelAnimationFrame(this._frameHandle);\n    }\n    this._startPauseTime = performance.now();\n  }\n\n  resume() {\n    if (this._startPauseTime === null) {\n      return;\n    }\n    this._frameHandle = requestAnimationFrame(this._tick);\n    this._pausedDuration += performance.now() - this._startPauseTime;\n    this._startPauseTime = null;\n  }\n\n  private _tick = (timing: number) => {\n    if (this._startPauseTime !== null) {\n      return;\n    }\n\n    const progress = Math.min(\n      1,\n      (timing - this._startTime! - this._pausedDuration) / this._duration,\n    );\n\n    if (progress === 1) {\n      this._renderState!.updateState(this._values!);\n      this._frameHandle = undefined;\n      this.cancel(this._renderState!);\n    } else {\n      const easedProgress = ease(progress);\n      const stateChanges = getPartialValues(\n        this._startState as TRenderStateObj,\n        this._values!,\n        easedProgress,\n      );\n\n      this._renderState!.updateState(stateChanges);\n      this._frameHandle = requestAnimationFrame(this._tick);\n    }\n  };\n\n  cancel(renderState: TRenderStateClass) {\n    this._resolve?.();\n    this._resolve = undefined;\n\n    cancelAnimationFrame(this._frameHandle || -1);\n    this._frameHandle = undefined;\n\n    if (this._force) {\n      if (!this._values) this._inflateValues(renderState);\n      renderState.updateState(this._values!);\n    }\n  }\n}\n\nfunction getPartialValues<T>(\n  startValues: T | undefined,\n  endValues: RecursivePartial<T> | undefined,\n  progress: number,\n) {\n  const target: RecursivePartial<T> = {};\n\n  for (const key in endValues) {\n    const endValue = endValues[key];\n    const startValue = startValues?.[key];\n    if (typeof startValue === 'number' && typeof endValue === 'number' && endValue >= 0) {\n      target[key] = progress * (endValue - startValue) + startValue;\n    } else {\n      target[key] = getPartialValues(startValue, endValue, progress);\n    }\n  }\n  return target;\n}\n\nfunction isAlreadyAtEnd<T>(\n  startValues: T | undefined,\n  endValues: RecursivePartial<T> | undefined,\n) {\n  for (const key in endValues) {\n    const endValue = endValues[key];\n    const startValue = startValues?.[key];\n    if (endValue >= 0) {\n      if (endValue !== startValue) {\n        return false;\n      }\n    } else if (!isAlreadyAtEnd(startValue, endValue)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// from https://github.com/maxwellito/vivus\nconst ease = (x: number) => -Math.cos(x * Math.PI) / 2 + 0.5;\n","import Stroke from './models/Stroke';\nimport { ColorObject, RecursivePartial } from './typings/types';\nimport Character from './models/Character';\nimport Mutation, { MutationChain } from './Mutation';\nimport { objRepeat } from './utils';\nimport { CharacterName, CharacterRenderState, RenderStateObject } from './RenderState';\n\nexport const showStrokes = (\n  charName: CharacterName,\n  character: Character,\n  duration: number,\n): MutationChain => {\n  return [\n    new Mutation(\n      `character.${charName}.strokes`,\n      objRepeat(\n        { opacity: 1, displayPortion: 1 },\n        character.strokes.length,\n      ) as CharacterRenderState['strokes'],\n      { duration, force: true },\n    ),\n  ];\n};\n\nexport const showCharacter = (\n  charName: CharacterName,\n  character: Character,\n  duration: number,\n): MutationChain => {\n  return [\n    new Mutation(\n      `character.${charName}`,\n      {\n        opacity: 1,\n        strokes: objRepeat({ opacity: 1, displayPortion: 1 }, character.strokes.length),\n      },\n      { duration, force: true },\n    ),\n  ];\n};\n\nexport const hideCharacter = (\n  charName: CharacterName,\n  character: Character,\n  duration?: number,\n): MutationChain => {\n  return [\n    new Mutation(`character.${charName}.opacity`, 0, { duration, force: true }),\n    ...showStrokes(charName, character, 0),\n  ];\n};\n\nexport const updateColor = (\n  colorName: string,\n  colorVal: ColorObject | null,\n  duration: number,\n) => {\n  return [new Mutation(`options.${colorName}`, colorVal, { duration })];\n};\n\nexport const highlightStroke = (\n  stroke: Stroke,\n  color: ColorObject | null,\n  speed: number,\n): MutationChain => {\n  const strokeNum = stroke.strokeNum;\n  const duration = (stroke.getLength() + 600) / (3 * speed);\n  return [\n    new Mutation('character.highlight.strokeColor', color),\n    new Mutation('character.highlight', {\n      opacity: 1,\n      strokes: {\n        [strokeNum]: {\n          displayPortion: 0,\n          opacity: 0,\n        },\n      },\n    }),\n    new Mutation(\n      `character.highlight.strokes.${strokeNum}`,\n      {\n        displayPortion: 1,\n        opacity: 1,\n      },\n      { duration },\n    ),\n    new Mutation(`character.highlight.strokes.${strokeNum}.opacity`, 0, { duration }),\n  ];\n};\n\nexport const animateStroke = (\n  charName: CharacterName,\n  stroke: Stroke,\n  speed: number,\n): MutationChain => {\n  const strokeNum = stroke.strokeNum;\n  const duration = (stroke.getLength() + 600) / (3 * speed);\n  return [\n    new Mutation(`character.${charName}`, {\n      opacity: 1,\n      strokes: {\n        [strokeNum]: {\n          displayPortion: 0,\n          opacity: 1,\n        },\n      },\n    }),\n    new Mutation(`character.${charName}.strokes.${strokeNum}.displayPortion`, 1, {\n      duration,\n    }),\n  ];\n};\n\nexport const animateSingleStroke = (\n  charName: CharacterName,\n  character: Character,\n  strokeNum: number,\n  speed: number,\n): MutationChain => {\n  const mutationStateFunc = (state: RenderStateObject) => {\n    const curCharState = state.character[charName];\n    const mutationState: RecursivePartial<CharacterRenderState> = {\n      opacity: 1,\n      strokes: {},\n    };\n    for (let i = 0; i < character.strokes.length; i++) {\n      mutationState.strokes![i] = {\n        opacity: curCharState.opacity * curCharState.strokes[i].opacity,\n      };\n    }\n    return mutationState;\n  };\n  const stroke = character.strokes[strokeNum];\n  return [\n    new Mutation(`character.${charName}`, mutationStateFunc),\n    ...animateStroke(charName, stroke, speed),\n  ];\n};\n\nexport const showStroke = (\n  charName: CharacterName,\n  strokeNum: number,\n  duration: number,\n): MutationChain => {\n  return [\n    new Mutation(\n      `character.${charName}.strokes.${strokeNum}`,\n      {\n        displayPortion: 1,\n        opacity: 1,\n      },\n      { duration, force: true },\n    ),\n  ];\n};\n\nexport const animateCharacter = (\n  charName: CharacterName,\n  character: Character,\n  fadeDuration: number,\n  speed: number,\n  delayBetweenStrokes: number,\n): MutationChain => {\n  let mutations: MutationChain = hideCharacter(charName, character, fadeDuration);\n  mutations = mutations.concat(showStrokes(charName, character, 0));\n  mutations.push(\n    new Mutation(\n      `character.${charName}`,\n      {\n        opacity: 1,\n        strokes: objRepeat({ opacity: 0 }, character.strokes.length),\n      },\n      { force: true },\n    ),\n  );\n  character.strokes.forEach((stroke, i) => {\n    if (i > 0) mutations.push(new Mutation.Delay(delayBetweenStrokes));\n    mutations = mutations.concat(animateStroke(charName, stroke, speed));\n  });\n  return mutations;\n};\n\nexport const animateCharacterLoop = (\n  charName: CharacterName,\n  character: Character,\n  fadeDuration: number,\n  speed: number,\n  delayBetweenStrokes: number,\n  delayBetweenLoops: number,\n): MutationChain => {\n  const mutations = animateCharacter(\n    charName,\n    character,\n    fadeDuration,\n    speed,\n    delayBetweenStrokes,\n  );\n  mutations.push(new Mutation.Delay(delayBetweenLoops));\n  return mutations;\n};\n","import Mutation, { MutationChain } from './Mutation';\nimport * as characterActions from './characterActions';\nimport { objRepeat } from './utils';\nimport Character from './models/Character';\nimport { Point } from './typings/types';\n\nexport const startQuiz = (character: Character, fadeDuration: number): MutationChain => {\n  return [\n    ...characterActions.hideCharacter('main', character, fadeDuration),\n    new Mutation(\n      'character.highlight',\n      {\n        opacity: 1,\n        strokes: objRepeat({ opacity: 0 }, character.strokes.length),\n      },\n      { force: true },\n    ),\n    new Mutation(\n      'character.main',\n      {\n        opacity: 1,\n        strokes: objRepeat({ opacity: 0 }, character.strokes.length),\n      },\n      { force: true },\n    ),\n  ];\n};\n\nexport const startUserStroke = (id: string | number, point: Point): MutationChain => {\n  return [\n    new Mutation('quiz.activeUserStrokeId', id, { force: true }),\n    new Mutation(\n      `userStrokes.${id}`,\n      {\n        points: [point],\n        opacity: 1,\n      },\n      { force: true },\n    ),\n  ];\n};\n\nexport const updateUserStroke = (\n  userStrokeId: string | number,\n  points: Point[],\n): MutationChain => {\n  return [new Mutation(`userStrokes.${userStrokeId}.points`, points, { force: true })];\n};\n\nexport const removeUserStroke = (\n  userStrokeId: string | number,\n  duration: number,\n): MutationChain => {\n  return [\n    new Mutation(`userStrokes.${userStrokeId}.opacity`, 0, { duration }),\n    new Mutation(`userStrokes.${userStrokeId}`, null, { force: true }),\n  ];\n};\n\nexport const highlightCompleteChar = (\n  character: Character,\n  duration: number,\n): MutationChain => {\n  return [\n    ...characterActions.hideCharacter('highlight', character),\n    ...characterActions.showCharacter('highlight', character, duration / 2),\n    ...characterActions.hideCharacter('highlight', character, duration / 2),\n  ];\n};\n\nexport const highlightStroke = characterActions.highlightStroke;\n","import strokeMatches from './strokeMatches';\nimport UserStroke from './models/UserStroke';\nimport Positioner from './Positioner';\nimport { counter, colorStringToVals } from './utils';\nimport * as quizActions from './quizActions';\nimport * as geometry from './geometry';\nimport * as characterActions from './characterActions';\nimport Character from './models/Character';\nimport { ParsedHanziWriterOptions, Point, StrokeData } from './typings/types';\nimport RenderState from './RenderState';\nimport { MutationChain } from './Mutation';\n\nconst getDrawnPath = (userStroke: UserStroke) => ({\n  pathString: geometry.getPathString(userStroke.externalPoints),\n  points: userStroke.points.map((point) => geometry.round(point)),\n});\n\nexport default class Quiz {\n  _character: Character;\n  _renderState: RenderState;\n  _isActive: boolean;\n  _positioner: Positioner;\n\n  /** Set on startQuiz */\n  _options: ParsedHanziWriterOptions | undefined;\n  _currentStrokeIndex = 0;\n  _mistakesOnStroke = 0;\n  _totalMistakes = 0;\n  _userStroke: UserStroke | undefined;\n\n  constructor(character: Character, renderState: RenderState, positioner: Positioner) {\n    this._character = character;\n    this._renderState = renderState;\n    this._isActive = false;\n    this._positioner = positioner;\n  }\n\n  startQuiz(options: ParsedHanziWriterOptions) {\n    this._isActive = true;\n    this._options = options;\n    this._currentStrokeIndex = 0;\n    this._mistakesOnStroke = 0;\n    this._totalMistakes = 0;\n\n    return this._renderState.run(\n      quizActions.startQuiz(this._character, options.strokeFadeDuration),\n    );\n  }\n\n  startUserStroke(externalPoint: Point) {\n    if (!this._isActive) {\n      return null;\n    }\n    if (this._userStroke) {\n      return this.endUserStroke();\n    }\n    const point = this._positioner.convertExternalPoint(externalPoint);\n    const strokeId = counter();\n    this._userStroke = new UserStroke(strokeId, point, externalPoint);\n    return this._renderState.run(quizActions.startUserStroke(strokeId, point));\n  }\n\n  continueUserStroke(externalPoint: Point) {\n    if (!this._userStroke) {\n      return Promise.resolve();\n    }\n    const point = this._positioner.convertExternalPoint(externalPoint);\n    this._userStroke.appendPoint(point, externalPoint);\n    const nextPoints = this._userStroke.points.slice(0);\n    return this._renderState.run(\n      quizActions.updateUserStroke(this._userStroke.id, nextPoints),\n    );\n  }\n\n  endUserStroke() {\n    if (!this._userStroke) return;\n\n    this._renderState.run(\n      quizActions.removeUserStroke(\n        this._userStroke.id,\n        this._options!.drawingFadeDuration ?? 300,\n      ),\n    );\n\n    // skip single-point strokes\n    if (this._userStroke.points.length === 1) {\n      this._userStroke = undefined;\n      return;\n    }\n\n    const currentStroke = this._getCurrentStroke();\n    const isMatch = strokeMatches(\n      this._userStroke,\n      this._character,\n      this._currentStrokeIndex,\n      {\n        isOutlineVisible: this._renderState.state.character.outline.opacity > 0,\n        leniency: this._options!.leniency,\n      },\n    );\n\n    if (isMatch) {\n      this._handleSuccess();\n    } else {\n      this._handleFailure();\n\n      const {\n        showHintAfterMisses,\n        highlightColor,\n        strokeHighlightSpeed,\n      } = this._options!;\n\n      if (\n        showHintAfterMisses !== false &&\n        this._mistakesOnStroke >= showHintAfterMisses\n      ) {\n        this._renderState.run(\n          characterActions.highlightStroke(\n            currentStroke,\n            colorStringToVals(highlightColor),\n            strokeHighlightSpeed,\n          ),\n        );\n      }\n    }\n\n    this._userStroke = undefined;\n  }\n\n  cancel() {\n    this._isActive = false;\n    if (this._userStroke) {\n      this._renderState.run(\n        quizActions.removeUserStroke(\n          this._userStroke.id,\n          this._options!.drawingFadeDuration,\n        ),\n      );\n    }\n  }\n\n  _getStrokeData(isCorrect = false): StrokeData {\n    return {\n      character: this._character.symbol,\n      strokeNum: this._currentStrokeIndex,\n      mistakesOnStroke: this._mistakesOnStroke,\n      totalMistakes: this._totalMistakes,\n      strokesRemaining:\n        this._character.strokes.length - this._currentStrokeIndex - (isCorrect ? 1 : 0),\n      drawnPath: getDrawnPath(this._userStroke!),\n    };\n  }\n\n  _handleSuccess() {\n    if (!this._options) return;\n\n    const { strokes, symbol } = this._character;\n\n    const {\n      onCorrectStroke,\n      onComplete,\n      highlightOnComplete,\n      strokeFadeDuration,\n      strokeHighlightDuration,\n    } = this._options;\n\n    onCorrectStroke?.(this._getStrokeData(true));\n\n    let animation: MutationChain = characterActions.showStroke(\n      'main',\n      this._currentStrokeIndex,\n      strokeFadeDuration,\n    );\n\n    this._mistakesOnStroke = 0;\n    this._currentStrokeIndex += 1;\n\n    const isComplete = this._currentStrokeIndex === strokes.length;\n\n    if (isComplete) {\n      this._isActive = false;\n      onComplete?.({\n        character: symbol,\n        totalMistakes: this._totalMistakes,\n      });\n      if (highlightOnComplete) {\n        animation = animation.concat(\n          quizActions.highlightCompleteChar(\n            this._character,\n            (strokeHighlightDuration || 0) * 2,\n          ),\n        );\n      }\n    }\n\n    this._renderState.run(animation);\n  }\n\n  _handleFailure() {\n    this._mistakesOnStroke += 1;\n    this._totalMistakes += 1;\n    this._options!.onMistake?.(this._getStrokeData());\n  }\n\n  _getCurrentStroke() {\n    return this._character.strokes[this._currentStrokeIndex];\n  }\n}\n","export function createElm(elmType: string) {\n  return document.createElementNS('http://www.w3.org/2000/svg', elmType);\n}\n\nexport function attr(elm: Element, name: string, value: string) {\n  elm.setAttributeNS(null, name, value);\n}\n\nexport function attrs(elm: Element, attrsMap: Record<string, string>) {\n  Object.keys(attrsMap).forEach((attrName) => attr(elm, attrName, attrsMap[attrName]));\n}\n\n// inspired by https://talk.observablehq.com/t/hanzi-writer-renders-incorrectly-inside-an-observable-notebook-on-a-mobile-browser/1898\nexport function urlIdRef(id: string) {\n  let prefix = '';\n  if (window.location && window.location.href) {\n    prefix = window.location.href.replace(/#[^#]*$/, '').replace(/\"/gi, '%22');\n  }\n  return `url(\"${prefix}#${id}\")`;\n}\n\nexport function removeElm(elm: Element | undefined) {\n  elm?.parentNode?.removeChild(elm);\n}\n","import Stroke from '../models/Stroke';\nimport { ColorObject } from '../typings/types';\n\nexport default class StrokeRendererBase {\n  _pathLength: number;\n  stroke: Stroke;\n  static STROKE_WIDTH = 200;\n\n  constructor(stroke: Stroke) {\n    this.stroke = stroke;\n    this._pathLength = stroke.getLength() + StrokeRendererBase.STROKE_WIDTH / 2;\n  }\n\n  _getStrokeDashoffset(displayPortion: number) {\n    return this._pathLength * 0.999 * (1 - displayPortion);\n  }\n\n  _getColor({\n    strokeColor,\n    radicalColor,\n  }: {\n    strokeColor: ColorObject;\n    radicalColor?: ColorObject | null;\n  }) {\n    return radicalColor && this.stroke.isInRadical ? radicalColor : strokeColor;\n  }\n}\n","import { counter } from '../../utils';\nimport * as svg from './svgUtils';\nimport { extendStart, getPathString } from '../../geometry';\nimport StrokeRendererBase from '../StrokeRendererBase';\nimport Stroke from '../../models/Stroke';\nimport SVGRenderTarget from './RenderTarget';\nimport { ColorObject } from '../../typings/types';\n\nconst STROKE_WIDTH = 200;\n\ntype StrokeRenderProps = {\n  strokeColor: ColorObject;\n  radicalColor: ColorObject | null;\n  displayPortion: number;\n  opacity: number;\n};\n\n/** This is a stroke composed of several stroke parts **/\nexport default class StrokeRenderer extends StrokeRendererBase {\n  _oldProps: StrokeRenderProps | undefined = undefined;\n\n  _animationPath: SVGPathElement | undefined;\n  _clip: SVGClipPathElement | undefined;\n  _strokePath: SVGPathElement | undefined;\n\n  constructor(stroke: Stroke) {\n    super(stroke);\n  }\n\n  mount(target: SVGRenderTarget) {\n    this._animationPath = svg.createElm('path') as SVGPathElement;\n    this._clip = svg.createElm('clipPath') as SVGClipPathElement;\n    this._strokePath = svg.createElm('path') as SVGPathElement;\n    const maskId = `mask-${counter()}`;\n    svg.attr(this._clip, 'id', maskId);\n\n    svg.attr(this._strokePath, 'd', this.stroke.path);\n    this._animationPath.style.opacity = '0';\n    svg.attr(this._animationPath, 'clip-path', svg.urlIdRef(maskId));\n\n    const extendedMaskPoints = extendStart(this.stroke.points, STROKE_WIDTH / 2);\n    svg.attr(this._animationPath, 'd', getPathString(extendedMaskPoints));\n    svg.attrs(this._animationPath, {\n      stroke: '#FFFFFF',\n      'stroke-width': STROKE_WIDTH.toString(),\n      fill: 'none',\n      'stroke-linecap': 'round',\n      'stroke-linejoin': 'miter',\n      'stroke-dasharray': `${this._pathLength},${this._pathLength}`,\n    });\n\n    this._clip.appendChild(this._strokePath);\n    target.defs.appendChild(this._clip);\n    target.svg.appendChild(this._animationPath);\n    return this;\n  }\n\n  render(props: StrokeRenderProps) {\n    if (props === this._oldProps || !this._animationPath) {\n      return;\n    }\n\n    if (props.displayPortion !== this._oldProps?.displayPortion) {\n      this._animationPath.style.strokeDashoffset = this._getStrokeDashoffset(\n        props.displayPortion,\n      ).toString();\n    }\n\n    const color = this._getColor(props);\n\n    if (!this._oldProps || color !== this._getColor(this._oldProps)) {\n      const { r, g, b, a } = color;\n      svg.attrs(this._animationPath, { stroke: `rgba(${r},${g},${b},${a})` });\n    }\n\n    if (props.opacity !== this._oldProps?.opacity) {\n      this._animationPath.style.opacity = props.opacity.toString();\n    }\n    this._oldProps = props;\n  }\n}\n","import { isMsBrowser } from '../../utils';\nimport StrokeRenderer from './StrokeRenderer';\nimport SVGRenderTarget from './RenderTarget';\nimport Character from '../../models/Character';\nimport { ColorObject } from '../../typings/types';\nimport { StrokeRenderState } from '../../RenderState';\n\ntype SvgCharacterRenderProps = {\n  opacity: number;\n  strokes: Record<number, StrokeRenderState>;\n  strokeColor: ColorObject;\n  radicalColor?: ColorObject | null;\n};\n\nexport default class CharacterRenderer {\n  _oldProps: SvgCharacterRenderProps | undefined = undefined;\n  _strokeRenderers: StrokeRenderer[];\n\n  // set on mount()\n  _group: SVGElement | SVGSVGElement | undefined;\n\n  constructor(character: Character) {\n    this._strokeRenderers = character.strokes.map((stroke) => new StrokeRenderer(stroke));\n  }\n\n  mount(target: SVGRenderTarget) {\n    const subTarget = target.createSubRenderTarget();\n    this._group = subTarget.svg;\n    this._strokeRenderers.forEach((strokeRenderer) => {\n      strokeRenderer.mount(subTarget);\n    });\n  }\n\n  render(props: SvgCharacterRenderProps) {\n    if (props === this._oldProps || !this._group) {\n      return;\n    }\n    const { opacity, strokes, strokeColor, radicalColor = null } = props;\n    if (opacity !== this._oldProps?.opacity) {\n      this._group.style.opacity = opacity.toString();\n      // MS browsers seem to have a bug where if SVG is set to display:none, it sometimes breaks.\n      // More info: https://github.com/chanind/hanzi-writer/issues/164\n      // this is just a perf improvement, so disable for MS browsers\n      if (!isMsBrowser) {\n        if (opacity === 0) {\n          this._group.style.display = 'none';\n        } else if (this._oldProps?.opacity === 0) {\n          this._group.style.removeProperty('display');\n        }\n      }\n    }\n    const colorsChanged =\n      !this._oldProps ||\n      strokeColor !== this._oldProps.strokeColor ||\n      radicalColor !== this._oldProps.radicalColor;\n\n    if (colorsChanged || strokes !== this._oldProps?.strokes) {\n      for (let i = 0; i < this._strokeRenderers.length; i++) {\n        if (\n          !colorsChanged &&\n          this._oldProps?.strokes &&\n          strokes[i] === this._oldProps.strokes[i]\n        ) {\n          continue;\n        }\n        this._strokeRenderers[i].render({\n          strokeColor,\n          radicalColor,\n          opacity: strokes[i].opacity,\n          displayPortion: strokes[i].displayPortion,\n        });\n      }\n    }\n    this._oldProps = props;\n  }\n}\n","import * as svg from './svgUtils';\nimport { getPathString } from '../../geometry';\nimport { ColorObject, Point } from '../../typings/types';\nimport SVGRenderTarget from './RenderTarget';\n\nexport type UserStrokeProps = {\n  strokeWidth: number;\n  strokeColor: ColorObject;\n  opacity: number;\n  points: Point[];\n};\n\nexport default class UserStrokeRenderer {\n  _oldProps: UserStrokeProps | undefined = undefined;\n  _path: SVGElement | undefined;\n\n  mount(target: SVGRenderTarget) {\n    this._path = svg.createElm('path');\n    target.svg.appendChild(this._path);\n  }\n\n  render(props: UserStrokeProps) {\n    if (!this._path || props === this._oldProps) {\n      return;\n    }\n    if (\n      props.strokeColor !== this._oldProps?.strokeColor ||\n      props.strokeWidth !== this._oldProps?.strokeWidth\n    ) {\n      const { r, g, b, a } = props.strokeColor;\n      svg.attrs(this._path, {\n        fill: 'none',\n        stroke: `rgba(${r},${g},${b},${a})`,\n        'stroke-width': props.strokeWidth.toString(),\n        'stroke-linecap': 'round',\n        'stroke-linejoin': 'round',\n      });\n    }\n    if (props.opacity !== this._oldProps?.opacity) {\n      svg.attr(this._path, 'opacity', props.opacity.toString());\n    }\n    if (props.points !== this._oldProps?.points) {\n      svg.attr(this._path, 'd', getPathString(props.points));\n    }\n    this._oldProps = props;\n  }\n\n  destroy() {\n    svg.removeElm(this._path);\n  }\n}\n","import { Point } from '../typings/types';\n\ntype BoundEvent = {\n  getPoint(): Point;\n  preventDefault(): void;\n};\n\n/** Generic render target */\nexport default class RenderTargetBase<\n  TElement extends\n    | HTMLElement\n    | SVGElement\n    | SVGSVGElement\n    | HTMLCanvasElement = HTMLElement\n> {\n  node: TElement;\n\n  constructor(node: TElement) {\n    this.node = node;\n  }\n\n  addPointerStartListener(callback: (arg: BoundEvent) => void) {\n    this.node.addEventListener('mousedown', (evt) => {\n      callback(this._eventify(evt as MouseEvent, this._getMousePoint));\n    });\n    this.node.addEventListener('touchstart', (evt) => {\n      callback(this._eventify(evt as TouchEvent, this._getTouchPoint));\n    });\n  }\n\n  addPointerMoveListener(callback: (arg: BoundEvent) => void) {\n    this.node.addEventListener('mousemove', (evt) => {\n      callback(this._eventify(evt as MouseEvent, this._getMousePoint));\n    });\n    this.node.addEventListener('touchmove', (evt) => {\n      callback(this._eventify(evt as TouchEvent, this._getTouchPoint));\n    });\n  }\n\n  addPointerEndListener(callback: () => void) {\n    // TODO: find a way to not need global listeners\n    document.addEventListener('mouseup', callback);\n    document.addEventListener('touchend', callback);\n  }\n\n  getBoundingClientRect() {\n    return this.node.getBoundingClientRect();\n  }\n\n  _eventify<TEvent extends Event>(evt: TEvent, pointFunc: (event: TEvent) => Point) {\n    return {\n      getPoint: () => pointFunc.call(this, evt),\n      preventDefault: () => evt.preventDefault(),\n    };\n  }\n\n  _getMousePoint(evt: MouseEvent): Point {\n    const { left, top } = this.getBoundingClientRect();\n    const x = evt.clientX - left;\n    const y = evt.clientY - top;\n    return { x, y };\n  }\n\n  _getTouchPoint(evt: TouchEvent): Point {\n    const { left, top } = this.getBoundingClientRect();\n    const x = evt.touches[0].clientX - left;\n    const y = evt.touches[0].clientY - top;\n    return { x, y };\n  }\n}\n","import { createElm, attrs } from './svgUtils';\nimport RenderTargetBase from '../RenderTargetBase';\n\nexport default class RenderTarget extends RenderTargetBase<SVGSVGElement | SVGElement> {\n  static init(elmOrId: Element | string, width = '100%', height = '100%') {\n    const element = (() => {\n      if (typeof elmOrId === 'string') {\n        return document.getElementById(elmOrId);\n      }\n      return elmOrId;\n    })();\n\n    if (!element) {\n      throw new Error(`HanziWriter target element not found: ${elmOrId}`);\n    }\n    const nodeType = element.nodeName.toUpperCase();\n\n    const svg = (() => {\n      if (nodeType === 'SVG' || nodeType === 'G') {\n        return element;\n      } else {\n        const svg = createElm('svg');\n        element.appendChild(svg);\n        return svg;\n      }\n    })() as SVGSVGElement;\n\n    attrs(svg, { width, height });\n    const defs = createElm('defs');\n    svg.appendChild(defs);\n\n    return new RenderTarget(svg, defs);\n  }\n\n  svg: SVGSVGElement | SVGElement;\n  defs: SVGElement;\n  _pt: DOMPoint | undefined;\n\n  constructor(svg: SVGElement | SVGSVGElement, defs: SVGElement) {\n    super(svg);\n\n    this.svg = svg;\n    this.defs = defs;\n\n    if ('createSVGPoint' in svg) {\n      this._pt = svg.createSVGPoint();\n    }\n  }\n\n  createSubRenderTarget() {\n    const group = createElm('g');\n    this.svg.appendChild(group);\n    return new RenderTarget(group, this.defs);\n  }\n\n  _getMousePoint(evt: MouseEvent) {\n    if (this._pt) {\n      this._pt.x = evt.clientX;\n      this._pt.y = evt.clientY;\n      if ('getScreenCTM' in this.node) {\n        const localPt = this._pt.matrixTransform(this.node.getScreenCTM()?.inverse());\n        return { x: localPt.x, y: localPt.y };\n      }\n    }\n    return super._getMousePoint.call(this, evt);\n  }\n\n  _getTouchPoint(evt: TouchEvent) {\n    if (this._pt) {\n      this._pt.x = evt.touches[0].clientX;\n      this._pt.y = evt.touches[0].clientY;\n      if ('getScreenCTM' in this.node) {\n        const localPt = this._pt.matrixTransform(\n          (this.node as SVGSVGElement).getScreenCTM()?.inverse(),\n        );\n        return { x: localPt.x, y: localPt.y };\n      }\n    }\n    return super._getTouchPoint(evt);\n  }\n}\n","import { RenderTargetInitFunction } from '../../typings/types';\nimport HanziWriterRenderer from './HanziWriterRenderer';\nimport RenderTarget from './RenderTarget';\n\nexport default {\n  HanziWriterRenderer,\n  createRenderTarget: RenderTarget.init as RenderTargetInitFunction<\n    SVGSVGElement | SVGElement\n  >,\n};\n","import CharacterRenderer from './CharacterRenderer';\nimport UserStrokeRenderer, { UserStrokeProps } from './UserStrokeRenderer';\nimport * as svg from './svgUtils';\nimport Character from '../../models/Character';\nimport Positioner from '../../Positioner';\nimport SVGRenderTarget from './RenderTarget';\nimport HanziWriterRendererBase from '../HanziWriterRendererBase';\nimport { RenderStateObject } from '../../RenderState';\n\nexport default class HanziWriterRenderer\n  implements HanziWriterRendererBase<SVGElement | SVGSVGElement, SVGRenderTarget> {\n  _character: Character;\n  _positioner: Positioner;\n  _mainCharRenderer: CharacterRenderer;\n  _outlineCharRenderer: CharacterRenderer;\n  _highlightCharRenderer: CharacterRenderer;\n  _userStrokeRenderers: Record<string, UserStrokeRenderer | undefined>;\n  _positionedTarget: SVGRenderTarget | undefined;\n\n  constructor(character: Character, positioner: Positioner) {\n    this._character = character;\n    this._positioner = positioner;\n    this._mainCharRenderer = new CharacterRenderer(character);\n    this._outlineCharRenderer = new CharacterRenderer(character);\n    this._highlightCharRenderer = new CharacterRenderer(character);\n    this._userStrokeRenderers = {};\n  }\n\n  mount(target: SVGRenderTarget) {\n    const positionedTarget = target.createSubRenderTarget();\n    const group = positionedTarget.svg;\n    const { xOffset, yOffset, height, scale } = this._positioner;\n\n    svg.attr(\n      group,\n      'transform',\n      `translate(${xOffset}, ${height - yOffset}) scale(${scale}, ${-1 * scale})`,\n    );\n    this._outlineCharRenderer.mount(positionedTarget);\n    this._mainCharRenderer.mount(positionedTarget);\n    this._highlightCharRenderer.mount(positionedTarget);\n    this._positionedTarget = positionedTarget;\n  }\n\n  render(props: RenderStateObject) {\n    const { main, outline, highlight } = props.character;\n    const {\n      outlineColor,\n      radicalColor,\n      highlightColor,\n      strokeColor,\n      drawingWidth,\n      drawingColor,\n    } = props.options;\n\n    this._outlineCharRenderer.render({\n      opacity: outline.opacity,\n      strokes: outline.strokes,\n      strokeColor: outlineColor,\n    });\n\n    this._mainCharRenderer.render({\n      opacity: main.opacity,\n      strokes: main.strokes,\n      strokeColor,\n      radicalColor: radicalColor,\n    });\n\n    this._highlightCharRenderer.render({\n      opacity: highlight.opacity,\n      strokes: highlight.strokes,\n      strokeColor: highlightColor,\n    });\n\n    const userStrokes = props.userStrokes || {};\n\n    for (const userStrokeId in this._userStrokeRenderers) {\n      if (!userStrokes[userStrokeId]) {\n        this._userStrokeRenderers[userStrokeId]?.destroy();\n        delete this._userStrokeRenderers[userStrokeId];\n      }\n    }\n\n    for (const userStrokeId in userStrokes) {\n      const stroke = userStrokes[userStrokeId];\n      if (!stroke) {\n        continue;\n      }\n      const userStrokeProps: UserStrokeProps = {\n        strokeWidth: drawingWidth,\n        strokeColor: drawingColor,\n        ...stroke,\n      };\n\n      const strokeRenderer = (() => {\n        if (this._userStrokeRenderers[userStrokeId]) {\n          return this._userStrokeRenderers[userStrokeId]!;\n        }\n        const newStrokeRenderer = new UserStrokeRenderer();\n        newStrokeRenderer.mount(this._positionedTarget!);\n        this._userStrokeRenderers[userStrokeId] = newStrokeRenderer;\n        return newStrokeRenderer;\n      })();\n\n      strokeRenderer.render(userStrokeProps);\n    }\n  }\n\n  destroy() {\n    svg.removeElm(this._positionedTarget!.svg);\n    this._positionedTarget!.defs.innerHTML = '';\n  }\n}\n","import { Point } from '../../typings/types';\n\nexport const drawPath = (ctx: CanvasRenderingContext2D, points: Point[]) => {\n  ctx.beginPath();\n  const start = points[0];\n  const remainingPoints = points.slice(1);\n  ctx.moveTo(start.x, start.y);\n  for (const point of remainingPoints) {\n    ctx.lineTo(point.x, point.y);\n  }\n  ctx.stroke();\n};\n\n/**\n * Break a path string into a series of canvas path commands\n *\n * Note: only works with the subset of SVG paths used by MakeMeAHanzi data\n * @param pathString\n */\nexport const pathStringToCanvas = (pathString: string) => {\n  const pathParts = pathString.split(/(^|\\s+)(?=[A-Z])/).filter((part) => part !== ' ');\n  const commands = [(ctx: CanvasRenderingContext2D) => ctx.beginPath()];\n  for (const part of pathParts) {\n    const [cmd, ...rawParams] = part.split(/\\s+/);\n    const params = rawParams.map((param) => parseFloat(param)) as any[];\n    if (cmd === 'M') {\n      commands.push((ctx) => ctx.moveTo(...(params as [number, number])));\n    } else if (cmd === 'L') {\n      commands.push((ctx) => ctx.lineTo(...(params as [number, number])));\n    } else if (cmd === 'C') {\n      commands.push((ctx) =>\n        ctx.bezierCurveTo(...(params as Parameters<typeof ctx.bezierCurveTo>)),\n      );\n    } else if (cmd === 'Q') {\n      commands.push((ctx) =>\n        ctx.quadraticCurveTo(...(params as Parameters<typeof ctx.quadraticCurveTo>)),\n      );\n    } else if (cmd === 'Z') {\n      // commands.push((ctx) => ctx.closePath());\n    }\n  }\n  return (ctx: CanvasRenderingContext2D) => commands.forEach((cmd) => cmd(ctx));\n};\n","import { extendStart } from '../../geometry';\nimport { drawPath, pathStringToCanvas } from './canvasUtils';\nimport StrokeRendererBase from '../StrokeRendererBase';\nimport Stroke from '../../models/Stroke';\nimport { ColorObject, Point } from '../../typings/types';\n\n/** this is a stroke composed of several stroke parts */\nexport default class StrokeRenderer extends StrokeRendererBase {\n  _extendedMaskPoints: Point[];\n\n  // Conditionally set on constructor\n  _path2D: Path2D | undefined;\n  _pathCmd: ((ctx: CanvasRenderingContext2D) => void) | undefined;\n\n  constructor(stroke: Stroke, usePath2D = true) {\n    super(stroke);\n\n    if (usePath2D && Path2D) {\n      this._path2D = new Path2D(this.stroke.path);\n    } else {\n      this._pathCmd = pathStringToCanvas(this.stroke.path);\n    }\n    this._extendedMaskPoints = extendStart(\n      this.stroke.points,\n      StrokeRendererBase.STROKE_WIDTH / 2,\n    );\n  }\n\n  render(\n    ctx: CanvasRenderingContext2D,\n    props: {\n      opacity: number;\n      strokeColor: ColorObject;\n      radicalColor?: ColorObject | null;\n      displayPortion: number;\n    },\n  ) {\n    if (props.opacity < 0.05) {\n      return;\n    }\n    ctx.save();\n\n    if (this._path2D) {\n      ctx.clip(this._path2D);\n    } else {\n      this._pathCmd?.(ctx);\n      // wechat bugs out if the clip path isn't stroked or filled\n      ctx.globalAlpha = 0;\n      ctx.stroke();\n      ctx.clip();\n    }\n\n    const { r, g, b, a } = this._getColor(props);\n    const color = a === 1 ? `rgb(${r},${g},${b})` : `rgb(${r},${g},${b},${a})`;\n    const dashOffset = this._getStrokeDashoffset(props.displayPortion);\n    ctx.globalAlpha = props.opacity;\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    ctx.lineWidth = StrokeRendererBase.STROKE_WIDTH;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    // wechat sets dashOffset as a second param here. Should be harmless for browsers to add here too\n    // @ts-ignore\n    ctx.setLineDash([this._pathLength, this._pathLength], dashOffset);\n    ctx.lineDashOffset = dashOffset;\n    drawPath(ctx, this._extendedMaskPoints);\n\n    ctx.restore();\n  }\n}\n","import Character from '../../models/Character';\nimport { StrokeRenderState } from '../../RenderState';\nimport { ColorObject } from '../../typings/types';\nimport StrokeRenderer from './StrokeRenderer';\n\nexport default class CharacterRenderer {\n  _strokeRenderers: StrokeRenderer[];\n\n  constructor(character: Character) {\n    this._strokeRenderers = character.strokes.map((stroke) => new StrokeRenderer(stroke));\n  }\n\n  render(\n    ctx: CanvasRenderingContext2D,\n    props: {\n      opacity: number;\n      strokes: Record<number, StrokeRenderState>;\n      strokeColor: ColorObject;\n      radicalColor?: ColorObject | null;\n    },\n  ) {\n    if (props.opacity < 0.05) return;\n\n    const { opacity, strokeColor, radicalColor, strokes } = props;\n\n    for (let i = 0; i < this._strokeRenderers.length; i++) {\n      this._strokeRenderers[i].render(ctx, {\n        strokeColor,\n        radicalColor,\n        opacity: strokes[i].opacity * opacity,\n        displayPortion: strokes[i].displayPortion || 0,\n      });\n    }\n  }\n}\n","import { ColorObject, Point } from '../../typings/types';\nimport { drawPath } from './canvasUtils';\n\nexport default function renderUserStroke(\n  ctx: CanvasRenderingContext2D,\n  props: {\n    opacity: number;\n    strokeWidth: number;\n    strokeColor: ColorObject;\n    points: Point[];\n  },\n) {\n  if (props.opacity < 0.05) {\n    return;\n  }\n  const { opacity, strokeWidth, strokeColor, points } = props;\n  const { r, g, b, a } = strokeColor;\n\n  ctx.save();\n  ctx.globalAlpha = opacity;\n  ctx.lineWidth = strokeWidth;\n  ctx.strokeStyle = `rgba(${r},${g},${b},${a})`;\n  ctx.lineCap = 'round';\n  ctx.lineJoin = 'round';\n  drawPath(ctx, points);\n  ctx.restore();\n}\n","import RenderTargetBase from '../RenderTargetBase';\n\nexport default class RenderTarget extends RenderTargetBase<HTMLCanvasElement> {\n  constructor(canvas: HTMLCanvasElement) {\n    super(canvas);\n  }\n\n  static init(elmOrId: string | HTMLCanvasElement, width = '100%', height = '100%') {\n    const element = (() => {\n      if (typeof elmOrId === 'string') {\n        return document.getElementById(elmOrId);\n      }\n      return elmOrId;\n    })();\n\n    if (!element) {\n      throw new Error(`HanziWriter target element not found: ${elmOrId}`);\n    }\n\n    const nodeType = element.nodeName.toUpperCase();\n\n    const canvas = (() => {\n      if (nodeType === 'CANVAS') {\n        return element as HTMLCanvasElement;\n      }\n      const canvas = document.createElement('canvas');\n      element.appendChild(canvas);\n      return canvas;\n    })();\n\n    canvas.setAttribute('width', width);\n    canvas.setAttribute('height', height);\n\n    return new RenderTarget(canvas);\n  }\n\n  getContext() {\n    return this.node.getContext('2d');\n  }\n}\n","import { RenderTargetInitFunction } from '../../typings/types';\nimport HanziWriterRenderer from './HanziWriterRenderer';\nimport RenderTarget from './RenderTarget';\n\nexport default {\n  HanziWriterRenderer,\n  createRenderTarget: RenderTarget.init as RenderTargetInitFunction<HTMLCanvasElement>,\n};\n","import Character from '../../models/Character';\nimport Positioner from '../../Positioner';\nimport HanziWriterRendererBase from '../HanziWriterRendererBase';\nimport CanvasRenderTarget from '../canvas/RenderTarget';\nimport CharacterRenderer from './CharacterRenderer';\nimport renderUserStroke from './renderUserStroke';\nimport { RenderStateObject } from '../../RenderState';\nimport { noop } from '../../utils';\n\nexport default class HanziWriterRenderer\n  implements HanziWriterRendererBase<HTMLCanvasElement, CanvasRenderTarget> {\n  _character: Character;\n  _positioner: Positioner;\n  _mainCharRenderer: CharacterRenderer;\n  _outlineCharRenderer: CharacterRenderer;\n  _highlightCharRenderer: CharacterRenderer;\n  _target: CanvasRenderTarget | undefined;\n\n  constructor(character: Character, positioner: Positioner) {\n    this._character = character;\n    this._positioner = positioner;\n    this._mainCharRenderer = new CharacterRenderer(character);\n    this._outlineCharRenderer = new CharacterRenderer(character);\n    this._highlightCharRenderer = new CharacterRenderer(character);\n  }\n\n  mount(target: CanvasRenderTarget) {\n    this._target = target;\n  }\n\n  destroy = noop;\n\n  _animationFrame(cb: (ctx: CanvasRenderingContext2D) => void) {\n    const { width, height, scale, xOffset, yOffset } = this._positioner;\n    const ctx = this._target!.getContext()!;\n    ctx.clearRect(0, 0, width, height);\n    ctx.save();\n    ctx.translate(xOffset, height - yOffset);\n    ctx.transform(1, 0, 0, -1, 0, 0);\n    ctx.scale(scale, scale);\n    cb(ctx);\n    ctx.restore();\n    // @ts-expect-error Verify if this is still needed for the \"wechat miniprogram\".\n    if (ctx.draw) {\n      // @ts-expect-error\n      ctx.draw();\n    }\n  }\n\n  render(props: RenderStateObject) {\n    const { outline, main, highlight } = props.character;\n    const {\n      outlineColor,\n      strokeColor,\n      radicalColor,\n      highlightColor,\n      drawingColor,\n      drawingWidth,\n    } = props.options;\n\n    this._animationFrame((ctx) => {\n      this._outlineCharRenderer.render(ctx, {\n        opacity: outline.opacity,\n        strokes: outline.strokes,\n        strokeColor: outlineColor,\n      });\n      this._mainCharRenderer.render(ctx, {\n        opacity: main.opacity,\n        strokes: main.strokes,\n        strokeColor: strokeColor,\n        radicalColor: radicalColor,\n      });\n      this._highlightCharRenderer.render(ctx, {\n        opacity: highlight.opacity,\n        strokes: highlight.strokes,\n        strokeColor: highlightColor,\n      });\n\n      const userStrokes = props.userStrokes || {};\n\n      for (const userStrokeId in userStrokes) {\n        const userStroke = userStrokes[userStrokeId];\n        if (userStroke) {\n          const userStrokeProps = {\n            strokeWidth: drawingWidth,\n            strokeColor: drawingColor,\n            ...userStroke,\n          };\n          renderUserStroke(ctx, userStrokeProps);\n        }\n      }\n    });\n  }\n}\n","import { CharacterJson } from './typings/types';\n\nconst VERSION = '2.0';\nconst getCharDataUrl = (char: string) =>\n  `https://cdn.jsdelivr.net/npm/hanzi-writer-data@${VERSION}/${char}.json`;\n\nconst defaultCharDataLoader = (\n  char: string,\n  onLoad: (parsedJson: CharacterJson) => void,\n  onError: (error?: any, context?: any) => void,\n) => {\n  // load char data from hanziwriter cdn (currently hosted on jsdelivr)\n  const xhr = new XMLHttpRequest();\n  if (xhr.overrideMimeType) {\n    // IE 9 and 10 don't seem to support this...\n    xhr.overrideMimeType('application/json');\n  }\n  xhr.open('GET', getCharDataUrl(char), true);\n  xhr.onerror = (event) => {\n    onError(xhr, event);\n  };\n  xhr.onreadystatechange = () => {\n    // TODO: error handling\n    if (xhr.readyState !== 4) return;\n\n    if (xhr.status === 200) {\n      onLoad(JSON.parse(xhr.responseText));\n    } else if (xhr.status !== 0 && onError) {\n      onError(xhr);\n    }\n  };\n  xhr.send(null);\n};\n\nexport default defaultCharDataLoader;\n","import { HanziWriterOptions } from './typings/types';\nimport defaultCharDataLoader from './defaultCharDataLoader';\n\nconst defaultOptions: HanziWriterOptions = {\n  charDataLoader: defaultCharDataLoader,\n  onLoadCharDataError: null,\n  onLoadCharDataSuccess: null,\n  showOutline: true,\n  showCharacter: true,\n  renderer: 'svg',\n\n  // positioning options\n\n  width: 0,\n  height: 0,\n  padding: 20,\n\n  // animation options\n\n  strokeAnimationSpeed: 1,\n  strokeFadeDuration: 400,\n  strokeHighlightDuration: 200,\n  strokeHighlightSpeed: 2,\n  delayBetweenStrokes: 1000,\n  delayBetweenLoops: 2000,\n\n  // colors\n\n  strokeColor: '#555',\n  radicalColor: null,\n  highlightColor: '#AAF',\n  outlineColor: '#DDD',\n  drawingColor: '#333',\n\n  // quiz options\n\n  leniency: 1,\n  showHintAfterMisses: 3,\n  highlightOnComplete: true,\n  highlightCompleteColor: null,\n\n  // undocumented obscure options\n\n  drawingFadeDuration: 300,\n  drawingWidth: 4,\n  strokeWidth: 2,\n  outlineWidth: 2,\n  rendererOverride: {},\n};\n\nexport default defaultOptions;\n","import { CharacterJson, LoadingManagerOptions } from './typings/types';\n\ntype CustomError = Error & { reason: string };\n\nexport default class LoadingManager {\n  _loadCounter = 0;\n  _isLoading = false;\n  _resolve: ((data: CharacterJson) => void) | undefined;\n  _reject: ((error?: Error | CustomError | string) => void) | undefined;\n  _options: LoadingManagerOptions;\n\n  /** Set when calling LoadingManager.loadCharData  */\n  _loadingChar: string | undefined;\n  /** use this to attribute to determine if there was a problem with loading */\n  loadingFailed = false;\n\n  constructor(options: LoadingManagerOptions) {\n    this._options = options;\n  }\n\n  _debouncedLoad(char: string, count: number) {\n    // these wrappers ignore all responses except the most recent.\n    const wrappedResolve = (data: CharacterJson) => {\n      if (count === this._loadCounter) {\n        this._resolve?.(data);\n      }\n    };\n    const wrappedReject = (reason?: Error | string) => {\n      if (count === this._loadCounter) {\n        this._reject?.(reason);\n      }\n    };\n\n    const returnedData = this._options.charDataLoader(\n      char,\n      wrappedResolve,\n      wrappedReject,\n    );\n\n    if (returnedData) {\n      if ('then' in returnedData) {\n        returnedData.then(wrappedResolve).catch(wrappedReject);\n      } else {\n        wrappedResolve(returnedData);\n      }\n    }\n  }\n\n  _setupLoadingPromise() {\n    return new Promise(\n      (\n        resolve: (data: CharacterJson) => void,\n        reject: (err?: Error | CustomError | string) => void,\n      ) => {\n        this._resolve = resolve;\n        this._reject = reject;\n      },\n    )\n      .then((data: CharacterJson) => {\n        this._isLoading = false;\n        this._options.onLoadCharDataSuccess?.(data);\n        return data;\n      })\n      .catch((reason) => {\n        this._isLoading = false;\n        this.loadingFailed = true;\n\n        // If the user has provided an \"onLoadCharDataError\", call this function\n        // Otherwise, throw the promise\n        if (this._options.onLoadCharDataError) {\n          this._options.onLoadCharDataError(reason);\n          return;\n        }\n\n        // If error callback wasn't provided, throw an error so the developer will be aware something went wrong\n        if (reason instanceof Error) {\n          throw reason;\n        }\n\n        const err = new Error(\n          `Failed to load char data for ${this._loadingChar}`,\n        ) as CustomError;\n\n        err.reason = reason;\n\n        throw err;\n      });\n  }\n\n  loadCharData(char: string) {\n    this._loadingChar = char;\n    const promise = this._setupLoadingPromise();\n    this.loadingFailed = false;\n    this._isLoading = true;\n    this._loadCounter++;\n    this._debouncedLoad(char, this._loadCounter);\n    return promise;\n  }\n}\n","import RenderState from './RenderState';\nimport parseCharData from './parseCharData';\nimport Positioner from './Positioner';\nimport Quiz from './Quiz';\nimport svgRenderer from './renderers/svg';\nimport canvasRenderer from './renderers/canvas';\nimport defaultOptions from './defaultOptions';\nimport LoadingManager from './LoadingManager';\nimport * as characterActions from './characterActions';\nimport { trim, colorStringToVals } from './utils';\nimport Character from './models/Character';\nimport HanziWriterRendererBase, {\n  HanziWriterRendererConstructor,\n} from './renderers/HanziWriterRendererBase';\nimport RenderTargetBase from './renderers/RenderTargetBase';\nimport { GenericMutation } from './Mutation';\n\n// Typings\nimport {\n  ColorOptions,\n  HanziWriterOptions,\n  LoadingManagerOptions,\n  OnCompleteFunction,\n  ParsedHanziWriterOptions,\n  QuizOptions,\n  RenderTargetInitFunction,\n} from './typings/types';\n\n// Export type interfaces\nexport * from './typings/types';\n\nexport default class HanziWriter {\n  _options: ParsedHanziWriterOptions;\n  _loadingManager: LoadingManager;\n  /** Only set when calling .setCharacter() */\n  _char: string | undefined;\n  /** Only set when calling .setCharacter() */\n  _renderState: RenderState | undefined;\n  /** Only set when calling .setCharacter() */\n  _character: Character | undefined;\n  /** Only set when calling .setCharacter() */\n  _positioner: Positioner | undefined;\n  /** Only set when calling .setCharacter() */\n  _hanziWriterRenderer: HanziWriterRendererBase<HTMLElement, any> | null | undefined;\n  /** Only set when calling .setCharacter() */\n  _withDataPromise: Promise<void> | undefined;\n\n  _quiz: Quiz | undefined;\n  _renderer: {\n    HanziWriterRenderer: HanziWriterRendererConstructor;\n    createRenderTarget: RenderTargetInitFunction<any>;\n  };\n\n  target: RenderTargetBase;\n\n  /** Main entry point */\n  static create(\n    element: string | HTMLElement,\n    character: string,\n    options?: Partial<HanziWriterOptions>,\n  ) {\n    const writer = new HanziWriter(element, options);\n    writer.setCharacter(character);\n\n    return writer;\n  }\n\n  /** Singleton instance of LoadingManager. Only set in `loadCharacterData` */\n  static _loadingManager: LoadingManager | null = null;\n  /** Singleton loading options. Only set in `loadCharacterData` */\n  static _loadingOptions: Partial<HanziWriterOptions> | null = null;\n\n  static loadCharacterData(\n    character: string,\n    options: Partial<LoadingManagerOptions> = {},\n  ) {\n    const loadingManager = (() => {\n      const { _loadingManager, _loadingOptions } = HanziWriter;\n      if (_loadingManager?._loadingChar === character && _loadingOptions === options) {\n        return _loadingManager;\n      }\n      return new LoadingManager({ ...defaultOptions, ...options });\n    })();\n\n    HanziWriter._loadingManager = loadingManager;\n    HanziWriter._loadingOptions = options;\n    return loadingManager.loadCharData(character);\n  }\n\n  static getScalingTransform(width: number, height: number, padding = 0) {\n    const positioner = new Positioner({ width, height, padding });\n    return {\n      x: positioner.xOffset,\n      y: positioner.yOffset,\n      scale: positioner.scale,\n      transform: trim(`\n        translate(${positioner.xOffset}, ${positioner.height - positioner.yOffset})\n        scale(${positioner.scale}, ${-1 * positioner.scale})\n      `).replace(/\\s+/g, ' '),\n    };\n  }\n\n  constructor(element: string | HTMLElement, options: Partial<HanziWriterOptions> = {}) {\n    const { HanziWriterRenderer, createRenderTarget } =\n      options.renderer === 'canvas' ? canvasRenderer : svgRenderer;\n    const rendererOverride = options.rendererOverride || {};\n\n    this._renderer = {\n      HanziWriterRenderer: rendererOverride.HanziWriterRenderer || HanziWriterRenderer,\n      createRenderTarget: rendererOverride.createRenderTarget || createRenderTarget,\n    };\n    // wechat miniprogram component needs direct access to the render target, so this is public\n    this.target = this._renderer.createRenderTarget(\n      element,\n      options.width,\n      options.height,\n    );\n    this._options = this._assignOptions(options);\n    this._loadingManager = new LoadingManager(this._options);\n    this._setupListeners();\n  }\n\n  showCharacter(\n    options: {\n      onComplete?: OnCompleteFunction;\n      duration?: number;\n    } = {},\n  ) {\n    this._options.showCharacter = true;\n    return this._withData(() =>\n      this._renderState\n        ?.run(\n          characterActions.showCharacter(\n            'main',\n            this._character!,\n            typeof options.duration === 'number'\n              ? options.duration\n              : this._options.strokeFadeDuration,\n          ),\n        )\n        .then((res) => {\n          options.onComplete?.(res);\n          return res;\n        }),\n    );\n  }\n\n  hideCharacter(\n    options: {\n      onComplete?: OnCompleteFunction;\n      duration?: number;\n    } = {},\n  ) {\n    this._options.showCharacter = false;\n    return this._withData(() =>\n      this._renderState\n        ?.run(\n          characterActions.hideCharacter(\n            'main',\n            this._character!,\n            typeof options.duration === 'number'\n              ? options.duration\n              : this._options.strokeFadeDuration,\n          ),\n        )\n        .then((res) => {\n          options.onComplete?.(res);\n          return res;\n        }),\n    );\n  }\n\n  animateCharacter(\n    options: {\n      onComplete?: OnCompleteFunction;\n    } = {},\n  ) {\n    this.cancelQuiz();\n\n    return this._withData(() =>\n      this._renderState\n        ?.run(\n          characterActions.animateCharacter(\n            'main',\n            this._character!,\n            this._options.strokeFadeDuration,\n            this._options.strokeAnimationSpeed,\n            this._options.delayBetweenStrokes,\n          ),\n        )\n        .then((res) => {\n          options.onComplete?.(res);\n          return res;\n        }),\n    );\n  }\n\n  animateStroke(\n    strokeNum: number,\n    options: {\n      onComplete?: OnCompleteFunction;\n    } = {},\n  ) {\n    this.cancelQuiz();\n    return this._withData(() =>\n      this._renderState\n        ?.run(\n          characterActions.animateSingleStroke(\n            'main',\n            this._character!,\n            strokeNum,\n            this._options.strokeAnimationSpeed,\n          ),\n        )\n        .then((res) => {\n          options.onComplete?.(res);\n          return res;\n        }),\n    );\n  }\n\n  highlightStroke(\n    strokeNum: number,\n    options: {\n      onComplete?: OnCompleteFunction;\n    } = {},\n  ) {\n    const promise = () => {\n      if (!this._character || !this._renderState) {\n        return;\n      }\n\n      return this._renderState\n        .run(\n          characterActions.highlightStroke(\n            this._character.strokes[strokeNum],\n            colorStringToVals(this._options.highlightColor),\n            this._options.strokeHighlightSpeed,\n          ),\n        )\n        .then((res) => {\n          options.onComplete?.(res);\n          return res;\n        });\n    };\n\n    return this._withData(promise);\n  }\n\n  async loopCharacterAnimation() {\n    this.cancelQuiz();\n    return this._withData(() =>\n      this._renderState!.run(\n        characterActions.animateCharacterLoop(\n          'main',\n          this._character!,\n          this._options.strokeFadeDuration,\n          this._options.strokeAnimationSpeed,\n          this._options.delayBetweenStrokes,\n          this._options.delayBetweenLoops,\n        ),\n        { loop: true },\n      ),\n    );\n  }\n\n  pauseAnimation() {\n    return this._withData(() => this._renderState?.pauseAll());\n  }\n\n  resumeAnimation() {\n    return this._withData(() => this._renderState?.resumeAll());\n  }\n\n  showOutline(\n    options: {\n      duration?: number;\n      onComplete?: OnCompleteFunction;\n    } = {},\n  ) {\n    this._options.showOutline = true;\n    return this._withData(() =>\n      this._renderState\n        ?.run(\n          characterActions.showCharacter(\n            'outline',\n            this._character!,\n            typeof options.duration === 'number'\n              ? options.duration\n              : this._options.strokeFadeDuration,\n          ),\n        )\n        .then((res) => {\n          options.onComplete?.(res);\n          return res;\n        }),\n    );\n  }\n\n  hideOutline(\n    options: {\n      duration?: number;\n      onComplete?: OnCompleteFunction;\n    } = {},\n  ) {\n    this._options.showOutline = false;\n    return this._withData(() =>\n      this._renderState\n        ?.run(\n          characterActions.hideCharacter(\n            'outline',\n            this._character!,\n            typeof options.duration === 'number'\n              ? options.duration\n              : this._options.strokeFadeDuration,\n          ),\n        )\n        .then((res) => {\n          options.onComplete?.(res);\n          return res;\n        }),\n    );\n  }\n\n  updateColor(\n    colorName: keyof ColorOptions,\n    colorVal: string | null,\n    options: {\n      duration?: number;\n      onComplete?: OnCompleteFunction;\n    } = {},\n  ) {\n    let mutations: GenericMutation[] = [];\n\n    const fixedColorVal = (() => {\n      // If we're removing radical color, tween it to the stroke color\n      if (colorName === 'radicalColor' && !colorVal) {\n        return this._options.strokeColor;\n      }\n      return colorVal;\n    })();\n\n    const mappedColor = colorStringToVals(fixedColorVal as string);\n\n    this._options[colorName] = colorVal as any;\n\n    const duration = options.duration ?? this._options.strokeFadeDuration;\n\n    mutations = mutations.concat(\n      characterActions.updateColor(colorName, mappedColor, duration),\n    );\n\n    // make sure to set radicalColor back to null after the transition finishes if val == null\n    if (colorName === 'radicalColor' && !colorVal) {\n      mutations = mutations.concat(characterActions.updateColor(colorName, null, 0));\n    }\n\n    return this._withData(() =>\n      this._renderState?.run(mutations).then((res) => {\n        options.onComplete?.(res);\n        return res;\n      }),\n    );\n  }\n\n  quiz(quizOptions: Partial<QuizOptions> = {}) {\n    return this._withData(async () => {\n      if (this._character && this._renderState && this._positioner) {\n        this.cancelQuiz();\n        this._quiz = new Quiz(this._character, this._renderState, this._positioner);\n        this._options = {\n          ...this._options,\n          ...quizOptions,\n        };\n        this._quiz.startQuiz(this._options);\n      }\n    });\n  }\n\n  cancelQuiz() {\n    if (this._quiz) {\n      this._quiz.cancel();\n      this._quiz = undefined;\n    }\n  }\n\n  setCharacter(char: string) {\n    this.cancelQuiz();\n    this._char = char;\n    if (this._hanziWriterRenderer) {\n      this._hanziWriterRenderer.destroy();\n    }\n    if (this._renderState) {\n      this._renderState.cancelAll();\n    }\n    this._hanziWriterRenderer = null;\n    this._withDataPromise = this._loadingManager\n      .loadCharData(char)\n      .then((pathStrings) => {\n        // if \"pathStrings\" isn't set, \".catch()\"\" was probably called and loading likely failed\n        if (!pathStrings || this._loadingManager.loadingFailed) {\n          return;\n        }\n\n        this._character = parseCharData(char, pathStrings);\n        const { width, height, padding } = this._options;\n        this._positioner = new Positioner({ width, height, padding });\n        const hanziWriterRenderer = new this._renderer.HanziWriterRenderer(\n          this._character,\n          this._positioner,\n        );\n        this._hanziWriterRenderer = hanziWriterRenderer;\n        this._renderState = new RenderState(this._character, this._options, (nextState) =>\n          hanziWriterRenderer.render(nextState),\n        );\n        this._hanziWriterRenderer.mount(this.target);\n        this._hanziWriterRenderer.render(this._renderState.state);\n      });\n    return this._withDataPromise;\n  }\n\n  async getCharacterData(): Promise<Character> {\n    if (!this._char) {\n      throw new Error('setCharacter() must be called before calling getCharacterData()');\n    }\n    const character = await this._withData(() => this._character);\n    return character!;\n  }\n\n  _assignOptions(options: Partial<HanziWriterOptions>): ParsedHanziWriterOptions {\n    const mergedOptions = {\n      ...defaultOptions,\n      ...options,\n    };\n\n    // backfill strokeAnimationSpeed if deprecated strokeAnimationDuration is provided instead\n    if (options.strokeAnimationDuration && !options.strokeAnimationSpeed) {\n      mergedOptions.strokeAnimationSpeed = 500 / options.strokeAnimationDuration;\n    }\n    if (options.strokeHighlightDuration && !options.strokeHighlightSpeed) {\n      mergedOptions.strokeHighlightSpeed = 500 / mergedOptions.strokeHighlightDuration;\n    }\n\n    if (!options.highlightCompleteColor) {\n      mergedOptions.highlightCompleteColor = mergedOptions.highlightColor;\n    }\n\n    return this._fillWidthAndHeight(mergedOptions);\n  }\n\n  /** returns a new options object with width and height filled in if missing */\n  _fillWidthAndHeight(options: HanziWriterOptions): ParsedHanziWriterOptions {\n    const filledOpts = { ...options };\n    if (filledOpts.width && !filledOpts.height) {\n      filledOpts.height = filledOpts.width;\n    } else if (filledOpts.height && !filledOpts.width) {\n      filledOpts.width = filledOpts.height;\n    } else if (!filledOpts.width && !filledOpts.height) {\n      const { width, height } = this.target.getBoundingClientRect();\n      const minDim = Math.min(width, height);\n      filledOpts.width = minDim;\n      filledOpts.height = minDim;\n    }\n    return filledOpts as ParsedHanziWriterOptions;\n  }\n\n  _withData<T>(func: () => T) {\n    // if this._loadingManager.loadingFailed, then loading failed before this method was called\n    if (this._loadingManager.loadingFailed) {\n      throw Error('Failed to load character data. Call setCharacter and try again.');\n    }\n\n    if (this._withDataPromise) {\n      return this._withDataPromise.then(() => {\n        if (!this._loadingManager.loadingFailed) {\n          return func();\n        }\n      });\n    }\n    return Promise.resolve().then(func);\n  }\n\n  _setupListeners() {\n    this.target.addPointerStartListener((evt) => {\n      if (this._quiz) {\n        evt.preventDefault();\n        this._quiz.startUserStroke(evt.getPoint());\n      }\n    });\n    this.target.addPointerMoveListener((evt) => {\n      if (this._quiz) {\n        evt.preventDefault();\n        this._quiz.continueUserStroke(evt.getPoint());\n      }\n    });\n    this.target.addPointerEndListener(() => {\n      this._quiz?.endUserStroke();\n    });\n  }\n}\n"],"names":["globalObj","window","global","performanceNow","performance","now","Date","requestAnimationFrame","callback","setTimeout","cancelAnimationFrame","clearTimeout","arrLast","arr","length","copyAndMergeDeep","base","override","output","key","baseVal","overrideVal","Array","isArray","count","counter","average","reduce","acc","val","colorStringToVals","colorString","normalizedColor","toUpperCase","trim","test","hexParts","substring","split","hexStr","join","r","parseInt","slice","g","b","a","rgbMatch","match","parseFloat","Error","objRepeat","item","times","obj","i","ua","navigator","userAgent","isMsBrowser","indexOf","noop","RenderState","constructor","character","options","onStateChange","_mutationChains","_onStateChange","state","drawingFadeDuration","drawingWidth","drawingColor","strokeColor","outlineColor","radicalColor","highlightColor","main","opacity","showCharacter","strokes","outline","showOutline","highlight","userStrokes","displayPortion","updateState","stateChanges","nextState","this","run","mutations","scopes","map","mut","scope","cancelMutations","Promise","resolve","mutationChain","_isActive","_index","_resolve","_mutations","_loop","loop","_scopes","push","_run","filter","chain","canceled","then","_getActiveMutations","pauseAll","forEach","mutation","pause","resumeAll","resume","scopesToCancel","chainId","scopeToCancel","startsWith","_cancelMutationChain","cancelAll","cancel","subtract","p1","p2","x","y","magnitude","point","Math","sqrt","pow","distance","point1","point2","round","precision","multiplier","points","lastPoint","dist","_extendPointOnLine","vect","norm","normalizeCurve","curve","outlinedCurve","numPoints","segmentLen","outlinePoints","endPoint","remainingCurvePoints","remainingDist","outlinePointFound","nextPointDist","shift","nextPoint","outlineCurve","mean","translatedCurve","scale","maxLen","newCurve","prevPoint","segLen","numNewPoints","ceil","newSegLen","subdivideCurve","getPathString","close","start","remainingPoints","pathString","roundedPoint","extendStart","filteredPoints","numFilteredPoints","curVect","prevVect","pop","_filterParallelPoints","newStart","extendedPoints","unshift","Stroke","path","strokeNum","isInRadical","getStartingPoint","getEndingPoint","getLength","getVectors","vector","getDistance","distances","strokePoint","min","getAverageDistance","Character","symbol","generateStrokes","radStrokes","medians","index","pointData","from","to","preScaledWidth","preScaledHeight","Positioner","padding","width","height","effectiveWidth","effectiveHeight","scaleX","scaleY","xCenteringBuffer","yCenteringBuffer","xOffset","yOffset","convertExternalPoint","directionMatches","stroke","edgeVectors","vectors","getEdgeVectors","strokeVectors","edgeVector","strokeSimilarities","strokeVector","cosineSimilarity","max","stripDuplicates","firstPoint","rest","dedupedPoints","SHAPE_FIT_ROTATIONS","PI","shapeFit","curve1","curve2","leniency","normCurve1","normCurve2","minDist","Infinity","theta","longCurve","shortCurve","calcVal","j","prevResultsCol","curResultsCol","lastResult","frechetDist","cos","sin","rotate","getMatchData","isOutlineVisible","avgDist","withinDistThresh","isMatch","startAndEndMatch","closestStroke","startingDist","endingDist","startAndEndMatches","directionMatch","shapeMatch","lengthMatch","lengthMatches","UserStroke","id","startingPoint","startingExternalPoint","externalPoints","appendPoint","externalPoint","Mutation","valuesOrCallable","_tick","timing","_startPauseTime","progress","_startTime","_pausedDuration","_duration","_renderState","_values","_frameHandle","undefined","easedProgress","ease","getPartialValues","_startState","_valuesOrCallable","duration","_force","force","renderState","_inflateValues","isAlreadyAtEnd","values","parts","final","current","cap","inflate","startValues","endValues","target","endValue","startValue","Delay","_paused","_runningPromise","_timeout","elapsedDelay","showStrokes","charName","hideCharacter","updateColor","colorName","colorVal","highlightStroke","color","speed","animateStroke","animateCharacter","fadeDuration","delayBetweenStrokes","concat","removeUserStroke","userStrokeId","Quiz","positioner","_currentStrokeIndex","_mistakesOnStroke","_totalMistakes","_character","_positioner","startQuiz","_options","strokeFadeDuration","characterActions","startUserStroke","_userStroke","endUserStroke","strokeId","quizActions","continueUserStroke","nextPoints","currentStroke","_getCurrentStroke","userStroke","laterStrokes","closestMatchDist","leniencyAdjustment","strokeMatches","_handleSuccess","_handleFailure","showHintAfterMisses","strokeHighlightSpeed","_getStrokeData","isCorrect","mistakesOnStroke","totalMistakes","strokesRemaining","drawnPath","geometry","onCorrectStroke","onComplete","highlightOnComplete","strokeHighlightDuration","animation","onMistake","createElm","elmType","document","createElementNS","attr","elm","name","value","setAttributeNS","attrs","attrsMap","Object","keys","attrName","removeElm","parentNode","removeChild","StrokeRendererBase","_pathLength","STROKE_WIDTH","_getStrokeDashoffset","_getColor","StrokeRenderer","_oldProps","mount","_animationPath","svg","_clip","_strokePath","maskId","style","prefix","location","href","replace","extendedMaskPoints","toString","fill","appendChild","defs","render","props","_this$_oldProps","strokeDashoffset","_this$_oldProps2","CharacterRenderer","_strokeRenderers","subTarget","createSubRenderTarget","_group","strokeRenderer","display","removeProperty","colorsChanged","_this$_oldProps3","_this$_oldProps4","UserStrokeRenderer","_path","strokeWidth","destroy","RenderTargetBase","node","addPointerStartListener","addEventListener","evt","_eventify","_getMousePoint","_getTouchPoint","addPointerMoveListener","addPointerEndListener","getBoundingClientRect","pointFunc","getPoint","call","preventDefault","left","top","clientX","clientY","touches","RenderTarget","_pt","createSVGPoint","elmOrId","element","getElementById","nodeType","nodeName","group","localPt","matrixTransform","getScreenCTM","_this$node$getScreenC","inverse","super","_this$node$getScreenC2","HanziWriterRenderer","_mainCharRenderer","_outlineCharRenderer","_highlightCharRenderer","_userStrokeRenderers","positionedTarget","_positionedTarget","userStrokeProps","newStrokeRenderer","innerHTML","createRenderTarget","init","drawPath","ctx","beginPath","moveTo","lineTo","usePath2D","Path2D","_path2D","_pathCmd","pathParts","part","commands","cmd","rawParams","params","param","bezierCurveTo","quadraticCurveTo","pathStringToCanvas","_extendedMaskPoints","save","clip","globalAlpha","dashOffset","strokeStyle","fillStyle","lineWidth","lineCap","lineJoin","setLineDash","lineDashOffset","restore","renderUserStroke","canvas","createElement","setAttribute","getContext","_target","_animationFrame","cb","clearRect","translate","transform","draw","defaultOptions","charDataLoader","char","onLoad","onError","xhr","XMLHttpRequest","overrideMimeType","open","getCharDataUrl","onerror","event","onreadystatechange","readyState","status","JSON","parse","responseText","send","onLoadCharDataError","onLoadCharDataSuccess","renderer","strokeAnimationSpeed","delayBetweenLoops","highlightCompleteColor","outlineWidth","rendererOverride","LoadingManager","_loadCounter","_isLoading","loadingFailed","_debouncedLoad","wrappedResolve","data","wrappedReject","reason","_reject","returnedData","catch","_setupLoadingPromise","reject","err","_loadingChar","loadCharData","promise","HanziWriter","canvasRenderer","svgRenderer","_renderer","_assignOptions","_loadingManager","_setupListeners","writer","setCharacter","loadingManager","_loadingOptions","string","_withData","_this$_renderState","res","_this$_renderState2","cancelQuiz","_this$_renderState3","_this$_renderState4","curCharState","mutationState","pauseAnimation","_this$_renderState5","resumeAnimation","_this$_renderState6","_this$_renderState7","hideOutline","_this$_renderState8","mappedColor","_this$_renderState9","quiz","quizOptions","async","_quiz","_char","_hanziWriterRenderer","_withDataPromise","pathStrings","charJson","parseCharData","hanziWriterRenderer","mergedOptions","strokeAnimationDuration","_fillWidthAndHeight","filledOpts","minDim","func"],"mappings":"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"}