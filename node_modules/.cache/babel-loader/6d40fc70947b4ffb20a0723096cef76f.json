{"ast":null,"code":"/**\n * Hanzi Writer v3.1.0 | https://chanind.github.io/hanzi-writer\n */\nvar _globalObj$navigator; // hacky way to get around rollup not properly setting `global` to `window` in browser\n\n\nconst globalObj = typeof window === 'undefined' ? global : window;\n\nconst performanceNow = globalObj.performance && (() => globalObj.performance.now()) || (() => Date.now());\n\nconst requestAnimationFrame = globalObj.requestAnimationFrame || (callback => setTimeout(() => callback(performanceNow()), 1000 / 60));\n\nconst cancelAnimationFrame = globalObj.cancelAnimationFrame || clearTimeout; // Object.assign polyfill, because IE :/\n\nfunction arrLast(arr) {\n  return arr[arr.length - 1];\n}\n\nfunction copyAndMergeDeep(base, override) {\n  const output = { ...base\n  };\n\n  for (const key in override) {\n    const baseVal = base[key];\n    const overrideVal = override[key];\n\n    if (baseVal === overrideVal) {\n      continue;\n    }\n\n    if (baseVal && overrideVal && typeof baseVal === 'object' && typeof overrideVal === 'object' && !Array.isArray(overrideVal)) {\n      output[key] = copyAndMergeDeep(baseVal, overrideVal);\n    } else {\n      // @ts-ignore\n      output[key] = overrideVal;\n    }\n  }\n\n  return output;\n}\n/** basically a simplified version of lodash.get, selects a key out of an object like 'a.b' from {a: {b: 7}} */\n\n\nfunction inflate(scope, obj) {\n  const parts = scope.split('.');\n  const final = {};\n  let current = final;\n\n  for (let i = 0; i < parts.length; i++) {\n    const cap = i === parts.length - 1 ? obj : {};\n    current[parts[i]] = cap;\n    current = cap;\n  }\n\n  return final;\n}\n\nlet count = 0;\n\nfunction counter() {\n  count++;\n  return count;\n}\n\nfunction average(arr) {\n  const sum = arr.reduce((acc, val) => val + acc, 0);\n  return sum / arr.length;\n}\n\nfunction colorStringToVals(colorString) {\n  const normalizedColor = colorString.toUpperCase().trim(); // based on https://stackoverflow.com/a/21648508\n\n  if (/^#([A-F0-9]{3}){1,2}$/.test(normalizedColor)) {\n    let hexParts = normalizedColor.substring(1).split('');\n\n    if (hexParts.length === 3) {\n      hexParts = [hexParts[0], hexParts[0], hexParts[1], hexParts[1], hexParts[2], hexParts[2]];\n    }\n\n    const hexStr = \"\".concat(hexParts.join(''));\n    return {\n      r: parseInt(hexStr.slice(0, 2), 16),\n      g: parseInt(hexStr.slice(2, 4), 16),\n      b: parseInt(hexStr.slice(4, 6), 16),\n      a: 1\n    };\n  }\n\n  const rgbMatch = normalizedColor.match(/^RGBA?\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(?:\\s*,\\s*(\\d*\\.?\\d+))?\\)$/);\n\n  if (rgbMatch) {\n    return {\n      r: parseInt(rgbMatch[1], 10),\n      g: parseInt(rgbMatch[2], 10),\n      b: parseInt(rgbMatch[3], 10),\n      // @ts-expect-error ts-migrate(2554) FIXME: Expected 1 arguments, but got 2.\n      a: parseFloat(rgbMatch[4] || 1, 10)\n    };\n  }\n\n  throw new Error(\"Invalid color: \".concat(colorString));\n}\n\nconst trim = string => string.replace(/^\\s+/, '').replace(/\\s+$/, ''); // return a new array-like object with int keys where each key is item\n// ex: objRepeat({x: 8}, 3) === {0: {x: 8}, 1: {x: 8}, 2: {x: 8}}\n\n\nfunction objRepeat(item, times) {\n  const obj = {};\n\n  for (let i = 0; i < times; i++) {\n    obj[i] = item;\n  }\n\n  return obj;\n}\n\nconst ua = ((_globalObj$navigator = globalObj.navigator) === null || _globalObj$navigator === void 0 ? void 0 : _globalObj$navigator.userAgent) || '';\nconst isMsBrowser = ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0; // eslint-disable-next-line @typescript-eslint/no-empty-function\n\nconst noop = () => {};\n\nclass RenderState {\n  constructor(character, options, onStateChange = noop) {\n    this._mutationChains = [];\n    this._onStateChange = onStateChange;\n    this.state = {\n      options: {\n        drawingFadeDuration: options.drawingFadeDuration,\n        drawingWidth: options.drawingWidth,\n        drawingColor: colorStringToVals(options.drawingColor),\n        strokeColor: colorStringToVals(options.strokeColor),\n        outlineColor: colorStringToVals(options.outlineColor),\n        radicalColor: colorStringToVals(options.radicalColor || options.strokeColor),\n        highlightColor: colorStringToVals(options.highlightColor)\n      },\n      character: {\n        main: {\n          opacity: options.showCharacter ? 1 : 0,\n          strokes: {}\n        },\n        outline: {\n          opacity: options.showOutline ? 1 : 0,\n          strokes: {}\n        },\n        highlight: {\n          opacity: 1,\n          strokes: {}\n        }\n      },\n      userStrokes: null\n    };\n\n    for (let i = 0; i < character.strokes.length; i++) {\n      this.state.character.main.strokes[i] = {\n        opacity: 1,\n        displayPortion: 1\n      };\n      this.state.character.outline.strokes[i] = {\n        opacity: 1,\n        displayPortion: 1\n      };\n      this.state.character.highlight.strokes[i] = {\n        opacity: 0,\n        displayPortion: 1\n      };\n    }\n  }\n\n  updateState(stateChanges) {\n    const nextState = copyAndMergeDeep(this.state, stateChanges);\n\n    this._onStateChange(nextState, this.state);\n\n    this.state = nextState;\n  }\n\n  run(mutations, options = {}) {\n    const scopes = mutations.map(mut => mut.scope);\n    this.cancelMutations(scopes);\n    return new Promise(resolve => {\n      const mutationChain = {\n        _isActive: true,\n        _index: 0,\n        _resolve: resolve,\n        _mutations: mutations,\n        _loop: options.loop,\n        _scopes: scopes\n      };\n\n      this._mutationChains.push(mutationChain);\n\n      this._run(mutationChain);\n    });\n  }\n\n  _run(mutationChain) {\n    if (!mutationChain._isActive) {\n      return;\n    }\n\n    const mutations = mutationChain._mutations;\n\n    if (mutationChain._index >= mutations.length) {\n      if (mutationChain._loop) {\n        mutationChain._index = 0; // eslint-disable-line no-param-reassign\n      } else {\n        mutationChain._isActive = false; // eslint-disable-line no-param-reassign\n\n        this._mutationChains = this._mutationChains.filter(chain => chain !== mutationChain); // The chain is done - resolve the promise to signal it finished successfully\n\n        mutationChain._resolve({\n          canceled: false\n        });\n\n        return;\n      }\n    }\n\n    const activeMutation = mutationChain._mutations[mutationChain._index];\n    activeMutation.run(this).then(() => {\n      if (mutationChain._isActive) {\n        mutationChain._index++; // eslint-disable-line no-param-reassign\n\n        this._run(mutationChain);\n      }\n    });\n  }\n\n  _getActiveMutations() {\n    return this._mutationChains.map(chain => chain._mutations[chain._index]);\n  }\n\n  pauseAll() {\n    this._getActiveMutations().forEach(mutation => mutation.pause());\n  }\n\n  resumeAll() {\n    this._getActiveMutations().forEach(mutation => mutation.resume());\n  }\n\n  cancelMutations(scopesToCancel) {\n    for (const chain of this._mutationChains) {\n      for (const chainId of chain._scopes) {\n        for (const scopeToCancel of scopesToCancel) {\n          if (chainId.startsWith(scopeToCancel) || scopeToCancel.startsWith(chainId)) {\n            this._cancelMutationChain(chain);\n          }\n        }\n      }\n    }\n  }\n\n  cancelAll() {\n    this.cancelMutations(['']);\n  }\n\n  _cancelMutationChain(mutationChain) {\n    var _mutationChain$_resol;\n\n    mutationChain._isActive = false;\n\n    for (let i = mutationChain._index; i < mutationChain._mutations.length; i++) {\n      mutationChain._mutations[i].cancel(this);\n    }\n\n    (_mutationChain$_resol = mutationChain._resolve) === null || _mutationChain$_resol === void 0 ? void 0 : _mutationChain$_resol.call(mutationChain, {\n      canceled: true\n    });\n    this._mutationChains = this._mutationChains.filter(chain => chain !== mutationChain);\n  }\n\n}\n\nconst subtract = (p1, p2) => ({\n  x: p1.x - p2.x,\n  y: p1.y - p2.y\n});\n\nconst magnitude = point => Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\n\nconst distance = (point1, point2) => magnitude(subtract(point1, point2));\n\nconst equals = (point1, point2) => point1.x === point2.x && point1.y === point2.y;\n\nconst round = (point, precision = 1) => {\n  const multiplier = precision * 10;\n  return {\n    x: Math.round(multiplier * point.x) / multiplier,\n    y: Math.round(multiplier * point.y) / multiplier\n  };\n};\n\nconst length = points => {\n  let lastPoint = points[0];\n  const pointsSansFirst = points.slice(1);\n  return pointsSansFirst.reduce((acc, point) => {\n    const dist = distance(point, lastPoint);\n    lastPoint = point;\n    return acc + dist;\n  }, 0);\n};\n\nconst cosineSimilarity = (point1, point2) => {\n  const rawDotProduct = point1.x * point2.x + point1.y * point2.y;\n  return rawDotProduct / magnitude(point1) / magnitude(point2);\n};\n/**\n * return a new point, p3, which is on the same line as p1 and p2, but distance away\n * from p2. p1, p2, p3 will always lie on the line in that order\n */\n\n\nconst _extendPointOnLine = (p1, p2, dist) => {\n  const vect = subtract(p2, p1);\n  const norm = dist / magnitude(vect);\n  return {\n    x: p2.x + norm * vect.x,\n    y: p2.y + norm * vect.y\n  };\n};\n/** based on http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf */\n\n\nconst frechetDist = (curve1, curve2) => {\n  const longCurve = curve1.length >= curve2.length ? curve1 : curve2;\n  const shortCurve = curve1.length >= curve2.length ? curve2 : curve1;\n\n  const calcVal = (i, j, prevResultsCol, curResultsCol) => {\n    if (i === 0 && j === 0) {\n      return distance(longCurve[0], shortCurve[0]);\n    }\n\n    if (i > 0 && j === 0) {\n      return Math.max(prevResultsCol[0], distance(longCurve[i], shortCurve[0]));\n    }\n\n    const lastResult = curResultsCol[curResultsCol.length - 1];\n\n    if (i === 0 && j > 0) {\n      return Math.max(lastResult, distance(longCurve[0], shortCurve[j]));\n    }\n\n    return Math.max(Math.min(prevResultsCol[j], prevResultsCol[j - 1], lastResult), distance(longCurve[i], shortCurve[j]));\n  };\n\n  let prevResultsCol = [];\n\n  for (let i = 0; i < longCurve.length; i++) {\n    const curResultsCol = [];\n\n    for (let j = 0; j < shortCurve.length; j++) {\n      // we only need the results from i - 1 and j - 1 to continue the calculation\n      // so we only need to hold onto the last column of calculated results\n      // prevResultsCol is results[i-1][:] in the original algorithm\n      // curResultsCol is results[i][:j-1] in the original algorithm\n      curResultsCol.push(calcVal(i, j, prevResultsCol, curResultsCol));\n    }\n\n    prevResultsCol = curResultsCol;\n  }\n\n  return prevResultsCol[shortCurve.length - 1];\n};\n/** break up long segments in the curve into smaller segments of len maxLen or smaller */\n\n\nconst subdivideCurve = (curve, maxLen = 0.05) => {\n  const newCurve = curve.slice(0, 1);\n\n  for (const point of curve.slice(1)) {\n    const prevPoint = newCurve[newCurve.length - 1];\n    const segLen = distance(point, prevPoint);\n\n    if (segLen > maxLen) {\n      const numNewPoints = Math.ceil(segLen / maxLen);\n      const newSegLen = segLen / numNewPoints;\n\n      for (let i = 0; i < numNewPoints; i++) {\n        newCurve.push(_extendPointOnLine(point, prevPoint, -1 * newSegLen * (i + 1)));\n      }\n    } else {\n      newCurve.push(point);\n    }\n  }\n\n  return newCurve;\n};\n/** redraw the curve using numPoints equally spaced out along the length of the curve */\n\n\nconst outlineCurve = (curve, numPoints = 30) => {\n  const curveLen = length(curve);\n  const segmentLen = curveLen / (numPoints - 1);\n  const outlinePoints = [curve[0]];\n  const endPoint = arrLast(curve);\n  const remainingCurvePoints = curve.slice(1);\n\n  for (let i = 0; i < numPoints - 2; i++) {\n    let lastPoint = arrLast(outlinePoints);\n    let remainingDist = segmentLen;\n    let outlinePointFound = false;\n\n    while (!outlinePointFound) {\n      const nextPointDist = distance(lastPoint, remainingCurvePoints[0]);\n\n      if (nextPointDist < remainingDist) {\n        remainingDist -= nextPointDist;\n        lastPoint = remainingCurvePoints.shift();\n      } else {\n        const nextPoint = _extendPointOnLine(lastPoint, remainingCurvePoints[0], remainingDist - nextPointDist);\n\n        outlinePoints.push(nextPoint);\n        outlinePointFound = true;\n      }\n    }\n  }\n\n  outlinePoints.push(endPoint);\n  return outlinePoints;\n};\n/** translate and scale from https://en.wikipedia.org/wiki/Procrustes_analysis */\n\n\nconst normalizeCurve = curve => {\n  const outlinedCurve = outlineCurve(curve);\n  const meanX = average(outlinedCurve.map(point => point.x));\n  const meanY = average(outlinedCurve.map(point => point.y));\n  const mean = {\n    x: meanX,\n    y: meanY\n  };\n  const translatedCurve = outlinedCurve.map(point => subtract(point, mean));\n  const scale = Math.sqrt(average([Math.pow(translatedCurve[0].x, 2) + Math.pow(translatedCurve[0].y, 2), Math.pow(arrLast(translatedCurve).x, 2) + Math.pow(arrLast(translatedCurve).y, 2)]));\n  const scaledCurve = translatedCurve.map(point => ({\n    x: point.x / scale,\n    y: point.y / scale\n  }));\n  return subdivideCurve(scaledCurve);\n}; // rotate around the origin\n\n\nconst rotate = (curve, theta) => {\n  return curve.map(point => ({\n    x: Math.cos(theta) * point.x - Math.sin(theta) * point.y,\n    y: Math.sin(theta) * point.x + Math.cos(theta) * point.y\n  }));\n}; // remove intermediate points that are on the same line as the points to either side\n\n\nconst _filterParallelPoints = points => {\n  if (points.length < 3) return points;\n  const filteredPoints = [points[0], points[1]];\n  points.slice(2).forEach(point => {\n    const numFilteredPoints = filteredPoints.length;\n    const curVect = subtract(point, filteredPoints[numFilteredPoints - 1]);\n    const prevVect = subtract(filteredPoints[numFilteredPoints - 1], filteredPoints[numFilteredPoints - 2]); // this is the z coord of the cross-product. If this is 0 then they're parallel\n\n    const isParallel = curVect.y * prevVect.x - curVect.x * prevVect.y === 0;\n\n    if (isParallel) {\n      filteredPoints.pop();\n    }\n\n    filteredPoints.push(point);\n  });\n  return filteredPoints;\n};\n\nfunction getPathString(points, close = false) {\n  const start = round(points[0]);\n  const remainingPoints = points.slice(1);\n  let pathString = \"M \".concat(start.x, \" \").concat(start.y);\n  remainingPoints.forEach(point => {\n    const roundedPoint = round(point);\n    pathString += \" L \".concat(roundedPoint.x, \" \").concat(roundedPoint.y);\n  });\n\n  if (close) {\n    pathString += 'Z';\n  }\n\n  return pathString;\n}\n/** take points on a path and move their start point backwards by distance */\n\n\nconst extendStart = (points, dist) => {\n  const filteredPoints = _filterParallelPoints(points);\n\n  if (filteredPoints.length < 2) return filteredPoints;\n  const p1 = filteredPoints[1];\n  const p2 = filteredPoints[0];\n\n  const newStart = _extendPointOnLine(p1, p2, dist);\n\n  const extendedPoints = filteredPoints.slice(1);\n  extendedPoints.unshift(newStart);\n  return extendedPoints;\n};\n\nclass Stroke {\n  constructor(path, points, strokeNum, isInRadical = false) {\n    this.path = path;\n    this.points = points;\n    this.strokeNum = strokeNum;\n    this.isInRadical = isInRadical;\n  }\n\n  getStartingPoint() {\n    return this.points[0];\n  }\n\n  getEndingPoint() {\n    return this.points[this.points.length - 1];\n  }\n\n  getLength() {\n    return length(this.points);\n  }\n\n  getVectors() {\n    let lastPoint = this.points[0];\n    const pointsSansFirst = this.points.slice(1);\n    return pointsSansFirst.map(point => {\n      const vector = subtract(point, lastPoint);\n      lastPoint = point;\n      return vector;\n    });\n  }\n\n  getDistance(point) {\n    const distances = this.points.map(strokePoint => distance(strokePoint, point));\n    return Math.min(...distances);\n  }\n\n  getAverageDistance(points) {\n    const totalDist = points.reduce((acc, point) => acc + this.getDistance(point), 0);\n    return totalDist / points.length;\n  }\n\n}\n\nclass Character {\n  constructor(symbol, strokes) {\n    this.symbol = symbol;\n    this.strokes = strokes;\n  }\n\n}\n\nfunction generateStrokes({\n  radStrokes,\n  strokes,\n  medians\n}) {\n  const isInRadical = strokeNum => {\n    var _radStrokes$indexOf;\n\n    return ((_radStrokes$indexOf = radStrokes === null || radStrokes === void 0 ? void 0 : radStrokes.indexOf(strokeNum)) !== null && _radStrokes$indexOf !== void 0 ? _radStrokes$indexOf : -1) >= 0;\n  };\n\n  return strokes.map((path, index) => {\n    const points = medians[index].map(pointData => {\n      const [x, y] = pointData;\n      return {\n        x,\n        y\n      };\n    });\n    return new Stroke(path, points, index, isInRadical(index));\n  });\n}\n\nfunction parseCharData(symbol, charJson) {\n  const strokes = generateStrokes(charJson);\n  return new Character(symbol, strokes);\n} // All makemeahanzi characters have the same bounding box\n\n\nconst CHARACTER_BOUNDS = [{\n  x: 0,\n  y: -124\n}, {\n  x: 1024,\n  y: 900\n}];\nconst [from, to] = CHARACTER_BOUNDS;\nconst preScaledWidth = to.x - from.x;\nconst preScaledHeight = to.y - from.y;\n\nclass Positioner {\n  constructor(options) {\n    const {\n      padding,\n      width,\n      height\n    } = options;\n    this.padding = padding;\n    this.width = width;\n    this.height = height;\n    const effectiveWidth = width - 2 * padding;\n    const effectiveHeight = height - 2 * padding;\n    const scaleX = effectiveWidth / preScaledWidth;\n    const scaleY = effectiveHeight / preScaledHeight;\n    this.scale = Math.min(scaleX, scaleY);\n    const xCenteringBuffer = padding + (effectiveWidth - this.scale * preScaledWidth) / 2;\n    const yCenteringBuffer = padding + (effectiveHeight - this.scale * preScaledHeight) / 2;\n    this.xOffset = -1 * from.x * this.scale + xCenteringBuffer;\n    this.yOffset = -1 * from.y * this.scale + yCenteringBuffer;\n  }\n\n  convertExternalPoint(point) {\n    const x = (point.x - this.xOffset) / this.scale;\n    const y = (this.height - this.yOffset - point.y) / this.scale;\n    return {\n      x,\n      y\n    };\n  }\n\n}\n\nconst AVG_DIST_THRESHOLD = 350; // bigger = more lenient\n\nconst COSINE_SIMILARITY_THRESHOLD = 0; // -1 to 1, smaller = more lenient\n\nconst START_AND_END_DIST_THRESHOLD = 250; // bigger = more lenient\n\nconst FRECHET_THRESHOLD = 0.4; // bigger = more lenient\n\nconst MIN_LEN_THRESHOLD = 0.35; // smaller = more lenient\n\nfunction strokeMatches(userStroke, character, strokeNum, options = {}) {\n  const strokes = character.strokes;\n  const points = stripDuplicates(userStroke.points);\n\n  if (points.length < 2) {\n    return null;\n  }\n\n  const {\n    isMatch,\n    avgDist\n  } = getMatchData(points, strokes[strokeNum], options);\n\n  if (!isMatch) {\n    return false;\n  } // if there is a better match among strokes the user hasn't drawn yet, the user probably drew the wrong stroke\n\n\n  const laterStrokes = strokes.slice(strokeNum + 1);\n  let closestMatchDist = avgDist;\n\n  for (let i = 0; i < laterStrokes.length; i++) {\n    const {\n      isMatch,\n      avgDist\n    } = getMatchData(points, laterStrokes[i], options);\n\n    if (isMatch && avgDist < closestMatchDist) {\n      closestMatchDist = avgDist;\n    }\n  } // if there's a better match, rather that returning false automatically, try reducing leniency instead\n  // if leniency is already really high we can allow some similar strokes to pass\n\n\n  if (closestMatchDist < avgDist) {\n    // adjust leniency between 0.3 and 0.6 depending on how much of a better match the new match is\n    const leniencyAdjustment = 0.6 * (closestMatchDist + avgDist) / (2 * avgDist);\n    const {\n      isMatch\n    } = getMatchData(points, strokes[strokeNum], { ...options,\n      leniency: (options.leniency || 1) * leniencyAdjustment\n    });\n    return isMatch;\n  }\n\n  return true;\n}\n\nconst startAndEndMatches = (points, closestStroke, leniency) => {\n  const startingDist = distance(closestStroke.getStartingPoint(), points[0]);\n  const endingDist = distance(closestStroke.getEndingPoint(), points[points.length - 1]);\n  return startingDist <= START_AND_END_DIST_THRESHOLD * leniency && endingDist <= START_AND_END_DIST_THRESHOLD * leniency;\n}; // returns a list of the direction of all segments in the line connecting the points\n\n\nconst getEdgeVectors = points => {\n  const vectors = [];\n  let lastPoint = points[0];\n  points.slice(1).forEach(point => {\n    vectors.push(subtract(point, lastPoint));\n    lastPoint = point;\n  });\n  return vectors;\n};\n\nconst directionMatches = (points, stroke) => {\n  const edgeVectors = getEdgeVectors(points);\n  const strokeVectors = stroke.getVectors();\n  const similarities = edgeVectors.map(edgeVector => {\n    const strokeSimilarities = strokeVectors.map(strokeVector => cosineSimilarity(strokeVector, edgeVector));\n    return Math.max(...strokeSimilarities);\n  });\n  const avgSimilarity = average(similarities);\n  return avgSimilarity > COSINE_SIMILARITY_THRESHOLD;\n};\n\nconst lengthMatches = (points, stroke, leniency) => {\n  return leniency * (length(points) + 25) / (stroke.getLength() + 25) >= MIN_LEN_THRESHOLD;\n};\n\nconst stripDuplicates = points => {\n  if (points.length < 2) return points;\n  const [firstPoint, ...rest] = points;\n  const dedupedPoints = [firstPoint];\n\n  for (const point of rest) {\n    if (!equals(point, dedupedPoints[dedupedPoints.length - 1])) {\n      dedupedPoints.push(point);\n    }\n  }\n\n  return dedupedPoints;\n};\n\nconst SHAPE_FIT_ROTATIONS = [Math.PI / 16, Math.PI / 32, 0, -1 * Math.PI / 32, -1 * Math.PI / 16];\n\nconst shapeFit = (curve1, curve2, leniency) => {\n  const normCurve1 = normalizeCurve(curve1);\n  const normCurve2 = normalizeCurve(curve2);\n  let minDist = Infinity;\n  SHAPE_FIT_ROTATIONS.forEach(theta => {\n    const dist = frechetDist(normCurve1, rotate(normCurve2, theta));\n\n    if (dist < minDist) {\n      minDist = dist;\n    }\n  });\n  return minDist <= FRECHET_THRESHOLD * leniency;\n};\n\nconst getMatchData = (points, stroke, options) => {\n  const {\n    leniency = 1,\n    isOutlineVisible = false\n  } = options;\n  const avgDist = stroke.getAverageDistance(points);\n  const distMod = isOutlineVisible || stroke.strokeNum > 0 ? 0.5 : 1;\n  const withinDistThresh = avgDist <= AVG_DIST_THRESHOLD * distMod * leniency; // short circuit for faster matching\n\n  if (!withinDistThresh) {\n    return {\n      isMatch: false,\n      avgDist\n    };\n  }\n\n  const startAndEndMatch = startAndEndMatches(points, stroke, leniency);\n  const directionMatch = directionMatches(points, stroke);\n  const shapeMatch = shapeFit(points, stroke.points, leniency);\n  const lengthMatch = lengthMatches(points, stroke, leniency);\n  return {\n    isMatch: withinDistThresh && startAndEndMatch && directionMatch && shapeMatch && lengthMatch,\n    avgDist\n  };\n};\n\nclass UserStroke {\n  constructor(id, startingPoint, startingExternalPoint) {\n    this.id = id;\n    this.points = [startingPoint];\n    this.externalPoints = [startingExternalPoint];\n  }\n\n  appendPoint(point, externalPoint) {\n    this.points.push(point);\n    this.externalPoints.push(externalPoint);\n  }\n\n}\n\nclass Delay {\n  constructor(duration) {\n    this._duration = duration;\n    this._startTime = null;\n    this._paused = false;\n    this.scope = \"delay.\".concat(duration);\n  }\n\n  run() {\n    this._startTime = performanceNow();\n    this._runningPromise = new Promise(resolve => {\n      this._resolve = resolve; // @ts-ignore return type of \"setTimeout\" in builds is parsed as `number` instead of `Timeout`\n\n      this._timeout = setTimeout(() => this.cancel(), this._duration);\n    });\n    return this._runningPromise;\n  }\n\n  pause() {\n    if (this._paused) return; // to pause, clear the timeout and rewrite this._duration with whatever time is remaining\n\n    const elapsedDelay = performance.now() - (this._startTime || 0);\n    this._duration = Math.max(0, this._duration - elapsedDelay);\n    clearTimeout(this._timeout);\n    this._paused = true;\n  }\n\n  resume() {\n    if (!this._paused) return;\n    this._startTime = performance.now(); // @ts-ignore return type of \"setTimeout\" in builds is parsed as `number` instead of `Timeout`\n\n    this._timeout = setTimeout(() => this.cancel(), this._duration);\n    this._paused = false;\n  }\n\n  cancel() {\n    clearTimeout(this._timeout);\n\n    if (this._resolve) {\n      this._resolve();\n    }\n\n    this._resolve = undefined;\n  }\n\n}\n\nclass Mutation {\n  /**\n   *\n   * @param scope a string representation of what fields this mutation affects from the state. This is used to cancel conflicting mutations\n   * @param valuesOrCallable a thunk containing the value to set, or a callback which will return those values\n   */\n  constructor(scope, valuesOrCallable, options = {}) {\n    this._tick = timing => {\n      if (this._startPauseTime !== null) {\n        return;\n      }\n\n      const progress = Math.min(1, (timing - this._startTime - this._pausedDuration) / this._duration);\n\n      if (progress === 1) {\n        this._renderState.updateState(this._values);\n\n        this._frameHandle = undefined;\n        this.cancel(this._renderState);\n      } else {\n        const easedProgress = ease(progress);\n        const stateChanges = getPartialValues(this._startState, this._values, easedProgress);\n\n        this._renderState.updateState(stateChanges);\n\n        this._frameHandle = requestAnimationFrame(this._tick);\n      }\n    };\n\n    this.scope = scope;\n    this._valuesOrCallable = valuesOrCallable;\n    this._duration = options.duration || 0;\n    this._force = options.force;\n    this._pausedDuration = 0;\n    this._startPauseTime = null;\n  }\n\n  run(renderState) {\n    if (!this._values) this._inflateValues(renderState);\n    if (this._duration === 0) renderState.updateState(this._values);\n\n    if (this._duration === 0 || isAlreadyAtEnd(renderState.state, this._values)) {\n      return Promise.resolve();\n    }\n\n    this._renderState = renderState;\n    this._startState = renderState.state;\n    this._startTime = performance.now();\n    this._frameHandle = requestAnimationFrame(this._tick);\n    return new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n  _inflateValues(renderState) {\n    let values = this._valuesOrCallable;\n\n    if (typeof this._valuesOrCallable === 'function') {\n      values = this._valuesOrCallable(renderState.state);\n    }\n\n    this._values = inflate(this.scope, values);\n  }\n\n  pause() {\n    if (this._startPauseTime !== null) {\n      return;\n    }\n\n    if (this._frameHandle) {\n      cancelAnimationFrame(this._frameHandle);\n    }\n\n    this._startPauseTime = performance.now();\n  }\n\n  resume() {\n    if (this._startPauseTime === null) {\n      return;\n    }\n\n    this._frameHandle = requestAnimationFrame(this._tick);\n    this._pausedDuration += performance.now() - this._startPauseTime;\n    this._startPauseTime = null;\n  }\n\n  cancel(renderState) {\n    var _this$_resolve;\n\n    (_this$_resolve = this._resolve) === null || _this$_resolve === void 0 ? void 0 : _this$_resolve.call(this);\n    this._resolve = undefined;\n    cancelAnimationFrame(this._frameHandle || -1);\n    this._frameHandle = undefined;\n\n    if (this._force) {\n      if (!this._values) this._inflateValues(renderState);\n      renderState.updateState(this._values);\n    }\n  }\n\n}\n\nMutation.Delay = Delay;\n\nfunction getPartialValues(startValues, endValues, progress) {\n  const target = {};\n\n  for (const key in endValues) {\n    const endValue = endValues[key];\n    const startValue = startValues === null || startValues === void 0 ? void 0 : startValues[key];\n\n    if (typeof startValue === 'number' && typeof endValue === 'number' && endValue >= 0) {\n      target[key] = progress * (endValue - startValue) + startValue;\n    } else {\n      target[key] = getPartialValues(startValue, endValue, progress);\n    }\n  }\n\n  return target;\n}\n\nfunction isAlreadyAtEnd(startValues, endValues) {\n  for (const key in endValues) {\n    const endValue = endValues[key];\n    const startValue = startValues === null || startValues === void 0 ? void 0 : startValues[key];\n\n    if (endValue >= 0) {\n      if (endValue !== startValue) {\n        return false;\n      }\n    } else if (!isAlreadyAtEnd(startValue, endValue)) {\n      return false;\n    }\n  }\n\n  return true;\n} // from https://github.com/maxwellito/vivus\n\n\nconst ease = x => -Math.cos(x * Math.PI) / 2 + 0.5;\n\nconst showStrokes = (charName, character, duration) => {\n  return [new Mutation(\"character.\".concat(charName, \".strokes\"), objRepeat({\n    opacity: 1,\n    displayPortion: 1\n  }, character.strokes.length), {\n    duration,\n    force: true\n  })];\n};\n\nconst showCharacter = (charName, character, duration) => {\n  return [new Mutation(\"character.\".concat(charName), {\n    opacity: 1,\n    strokes: objRepeat({\n      opacity: 1,\n      displayPortion: 1\n    }, character.strokes.length)\n  }, {\n    duration,\n    force: true\n  })];\n};\n\nconst hideCharacter = (charName, character, duration) => {\n  return [new Mutation(\"character.\".concat(charName, \".opacity\"), 0, {\n    duration,\n    force: true\n  }), ...showStrokes(charName, character, 0)];\n};\n\nconst updateColor = (colorName, colorVal, duration) => {\n  return [new Mutation(\"options.\".concat(colorName), colorVal, {\n    duration\n  })];\n};\n\nconst highlightStroke = (stroke, color, speed) => {\n  const strokeNum = stroke.strokeNum;\n  const duration = (stroke.getLength() + 600) / (3 * speed);\n  return [new Mutation('character.highlight.strokeColor', color), new Mutation('character.highlight', {\n    opacity: 1,\n    strokes: {\n      [strokeNum]: {\n        displayPortion: 0,\n        opacity: 0\n      }\n    }\n  }), new Mutation(\"character.highlight.strokes.\".concat(strokeNum), {\n    displayPortion: 1,\n    opacity: 1\n  }, {\n    duration\n  }), new Mutation(\"character.highlight.strokes.\".concat(strokeNum, \".opacity\"), 0, {\n    duration\n  })];\n};\n\nconst animateStroke = (charName, stroke, speed) => {\n  const strokeNum = stroke.strokeNum;\n  const duration = (stroke.getLength() + 600) / (3 * speed);\n  return [new Mutation(\"character.\".concat(charName), {\n    opacity: 1,\n    strokes: {\n      [strokeNum]: {\n        displayPortion: 0,\n        opacity: 1\n      }\n    }\n  }), new Mutation(\"character.\".concat(charName, \".strokes.\").concat(strokeNum, \".displayPortion\"), 1, {\n    duration\n  })];\n};\n\nconst animateSingleStroke = (charName, character, strokeNum, speed) => {\n  const mutationStateFunc = state => {\n    const curCharState = state.character[charName];\n    const mutationState = {\n      opacity: 1,\n      strokes: {}\n    };\n\n    for (let i = 0; i < character.strokes.length; i++) {\n      mutationState.strokes[i] = {\n        opacity: curCharState.opacity * curCharState.strokes[i].opacity\n      };\n    }\n\n    return mutationState;\n  };\n\n  const stroke = character.strokes[strokeNum];\n  return [new Mutation(\"character.\".concat(charName), mutationStateFunc), ...animateStroke(charName, stroke, speed)];\n};\n\nconst showStroke = (charName, strokeNum, duration) => {\n  return [new Mutation(\"character.\".concat(charName, \".strokes.\").concat(strokeNum), {\n    displayPortion: 1,\n    opacity: 1\n  }, {\n    duration,\n    force: true\n  })];\n};\n\nconst animateCharacter = (charName, character, fadeDuration, speed, delayBetweenStrokes) => {\n  let mutations = hideCharacter(charName, character, fadeDuration);\n  mutations = mutations.concat(showStrokes(charName, character, 0));\n  mutations.push(new Mutation(\"character.\".concat(charName), {\n    opacity: 1,\n    strokes: objRepeat({\n      opacity: 0\n    }, character.strokes.length)\n  }, {\n    force: true\n  }));\n  character.strokes.forEach((stroke, i) => {\n    if (i > 0) mutations.push(new Mutation.Delay(delayBetweenStrokes));\n    mutations = mutations.concat(animateStroke(charName, stroke, speed));\n  });\n  return mutations;\n};\n\nconst animateCharacterLoop = (charName, character, fadeDuration, speed, delayBetweenStrokes, delayBetweenLoops) => {\n  const mutations = animateCharacter(charName, character, fadeDuration, speed, delayBetweenStrokes);\n  mutations.push(new Mutation.Delay(delayBetweenLoops));\n  return mutations;\n};\n\nconst startQuiz = (character, fadeDuration) => {\n  return [...hideCharacter('main', character, fadeDuration), new Mutation('character.highlight', {\n    opacity: 1,\n    strokes: objRepeat({\n      opacity: 0\n    }, character.strokes.length)\n  }, {\n    force: true\n  }), new Mutation('character.main', {\n    opacity: 1,\n    strokes: objRepeat({\n      opacity: 0\n    }, character.strokes.length)\n  }, {\n    force: true\n  })];\n};\n\nconst startUserStroke = (id, point) => {\n  return [new Mutation('quiz.activeUserStrokeId', id, {\n    force: true\n  }), new Mutation(\"userStrokes.\".concat(id), {\n    points: [point],\n    opacity: 1\n  }, {\n    force: true\n  })];\n};\n\nconst updateUserStroke = (userStrokeId, points) => {\n  return [new Mutation(\"userStrokes.\".concat(userStrokeId, \".points\"), points, {\n    force: true\n  })];\n};\n\nconst removeUserStroke = (userStrokeId, duration) => {\n  return [new Mutation(\"userStrokes.\".concat(userStrokeId, \".opacity\"), 0, {\n    duration\n  }), new Mutation(\"userStrokes.\".concat(userStrokeId), null, {\n    force: true\n  })];\n};\n\nconst highlightCompleteChar = (character, duration) => {\n  return [...hideCharacter('highlight', character), ...showCharacter('highlight', character, duration / 2), ...hideCharacter('highlight', character, duration / 2)];\n};\n\nconst getDrawnPath = userStroke => ({\n  pathString: getPathString(userStroke.externalPoints),\n  points: userStroke.points.map(point => round(point))\n});\n\nclass Quiz {\n  constructor(character, renderState, positioner) {\n    this._currentStrokeIndex = 0;\n    this._mistakesOnStroke = 0;\n    this._totalMistakes = 0;\n    this._character = character;\n    this._renderState = renderState;\n    this._isActive = false;\n    this._positioner = positioner;\n  }\n\n  startQuiz(options) {\n    this._isActive = true;\n    this._options = options;\n    this._currentStrokeIndex = 0;\n    this._mistakesOnStroke = 0;\n    this._totalMistakes = 0;\n    return this._renderState.run(startQuiz(this._character, options.strokeFadeDuration));\n  }\n\n  startUserStroke(externalPoint) {\n    if (!this._isActive) {\n      return null;\n    }\n\n    if (this._userStroke) {\n      return this.endUserStroke();\n    }\n\n    const point = this._positioner.convertExternalPoint(externalPoint);\n\n    const strokeId = counter();\n    this._userStroke = new UserStroke(strokeId, point, externalPoint);\n    return this._renderState.run(startUserStroke(strokeId, point));\n  }\n\n  continueUserStroke(externalPoint) {\n    if (!this._userStroke) {\n      return Promise.resolve();\n    }\n\n    const point = this._positioner.convertExternalPoint(externalPoint);\n\n    this._userStroke.appendPoint(point, externalPoint);\n\n    const nextPoints = this._userStroke.points.slice(0);\n\n    return this._renderState.run(updateUserStroke(this._userStroke.id, nextPoints));\n  }\n\n  endUserStroke() {\n    var _this$_options$drawin;\n\n    if (!this._userStroke) return;\n\n    this._renderState.run(removeUserStroke(this._userStroke.id, (_this$_options$drawin = this._options.drawingFadeDuration) !== null && _this$_options$drawin !== void 0 ? _this$_options$drawin : 300)); // skip single-point strokes\n\n\n    if (this._userStroke.points.length === 1) {\n      this._userStroke = undefined;\n      return;\n    }\n\n    const currentStroke = this._getCurrentStroke();\n\n    const isMatch = strokeMatches(this._userStroke, this._character, this._currentStrokeIndex, {\n      isOutlineVisible: this._renderState.state.character.outline.opacity > 0,\n      leniency: this._options.leniency\n    });\n\n    if (isMatch) {\n      this._handleSuccess();\n    } else {\n      this._handleFailure();\n\n      const {\n        showHintAfterMisses,\n        highlightColor,\n        strokeHighlightSpeed\n      } = this._options;\n\n      if (showHintAfterMisses !== false && this._mistakesOnStroke >= showHintAfterMisses) {\n        this._renderState.run(highlightStroke(currentStroke, colorStringToVals(highlightColor), strokeHighlightSpeed));\n      }\n    }\n\n    this._userStroke = undefined;\n  }\n\n  cancel() {\n    this._isActive = false;\n\n    if (this._userStroke) {\n      this._renderState.run(removeUserStroke(this._userStroke.id, this._options.drawingFadeDuration));\n    }\n  }\n\n  _getStrokeData(isCorrect = false) {\n    return {\n      character: this._character.symbol,\n      strokeNum: this._currentStrokeIndex,\n      mistakesOnStroke: this._mistakesOnStroke,\n      totalMistakes: this._totalMistakes,\n      strokesRemaining: this._character.strokes.length - this._currentStrokeIndex - (isCorrect ? 1 : 0),\n      drawnPath: getDrawnPath(this._userStroke)\n    };\n  }\n\n  _handleSuccess() {\n    if (!this._options) return;\n    const {\n      strokes,\n      symbol\n    } = this._character;\n    const {\n      onCorrectStroke,\n      onComplete,\n      highlightOnComplete,\n      strokeFadeDuration,\n      strokeHighlightDuration\n    } = this._options;\n    onCorrectStroke === null || onCorrectStroke === void 0 ? void 0 : onCorrectStroke(this._getStrokeData(true));\n    let animation = showStroke('main', this._currentStrokeIndex, strokeFadeDuration);\n    this._mistakesOnStroke = 0;\n    this._currentStrokeIndex += 1;\n    const isComplete = this._currentStrokeIndex === strokes.length;\n\n    if (isComplete) {\n      this._isActive = false;\n      onComplete === null || onComplete === void 0 ? void 0 : onComplete({\n        character: symbol,\n        totalMistakes: this._totalMistakes\n      });\n\n      if (highlightOnComplete) {\n        animation = animation.concat(highlightCompleteChar(this._character, (strokeHighlightDuration || 0) * 2));\n      }\n    }\n\n    this._renderState.run(animation);\n  }\n\n  _handleFailure() {\n    var _this$_options$onMist, _this$_options;\n\n    this._mistakesOnStroke += 1;\n    this._totalMistakes += 1;\n    (_this$_options$onMist = (_this$_options = this._options).onMistake) === null || _this$_options$onMist === void 0 ? void 0 : _this$_options$onMist.call(_this$_options, this._getStrokeData());\n  }\n\n  _getCurrentStroke() {\n    return this._character.strokes[this._currentStrokeIndex];\n  }\n\n}\n\nfunction createElm(elmType) {\n  return document.createElementNS('http://www.w3.org/2000/svg', elmType);\n}\n\nfunction attr(elm, name, value) {\n  elm.setAttributeNS(null, name, value);\n}\n\nfunction attrs(elm, attrsMap) {\n  Object.keys(attrsMap).forEach(attrName => attr(elm, attrName, attrsMap[attrName]));\n} // inspired by https://talk.observablehq.com/t/hanzi-writer-renders-incorrectly-inside-an-observable-notebook-on-a-mobile-browser/1898\n\n\nfunction urlIdRef(id) {\n  let prefix = '';\n\n  if (window.location && window.location.href) {\n    prefix = window.location.href.replace(/#[^#]*$/, '').replace(/\"/gi, '%22');\n  }\n\n  return \"url(\\\"\".concat(prefix, \"#\").concat(id, \"\\\")\");\n}\n\nfunction removeElm(elm) {\n  var _elm$parentNode;\n\n  elm === null || elm === void 0 ? void 0 : (_elm$parentNode = elm.parentNode) === null || _elm$parentNode === void 0 ? void 0 : _elm$parentNode.removeChild(elm);\n}\n\nclass StrokeRendererBase {\n  constructor(stroke) {\n    this.stroke = stroke;\n    this._pathLength = stroke.getLength() + StrokeRendererBase.STROKE_WIDTH / 2;\n  }\n\n  _getStrokeDashoffset(displayPortion) {\n    return this._pathLength * 0.999 * (1 - displayPortion);\n  }\n\n  _getColor({\n    strokeColor,\n    radicalColor\n  }) {\n    return radicalColor && this.stroke.isInRadical ? radicalColor : strokeColor;\n  }\n\n}\n\nStrokeRendererBase.STROKE_WIDTH = 200;\nconst STROKE_WIDTH = 200;\n/** This is a stroke composed of several stroke parts **/\n\nclass StrokeRenderer extends StrokeRendererBase {\n  constructor(stroke) {\n    super(stroke);\n    this._oldProps = undefined;\n  }\n\n  mount(target) {\n    this._animationPath = createElm('path');\n    this._clip = createElm('clipPath');\n    this._strokePath = createElm('path');\n    const maskId = \"mask-\".concat(counter());\n    attr(this._clip, 'id', maskId);\n    attr(this._strokePath, 'd', this.stroke.path);\n    this._animationPath.style.opacity = '0';\n    attr(this._animationPath, 'clip-path', urlIdRef(maskId));\n    const extendedMaskPoints = extendStart(this.stroke.points, STROKE_WIDTH / 2);\n    attr(this._animationPath, 'd', getPathString(extendedMaskPoints));\n    attrs(this._animationPath, {\n      stroke: '#FFFFFF',\n      'stroke-width': STROKE_WIDTH.toString(),\n      fill: 'none',\n      'stroke-linecap': 'round',\n      'stroke-linejoin': 'miter',\n      'stroke-dasharray': \"\".concat(this._pathLength, \",\").concat(this._pathLength)\n    });\n\n    this._clip.appendChild(this._strokePath);\n\n    target.defs.appendChild(this._clip);\n    target.svg.appendChild(this._animationPath);\n    return this;\n  }\n\n  render(props) {\n    var _this$_oldProps, _this$_oldProps2;\n\n    if (props === this._oldProps || !this._animationPath) {\n      return;\n    }\n\n    if (props.displayPortion !== ((_this$_oldProps = this._oldProps) === null || _this$_oldProps === void 0 ? void 0 : _this$_oldProps.displayPortion)) {\n      this._animationPath.style.strokeDashoffset = this._getStrokeDashoffset(props.displayPortion).toString();\n    }\n\n    const color = this._getColor(props);\n\n    if (!this._oldProps || color !== this._getColor(this._oldProps)) {\n      const {\n        r,\n        g,\n        b,\n        a\n      } = color;\n      attrs(this._animationPath, {\n        stroke: \"rgba(\".concat(r, \",\").concat(g, \",\").concat(b, \",\").concat(a, \")\")\n      });\n    }\n\n    if (props.opacity !== ((_this$_oldProps2 = this._oldProps) === null || _this$_oldProps2 === void 0 ? void 0 : _this$_oldProps2.opacity)) {\n      this._animationPath.style.opacity = props.opacity.toString();\n    }\n\n    this._oldProps = props;\n  }\n\n}\n\nclass CharacterRenderer {\n  constructor(character) {\n    this._oldProps = undefined;\n    this._strokeRenderers = character.strokes.map(stroke => new StrokeRenderer(stroke));\n  }\n\n  mount(target) {\n    const subTarget = target.createSubRenderTarget();\n    this._group = subTarget.svg;\n\n    this._strokeRenderers.forEach(strokeRenderer => {\n      strokeRenderer.mount(subTarget);\n    });\n  }\n\n  render(props) {\n    var _this$_oldProps, _this$_oldProps3;\n\n    if (props === this._oldProps || !this._group) {\n      return;\n    }\n\n    const {\n      opacity,\n      strokes,\n      strokeColor,\n      radicalColor = null\n    } = props;\n\n    if (opacity !== ((_this$_oldProps = this._oldProps) === null || _this$_oldProps === void 0 ? void 0 : _this$_oldProps.opacity)) {\n      this._group.style.opacity = opacity.toString(); // MS browsers seem to have a bug where if SVG is set to display:none, it sometimes breaks.\n      // More info: https://github.com/chanind/hanzi-writer/issues/164\n      // this is just a perf improvement, so disable for MS browsers\n\n      if (!isMsBrowser) {\n        var _this$_oldProps2;\n\n        if (opacity === 0) {\n          this._group.style.display = 'none';\n        } else if (((_this$_oldProps2 = this._oldProps) === null || _this$_oldProps2 === void 0 ? void 0 : _this$_oldProps2.opacity) === 0) {\n          this._group.style.removeProperty('display');\n        }\n      }\n    }\n\n    const colorsChanged = !this._oldProps || strokeColor !== this._oldProps.strokeColor || radicalColor !== this._oldProps.radicalColor;\n\n    if (colorsChanged || strokes !== ((_this$_oldProps3 = this._oldProps) === null || _this$_oldProps3 === void 0 ? void 0 : _this$_oldProps3.strokes)) {\n      for (let i = 0; i < this._strokeRenderers.length; i++) {\n        var _this$_oldProps4;\n\n        if (!colorsChanged && (_this$_oldProps4 = this._oldProps) !== null && _this$_oldProps4 !== void 0 && _this$_oldProps4.strokes && strokes[i] === this._oldProps.strokes[i]) {\n          continue;\n        }\n\n        this._strokeRenderers[i].render({\n          strokeColor,\n          radicalColor,\n          opacity: strokes[i].opacity,\n          displayPortion: strokes[i].displayPortion\n        });\n      }\n    }\n\n    this._oldProps = props;\n  }\n\n}\n\nclass UserStrokeRenderer {\n  constructor() {\n    this._oldProps = undefined;\n  }\n\n  mount(target) {\n    this._path = createElm('path');\n    target.svg.appendChild(this._path);\n  }\n\n  render(props) {\n    var _this$_oldProps, _this$_oldProps2, _this$_oldProps3, _this$_oldProps4;\n\n    if (!this._path || props === this._oldProps) {\n      return;\n    }\n\n    if (props.strokeColor !== ((_this$_oldProps = this._oldProps) === null || _this$_oldProps === void 0 ? void 0 : _this$_oldProps.strokeColor) || props.strokeWidth !== ((_this$_oldProps2 = this._oldProps) === null || _this$_oldProps2 === void 0 ? void 0 : _this$_oldProps2.strokeWidth)) {\n      const {\n        r,\n        g,\n        b,\n        a\n      } = props.strokeColor;\n      attrs(this._path, {\n        fill: 'none',\n        stroke: \"rgba(\".concat(r, \",\").concat(g, \",\").concat(b, \",\").concat(a, \")\"),\n        'stroke-width': props.strokeWidth.toString(),\n        'stroke-linecap': 'round',\n        'stroke-linejoin': 'round'\n      });\n    }\n\n    if (props.opacity !== ((_this$_oldProps3 = this._oldProps) === null || _this$_oldProps3 === void 0 ? void 0 : _this$_oldProps3.opacity)) {\n      attr(this._path, 'opacity', props.opacity.toString());\n    }\n\n    if (props.points !== ((_this$_oldProps4 = this._oldProps) === null || _this$_oldProps4 === void 0 ? void 0 : _this$_oldProps4.points)) {\n      attr(this._path, 'd', getPathString(props.points));\n    }\n\n    this._oldProps = props;\n  }\n\n  destroy() {\n    removeElm(this._path);\n  }\n\n}\n\nclass HanziWriterRenderer {\n  constructor(character, positioner) {\n    this._character = character;\n    this._positioner = positioner;\n    this._mainCharRenderer = new CharacterRenderer(character);\n    this._outlineCharRenderer = new CharacterRenderer(character);\n    this._highlightCharRenderer = new CharacterRenderer(character);\n    this._userStrokeRenderers = {};\n  }\n\n  mount(target) {\n    const positionedTarget = target.createSubRenderTarget();\n    const group = positionedTarget.svg;\n    const {\n      xOffset,\n      yOffset,\n      height,\n      scale\n    } = this._positioner;\n    attr(group, 'transform', \"translate(\".concat(xOffset, \", \").concat(height - yOffset, \") scale(\").concat(scale, \", \").concat(-1 * scale, \")\"));\n\n    this._outlineCharRenderer.mount(positionedTarget);\n\n    this._mainCharRenderer.mount(positionedTarget);\n\n    this._highlightCharRenderer.mount(positionedTarget);\n\n    this._positionedTarget = positionedTarget;\n  }\n\n  render(props) {\n    const {\n      main,\n      outline,\n      highlight\n    } = props.character;\n    const {\n      outlineColor,\n      radicalColor,\n      highlightColor,\n      strokeColor,\n      drawingWidth,\n      drawingColor\n    } = props.options;\n\n    this._outlineCharRenderer.render({\n      opacity: outline.opacity,\n      strokes: outline.strokes,\n      strokeColor: outlineColor\n    });\n\n    this._mainCharRenderer.render({\n      opacity: main.opacity,\n      strokes: main.strokes,\n      strokeColor,\n      radicalColor: radicalColor\n    });\n\n    this._highlightCharRenderer.render({\n      opacity: highlight.opacity,\n      strokes: highlight.strokes,\n      strokeColor: highlightColor\n    });\n\n    const userStrokes = props.userStrokes || {};\n\n    for (const userStrokeId in this._userStrokeRenderers) {\n      if (!userStrokes[userStrokeId]) {\n        var _this$_userStrokeRend;\n\n        (_this$_userStrokeRend = this._userStrokeRenderers[userStrokeId]) === null || _this$_userStrokeRend === void 0 ? void 0 : _this$_userStrokeRend.destroy();\n        delete this._userStrokeRenderers[userStrokeId];\n      }\n    }\n\n    for (const userStrokeId in userStrokes) {\n      const stroke = userStrokes[userStrokeId];\n\n      if (!stroke) {\n        continue;\n      }\n\n      const userStrokeProps = {\n        strokeWidth: drawingWidth,\n        strokeColor: drawingColor,\n        ...stroke\n      };\n\n      const strokeRenderer = (() => {\n        if (this._userStrokeRenderers[userStrokeId]) {\n          return this._userStrokeRenderers[userStrokeId];\n        }\n\n        const newStrokeRenderer = new UserStrokeRenderer();\n        newStrokeRenderer.mount(this._positionedTarget);\n        this._userStrokeRenderers[userStrokeId] = newStrokeRenderer;\n        return newStrokeRenderer;\n      })();\n\n      strokeRenderer.render(userStrokeProps);\n    }\n  }\n\n  destroy() {\n    removeElm(this._positionedTarget.svg);\n    this._positionedTarget.defs.innerHTML = '';\n  }\n\n}\n/** Generic render target */\n\n\nclass RenderTargetBase {\n  constructor(node) {\n    this.node = node;\n  }\n\n  addPointerStartListener(callback) {\n    this.node.addEventListener('mousedown', evt => {\n      callback(this._eventify(evt, this._getMousePoint));\n    });\n    this.node.addEventListener('touchstart', evt => {\n      callback(this._eventify(evt, this._getTouchPoint));\n    });\n  }\n\n  addPointerMoveListener(callback) {\n    this.node.addEventListener('mousemove', evt => {\n      callback(this._eventify(evt, this._getMousePoint));\n    });\n    this.node.addEventListener('touchmove', evt => {\n      callback(this._eventify(evt, this._getTouchPoint));\n    });\n  }\n\n  addPointerEndListener(callback) {\n    // TODO: find a way to not need global listeners\n    document.addEventListener('mouseup', callback);\n    document.addEventListener('touchend', callback);\n  }\n\n  getBoundingClientRect() {\n    return this.node.getBoundingClientRect();\n  }\n\n  _eventify(evt, pointFunc) {\n    return {\n      getPoint: () => pointFunc.call(this, evt),\n      preventDefault: () => evt.preventDefault()\n    };\n  }\n\n  _getMousePoint(evt) {\n    const {\n      left,\n      top\n    } = this.getBoundingClientRect();\n    const x = evt.clientX - left;\n    const y = evt.clientY - top;\n    return {\n      x,\n      y\n    };\n  }\n\n  _getTouchPoint(evt) {\n    const {\n      left,\n      top\n    } = this.getBoundingClientRect();\n    const x = evt.touches[0].clientX - left;\n    const y = evt.touches[0].clientY - top;\n    return {\n      x,\n      y\n    };\n  }\n\n}\n\nclass RenderTarget extends RenderTargetBase {\n  constructor(svg, defs) {\n    super(svg);\n    this.svg = svg;\n    this.defs = defs;\n\n    if ('createSVGPoint' in svg) {\n      this._pt = svg.createSVGPoint();\n    }\n  }\n\n  static init(elmOrId, width = '100%', height = '100%') {\n    const element = (() => {\n      if (typeof elmOrId === 'string') {\n        return document.getElementById(elmOrId);\n      }\n\n      return elmOrId;\n    })();\n\n    if (!element) {\n      throw new Error(\"HanziWriter target element not found: \".concat(elmOrId));\n    }\n\n    const nodeType = element.nodeName.toUpperCase();\n\n    const svg = (() => {\n      if (nodeType === 'SVG' || nodeType === 'G') {\n        return element;\n      } else {\n        const svg = createElm('svg');\n        element.appendChild(svg);\n        return svg;\n      }\n    })();\n\n    attrs(svg, {\n      width,\n      height\n    });\n    const defs = createElm('defs');\n    svg.appendChild(defs);\n    return new RenderTarget(svg, defs);\n  }\n\n  createSubRenderTarget() {\n    const group = createElm('g');\n    this.svg.appendChild(group);\n    return new RenderTarget(group, this.defs);\n  }\n\n  _getMousePoint(evt) {\n    if (this._pt) {\n      this._pt.x = evt.clientX;\n      this._pt.y = evt.clientY;\n\n      if ('getScreenCTM' in this.node) {\n        var _this$node$getScreenC;\n\n        const localPt = this._pt.matrixTransform((_this$node$getScreenC = this.node.getScreenCTM()) === null || _this$node$getScreenC === void 0 ? void 0 : _this$node$getScreenC.inverse());\n\n        return {\n          x: localPt.x,\n          y: localPt.y\n        };\n      }\n    }\n\n    return super._getMousePoint.call(this, evt);\n  }\n\n  _getTouchPoint(evt) {\n    if (this._pt) {\n      this._pt.x = evt.touches[0].clientX;\n      this._pt.y = evt.touches[0].clientY;\n\n      if ('getScreenCTM' in this.node) {\n        var _this$node$getScreenC2;\n\n        const localPt = this._pt.matrixTransform((_this$node$getScreenC2 = this.node.getScreenCTM()) === null || _this$node$getScreenC2 === void 0 ? void 0 : _this$node$getScreenC2.inverse());\n\n        return {\n          x: localPt.x,\n          y: localPt.y\n        };\n      }\n    }\n\n    return super._getTouchPoint(evt);\n  }\n\n}\n\nvar svgRenderer = {\n  HanziWriterRenderer,\n  createRenderTarget: RenderTarget.init\n};\n\nconst drawPath = (ctx, points) => {\n  ctx.beginPath();\n  const start = points[0];\n  const remainingPoints = points.slice(1);\n  ctx.moveTo(start.x, start.y);\n\n  for (const point of remainingPoints) {\n    ctx.lineTo(point.x, point.y);\n  }\n\n  ctx.stroke();\n};\n/**\n * Break a path string into a series of canvas path commands\n *\n * Note: only works with the subset of SVG paths used by MakeMeAHanzi data\n * @param pathString\n */\n\n\nconst pathStringToCanvas = pathString => {\n  const pathParts = pathString.split(/(^|\\s+)(?=[A-Z])/).filter(part => part !== ' ');\n  const commands = [ctx => ctx.beginPath()];\n\n  for (const part of pathParts) {\n    const [cmd, ...rawParams] = part.split(/\\s+/);\n    const params = rawParams.map(param => parseFloat(param));\n\n    if (cmd === 'M') {\n      commands.push(ctx => ctx.moveTo(...params));\n    } else if (cmd === 'L') {\n      commands.push(ctx => ctx.lineTo(...params));\n    } else if (cmd === 'C') {\n      commands.push(ctx => ctx.bezierCurveTo(...params));\n    } else if (cmd === 'Q') {\n      commands.push(ctx => ctx.quadraticCurveTo(...params));\n    } else ;\n  }\n\n  return ctx => commands.forEach(cmd => cmd(ctx));\n};\n/** this is a stroke composed of several stroke parts */\n\n\nclass StrokeRenderer$1 extends StrokeRendererBase {\n  constructor(stroke, usePath2D = true) {\n    super(stroke);\n\n    if (usePath2D && Path2D) {\n      this._path2D = new Path2D(this.stroke.path);\n    } else {\n      this._pathCmd = pathStringToCanvas(this.stroke.path);\n    }\n\n    this._extendedMaskPoints = extendStart(this.stroke.points, StrokeRendererBase.STROKE_WIDTH / 2);\n  }\n\n  render(ctx, props) {\n    if (props.opacity < 0.05) {\n      return;\n    }\n\n    ctx.save();\n\n    if (this._path2D) {\n      ctx.clip(this._path2D);\n    } else {\n      var _this$_pathCmd;\n\n      (_this$_pathCmd = this._pathCmd) === null || _this$_pathCmd === void 0 ? void 0 : _this$_pathCmd.call(this, ctx); // wechat bugs out if the clip path isn't stroked or filled\n\n      ctx.globalAlpha = 0;\n      ctx.stroke();\n      ctx.clip();\n    }\n\n    const {\n      r,\n      g,\n      b,\n      a\n    } = this._getColor(props);\n\n    const color = a === 1 ? \"rgb(\".concat(r, \",\").concat(g, \",\").concat(b, \")\") : \"rgb(\".concat(r, \",\").concat(g, \",\").concat(b, \",\").concat(a, \")\");\n\n    const dashOffset = this._getStrokeDashoffset(props.displayPortion);\n\n    ctx.globalAlpha = props.opacity;\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    ctx.lineWidth = StrokeRendererBase.STROKE_WIDTH;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round'; // wechat sets dashOffset as a second param here. Should be harmless for browsers to add here too\n    // @ts-ignore\n\n    ctx.setLineDash([this._pathLength, this._pathLength], dashOffset);\n    ctx.lineDashOffset = dashOffset;\n    drawPath(ctx, this._extendedMaskPoints);\n    ctx.restore();\n  }\n\n}\n\nclass CharacterRenderer$1 {\n  constructor(character) {\n    this._strokeRenderers = character.strokes.map(stroke => new StrokeRenderer$1(stroke));\n  }\n\n  render(ctx, props) {\n    if (props.opacity < 0.05) return;\n    const {\n      opacity,\n      strokeColor,\n      radicalColor,\n      strokes\n    } = props;\n\n    for (let i = 0; i < this._strokeRenderers.length; i++) {\n      this._strokeRenderers[i].render(ctx, {\n        strokeColor,\n        radicalColor,\n        opacity: strokes[i].opacity * opacity,\n        displayPortion: strokes[i].displayPortion || 0\n      });\n    }\n  }\n\n}\n\nfunction renderUserStroke(ctx, props) {\n  if (props.opacity < 0.05) {\n    return;\n  }\n\n  const {\n    opacity,\n    strokeWidth,\n    strokeColor,\n    points\n  } = props;\n  const {\n    r,\n    g,\n    b,\n    a\n  } = strokeColor;\n  ctx.save();\n  ctx.globalAlpha = opacity;\n  ctx.lineWidth = strokeWidth;\n  ctx.strokeStyle = \"rgba(\".concat(r, \",\").concat(g, \",\").concat(b, \",\").concat(a, \")\");\n  ctx.lineCap = 'round';\n  ctx.lineJoin = 'round';\n  drawPath(ctx, points);\n  ctx.restore();\n}\n\nclass HanziWriterRenderer$1 {\n  constructor(character, positioner) {\n    this.destroy = noop;\n    this._character = character;\n    this._positioner = positioner;\n    this._mainCharRenderer = new CharacterRenderer$1(character);\n    this._outlineCharRenderer = new CharacterRenderer$1(character);\n    this._highlightCharRenderer = new CharacterRenderer$1(character);\n  }\n\n  mount(target) {\n    this._target = target;\n  }\n\n  _animationFrame(cb) {\n    const {\n      width,\n      height,\n      scale,\n      xOffset,\n      yOffset\n    } = this._positioner;\n\n    const ctx = this._target.getContext();\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.save();\n    ctx.translate(xOffset, height - yOffset);\n    ctx.transform(1, 0, 0, -1, 0, 0);\n    ctx.scale(scale, scale);\n    cb(ctx);\n    ctx.restore(); // @ts-expect-error Verify if this is still needed for the \"wechat miniprogram\".\n\n    if (ctx.draw) {\n      // @ts-expect-error\n      ctx.draw();\n    }\n  }\n\n  render(props) {\n    const {\n      outline,\n      main,\n      highlight\n    } = props.character;\n    const {\n      outlineColor,\n      strokeColor,\n      radicalColor,\n      highlightColor,\n      drawingColor,\n      drawingWidth\n    } = props.options;\n\n    this._animationFrame(ctx => {\n      this._outlineCharRenderer.render(ctx, {\n        opacity: outline.opacity,\n        strokes: outline.strokes,\n        strokeColor: outlineColor\n      });\n\n      this._mainCharRenderer.render(ctx, {\n        opacity: main.opacity,\n        strokes: main.strokes,\n        strokeColor: strokeColor,\n        radicalColor: radicalColor\n      });\n\n      this._highlightCharRenderer.render(ctx, {\n        opacity: highlight.opacity,\n        strokes: highlight.strokes,\n        strokeColor: highlightColor\n      });\n\n      const userStrokes = props.userStrokes || {};\n\n      for (const userStrokeId in userStrokes) {\n        const userStroke = userStrokes[userStrokeId];\n\n        if (userStroke) {\n          const userStrokeProps = {\n            strokeWidth: drawingWidth,\n            strokeColor: drawingColor,\n            ...userStroke\n          };\n          renderUserStroke(ctx, userStrokeProps);\n        }\n      }\n    });\n  }\n\n}\n\nclass RenderTarget$1 extends RenderTargetBase {\n  constructor(canvas) {\n    super(canvas);\n  }\n\n  static init(elmOrId, width = '100%', height = '100%') {\n    const element = (() => {\n      if (typeof elmOrId === 'string') {\n        return document.getElementById(elmOrId);\n      }\n\n      return elmOrId;\n    })();\n\n    if (!element) {\n      throw new Error(\"HanziWriter target element not found: \".concat(elmOrId));\n    }\n\n    const nodeType = element.nodeName.toUpperCase();\n\n    const canvas = (() => {\n      if (nodeType === 'CANVAS') {\n        return element;\n      }\n\n      const canvas = document.createElement('canvas');\n      element.appendChild(canvas);\n      return canvas;\n    })();\n\n    canvas.setAttribute('width', width);\n    canvas.setAttribute('height', height);\n    return new RenderTarget$1(canvas);\n  }\n\n  getContext() {\n    return this.node.getContext('2d');\n  }\n\n}\n\nvar canvasRenderer = {\n  HanziWriterRenderer: HanziWriterRenderer$1,\n  createRenderTarget: RenderTarget$1.init\n};\nconst VERSION = '2.0';\n\nconst getCharDataUrl = char => \"https://cdn.jsdelivr.net/npm/hanzi-writer-data@\".concat(VERSION, \"/\").concat(char, \".json\");\n\nconst defaultCharDataLoader = (char, onLoad, onError) => {\n  // load char data from hanziwriter cdn (currently hosted on jsdelivr)\n  const xhr = new XMLHttpRequest();\n\n  if (xhr.overrideMimeType) {\n    // IE 9 and 10 don't seem to support this...\n    xhr.overrideMimeType('application/json');\n  }\n\n  xhr.open('GET', getCharDataUrl(char), true);\n\n  xhr.onerror = event => {\n    onError(xhr, event);\n  };\n\n  xhr.onreadystatechange = () => {\n    // TODO: error handling\n    if (xhr.readyState !== 4) return;\n\n    if (xhr.status === 200) {\n      onLoad(JSON.parse(xhr.responseText));\n    } else if (xhr.status !== 0 && onError) {\n      onError(xhr);\n    }\n  };\n\n  xhr.send(null);\n};\n\nconst defaultOptions = {\n  charDataLoader: defaultCharDataLoader,\n  onLoadCharDataError: null,\n  onLoadCharDataSuccess: null,\n  showOutline: true,\n  showCharacter: true,\n  renderer: 'svg',\n  // positioning options\n  width: 0,\n  height: 0,\n  padding: 20,\n  // animation options\n  strokeAnimationSpeed: 1,\n  strokeFadeDuration: 400,\n  strokeHighlightDuration: 200,\n  strokeHighlightSpeed: 2,\n  delayBetweenStrokes: 1000,\n  delayBetweenLoops: 2000,\n  // colors\n  strokeColor: '#555',\n  radicalColor: null,\n  highlightColor: '#AAF',\n  outlineColor: '#DDD',\n  drawingColor: '#333',\n  // quiz options\n  leniency: 1,\n  showHintAfterMisses: 3,\n  highlightOnComplete: true,\n  highlightCompleteColor: null,\n  // undocumented obscure options\n  drawingFadeDuration: 300,\n  drawingWidth: 4,\n  strokeWidth: 2,\n  outlineWidth: 2,\n  rendererOverride: {}\n};\n\nclass LoadingManager {\n  constructor(options) {\n    this._loadCounter = 0;\n    this._isLoading = false;\n    /** use this to attribute to determine if there was a problem with loading */\n\n    this.loadingFailed = false;\n    this._options = options;\n  }\n\n  _debouncedLoad(char, count) {\n    // these wrappers ignore all responses except the most recent.\n    const wrappedResolve = data => {\n      if (count === this._loadCounter) {\n        var _this$_resolve;\n\n        (_this$_resolve = this._resolve) === null || _this$_resolve === void 0 ? void 0 : _this$_resolve.call(this, data);\n      }\n    };\n\n    const wrappedReject = reason => {\n      if (count === this._loadCounter) {\n        var _this$_reject;\n\n        (_this$_reject = this._reject) === null || _this$_reject === void 0 ? void 0 : _this$_reject.call(this, reason);\n      }\n    };\n\n    const returnedData = this._options.charDataLoader(char, wrappedResolve, wrappedReject);\n\n    if (returnedData) {\n      if ('then' in returnedData) {\n        returnedData.then(wrappedResolve).catch(wrappedReject);\n      } else {\n        wrappedResolve(returnedData);\n      }\n    }\n  }\n\n  _setupLoadingPromise() {\n    return new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    }).then(data => {\n      var _this$_options$onLoad, _this$_options;\n\n      this._isLoading = false;\n      (_this$_options$onLoad = (_this$_options = this._options).onLoadCharDataSuccess) === null || _this$_options$onLoad === void 0 ? void 0 : _this$_options$onLoad.call(_this$_options, data);\n      return data;\n    }).catch(reason => {\n      this._isLoading = false;\n      this.loadingFailed = true; // If the user has provided an \"onLoadCharDataError\", call this function\n      // Otherwise, throw the promise\n\n      if (this._options.onLoadCharDataError) {\n        this._options.onLoadCharDataError(reason);\n\n        return;\n      } // If error callback wasn't provided, throw an error so the developer will be aware something went wrong\n\n\n      if (reason instanceof Error) {\n        throw reason;\n      }\n\n      const err = new Error(\"Failed to load char data for \".concat(this._loadingChar));\n      err.reason = reason;\n      throw err;\n    });\n  }\n\n  loadCharData(char) {\n    this._loadingChar = char;\n\n    const promise = this._setupLoadingPromise();\n\n    this.loadingFailed = false;\n    this._isLoading = true;\n    this._loadCounter++;\n\n    this._debouncedLoad(char, this._loadCounter);\n\n    return promise;\n  }\n\n}\n\nclass HanziWriter {\n  constructor(element, options = {}) {\n    const {\n      HanziWriterRenderer,\n      createRenderTarget\n    } = options.renderer === 'canvas' ? canvasRenderer : svgRenderer;\n    const rendererOverride = options.rendererOverride || {};\n    this._renderer = {\n      HanziWriterRenderer: rendererOverride.HanziWriterRenderer || HanziWriterRenderer,\n      createRenderTarget: rendererOverride.createRenderTarget || createRenderTarget\n    }; // wechat miniprogram component needs direct access to the render target, so this is public\n\n    this.target = this._renderer.createRenderTarget(element, options.width, options.height);\n    this._options = this._assignOptions(options);\n    this._loadingManager = new LoadingManager(this._options);\n\n    this._setupListeners();\n  }\n  /** Main entry point */\n\n\n  static create(element, character, options) {\n    const writer = new HanziWriter(element, options);\n    writer.setCharacter(character);\n    return writer;\n  }\n\n  static loadCharacterData(character, options = {}) {\n    const loadingManager = (() => {\n      const {\n        _loadingManager,\n        _loadingOptions\n      } = HanziWriter;\n\n      if ((_loadingManager === null || _loadingManager === void 0 ? void 0 : _loadingManager._loadingChar) === character && _loadingOptions === options) {\n        return _loadingManager;\n      }\n\n      return new LoadingManager({ ...defaultOptions,\n        ...options\n      });\n    })();\n\n    HanziWriter._loadingManager = loadingManager;\n    HanziWriter._loadingOptions = options;\n    return loadingManager.loadCharData(character);\n  }\n\n  static getScalingTransform(width, height, padding = 0) {\n    const positioner = new Positioner({\n      width,\n      height,\n      padding\n    });\n    return {\n      x: positioner.xOffset,\n      y: positioner.yOffset,\n      scale: positioner.scale,\n      transform: trim(\"\\n        translate(\".concat(positioner.xOffset, \", \").concat(positioner.height - positioner.yOffset, \")\\n        scale(\").concat(positioner.scale, \", \").concat(-1 * positioner.scale, \")\\n      \")).replace(/\\s+/g, ' ')\n    };\n  }\n\n  showCharacter(options = {}) {\n    this._options.showCharacter = true;\n    return this._withData(() => {\n      var _this$_renderState;\n\n      return (_this$_renderState = this._renderState) === null || _this$_renderState === void 0 ? void 0 : _this$_renderState.run(showCharacter('main', this._character, typeof options.duration === 'number' ? options.duration : this._options.strokeFadeDuration)).then(res => {\n        var _options$onComplete;\n\n        (_options$onComplete = options.onComplete) === null || _options$onComplete === void 0 ? void 0 : _options$onComplete.call(options, res);\n        return res;\n      });\n    });\n  }\n\n  hideCharacter(options = {}) {\n    this._options.showCharacter = false;\n    return this._withData(() => {\n      var _this$_renderState2;\n\n      return (_this$_renderState2 = this._renderState) === null || _this$_renderState2 === void 0 ? void 0 : _this$_renderState2.run(hideCharacter('main', this._character, typeof options.duration === 'number' ? options.duration : this._options.strokeFadeDuration)).then(res => {\n        var _options$onComplete2;\n\n        (_options$onComplete2 = options.onComplete) === null || _options$onComplete2 === void 0 ? void 0 : _options$onComplete2.call(options, res);\n        return res;\n      });\n    });\n  }\n\n  animateCharacter(options = {}) {\n    this.cancelQuiz();\n    return this._withData(() => {\n      var _this$_renderState3;\n\n      return (_this$_renderState3 = this._renderState) === null || _this$_renderState3 === void 0 ? void 0 : _this$_renderState3.run(animateCharacter('main', this._character, this._options.strokeFadeDuration, this._options.strokeAnimationSpeed, this._options.delayBetweenStrokes)).then(res => {\n        var _options$onComplete3;\n\n        (_options$onComplete3 = options.onComplete) === null || _options$onComplete3 === void 0 ? void 0 : _options$onComplete3.call(options, res);\n        return res;\n      });\n    });\n  }\n\n  animateStroke(strokeNum, options = {}) {\n    this.cancelQuiz();\n    return this._withData(() => {\n      var _this$_renderState4;\n\n      return (_this$_renderState4 = this._renderState) === null || _this$_renderState4 === void 0 ? void 0 : _this$_renderState4.run(animateSingleStroke('main', this._character, strokeNum, this._options.strokeAnimationSpeed)).then(res => {\n        var _options$onComplete4;\n\n        (_options$onComplete4 = options.onComplete) === null || _options$onComplete4 === void 0 ? void 0 : _options$onComplete4.call(options, res);\n        return res;\n      });\n    });\n  }\n\n  highlightStroke(strokeNum, options = {}) {\n    const promise = () => {\n      if (!this._character || !this._renderState) {\n        return;\n      }\n\n      return this._renderState.run(highlightStroke(this._character.strokes[strokeNum], colorStringToVals(this._options.highlightColor), this._options.strokeHighlightSpeed)).then(res => {\n        var _options$onComplete5;\n\n        (_options$onComplete5 = options.onComplete) === null || _options$onComplete5 === void 0 ? void 0 : _options$onComplete5.call(options, res);\n        return res;\n      });\n    };\n\n    return this._withData(promise);\n  }\n\n  async loopCharacterAnimation() {\n    this.cancelQuiz();\n    return this._withData(() => this._renderState.run(animateCharacterLoop('main', this._character, this._options.strokeFadeDuration, this._options.strokeAnimationSpeed, this._options.delayBetweenStrokes, this._options.delayBetweenLoops), {\n      loop: true\n    }));\n  }\n\n  pauseAnimation() {\n    return this._withData(() => {\n      var _this$_renderState5;\n\n      return (_this$_renderState5 = this._renderState) === null || _this$_renderState5 === void 0 ? void 0 : _this$_renderState5.pauseAll();\n    });\n  }\n\n  resumeAnimation() {\n    return this._withData(() => {\n      var _this$_renderState6;\n\n      return (_this$_renderState6 = this._renderState) === null || _this$_renderState6 === void 0 ? void 0 : _this$_renderState6.resumeAll();\n    });\n  }\n\n  showOutline(options = {}) {\n    this._options.showOutline = true;\n    return this._withData(() => {\n      var _this$_renderState7;\n\n      return (_this$_renderState7 = this._renderState) === null || _this$_renderState7 === void 0 ? void 0 : _this$_renderState7.run(showCharacter('outline', this._character, typeof options.duration === 'number' ? options.duration : this._options.strokeFadeDuration)).then(res => {\n        var _options$onComplete6;\n\n        (_options$onComplete6 = options.onComplete) === null || _options$onComplete6 === void 0 ? void 0 : _options$onComplete6.call(options, res);\n        return res;\n      });\n    });\n  }\n\n  hideOutline(options = {}) {\n    this._options.showOutline = false;\n    return this._withData(() => {\n      var _this$_renderState8;\n\n      return (_this$_renderState8 = this._renderState) === null || _this$_renderState8 === void 0 ? void 0 : _this$_renderState8.run(hideCharacter('outline', this._character, typeof options.duration === 'number' ? options.duration : this._options.strokeFadeDuration)).then(res => {\n        var _options$onComplete7;\n\n        (_options$onComplete7 = options.onComplete) === null || _options$onComplete7 === void 0 ? void 0 : _options$onComplete7.call(options, res);\n        return res;\n      });\n    });\n  }\n\n  updateColor(colorName, colorVal, options = {}) {\n    var _options$duration;\n\n    let mutations = [];\n\n    const fixedColorVal = (() => {\n      // If we're removing radical color, tween it to the stroke color\n      if (colorName === 'radicalColor' && !colorVal) {\n        return this._options.strokeColor;\n      }\n\n      return colorVal;\n    })();\n\n    const mappedColor = colorStringToVals(fixedColorVal);\n    this._options[colorName] = colorVal;\n    const duration = (_options$duration = options.duration) !== null && _options$duration !== void 0 ? _options$duration : this._options.strokeFadeDuration;\n    mutations = mutations.concat(updateColor(colorName, mappedColor, duration)); // make sure to set radicalColor back to null after the transition finishes if val == null\n\n    if (colorName === 'radicalColor' && !colorVal) {\n      mutations = mutations.concat(updateColor(colorName, null, 0));\n    }\n\n    return this._withData(() => {\n      var _this$_renderState9;\n\n      return (_this$_renderState9 = this._renderState) === null || _this$_renderState9 === void 0 ? void 0 : _this$_renderState9.run(mutations).then(res => {\n        var _options$onComplete8;\n\n        (_options$onComplete8 = options.onComplete) === null || _options$onComplete8 === void 0 ? void 0 : _options$onComplete8.call(options, res);\n        return res;\n      });\n    });\n  }\n\n  quiz(quizOptions = {}) {\n    return this._withData(async () => {\n      if (this._character && this._renderState && this._positioner) {\n        this.cancelQuiz();\n        this._quiz = new Quiz(this._character, this._renderState, this._positioner);\n        this._options = { ...this._options,\n          ...quizOptions\n        };\n\n        this._quiz.startQuiz(this._options);\n      }\n    });\n  }\n\n  cancelQuiz() {\n    if (this._quiz) {\n      this._quiz.cancel();\n\n      this._quiz = undefined;\n    }\n  }\n\n  setCharacter(char) {\n    this.cancelQuiz();\n    this._char = char;\n\n    if (this._hanziWriterRenderer) {\n      this._hanziWriterRenderer.destroy();\n    }\n\n    if (this._renderState) {\n      this._renderState.cancelAll();\n    }\n\n    this._hanziWriterRenderer = null;\n    this._withDataPromise = this._loadingManager.loadCharData(char).then(pathStrings => {\n      // if \"pathStrings\" isn't set, \".catch()\"\" was probably called and loading likely failed\n      if (!pathStrings || this._loadingManager.loadingFailed) {\n        return;\n      }\n\n      this._character = parseCharData(char, pathStrings);\n      const {\n        width,\n        height,\n        padding\n      } = this._options;\n      this._positioner = new Positioner({\n        width,\n        height,\n        padding\n      });\n      const hanziWriterRenderer = new this._renderer.HanziWriterRenderer(this._character, this._positioner);\n      this._hanziWriterRenderer = hanziWriterRenderer;\n      this._renderState = new RenderState(this._character, this._options, nextState => hanziWriterRenderer.render(nextState));\n\n      this._hanziWriterRenderer.mount(this.target);\n\n      this._hanziWriterRenderer.render(this._renderState.state);\n    });\n    return this._withDataPromise;\n  }\n\n  async getCharacterData() {\n    if (!this._char) {\n      throw new Error('setCharacter() must be called before calling getCharacterData()');\n    }\n\n    const character = await this._withData(() => this._character);\n    return character;\n  }\n\n  _assignOptions(options) {\n    const mergedOptions = { ...defaultOptions,\n      ...options\n    }; // backfill strokeAnimationSpeed if deprecated strokeAnimationDuration is provided instead\n\n    if (options.strokeAnimationDuration && !options.strokeAnimationSpeed) {\n      mergedOptions.strokeAnimationSpeed = 500 / options.strokeAnimationDuration;\n    }\n\n    if (options.strokeHighlightDuration && !options.strokeHighlightSpeed) {\n      mergedOptions.strokeHighlightSpeed = 500 / mergedOptions.strokeHighlightDuration;\n    }\n\n    if (!options.highlightCompleteColor) {\n      mergedOptions.highlightCompleteColor = mergedOptions.highlightColor;\n    }\n\n    return this._fillWidthAndHeight(mergedOptions);\n  }\n  /** returns a new options object with width and height filled in if missing */\n\n\n  _fillWidthAndHeight(options) {\n    const filledOpts = { ...options\n    };\n\n    if (filledOpts.width && !filledOpts.height) {\n      filledOpts.height = filledOpts.width;\n    } else if (filledOpts.height && !filledOpts.width) {\n      filledOpts.width = filledOpts.height;\n    } else if (!filledOpts.width && !filledOpts.height) {\n      const {\n        width,\n        height\n      } = this.target.getBoundingClientRect();\n      const minDim = Math.min(width, height);\n      filledOpts.width = minDim;\n      filledOpts.height = minDim;\n    }\n\n    return filledOpts;\n  }\n\n  _withData(func) {\n    // if this._loadingManager.loadingFailed, then loading failed before this method was called\n    if (this._loadingManager.loadingFailed) {\n      throw Error('Failed to load character data. Call setCharacter and try again.');\n    }\n\n    if (this._withDataPromise) {\n      return this._withDataPromise.then(() => {\n        if (!this._loadingManager.loadingFailed) {\n          return func();\n        }\n      });\n    }\n\n    return Promise.resolve().then(func);\n  }\n\n  _setupListeners() {\n    this.target.addPointerStartListener(evt => {\n      if (this._quiz) {\n        evt.preventDefault();\n\n        this._quiz.startUserStroke(evt.getPoint());\n      }\n    });\n    this.target.addPointerMoveListener(evt => {\n      if (this._quiz) {\n        evt.preventDefault();\n\n        this._quiz.continueUserStroke(evt.getPoint());\n      }\n    });\n    this.target.addPointerEndListener(() => {\n      var _this$_quiz;\n\n      (_this$_quiz = this._quiz) === null || _this$_quiz === void 0 ? void 0 : _this$_quiz.endUserStroke();\n    });\n  }\n\n}\n/** Singleton instance of LoadingManager. Only set in `loadCharacterData` */\n\n\nHanziWriter._loadingManager = null;\n/** Singleton loading options. Only set in `loadCharacterData` */\n\nHanziWriter._loadingOptions = null;\nexport default HanziWriter;","map":{"version":3,"sources":["../src/utils.ts","../src/RenderState.ts","../src/geometry.ts","../src/models/Stroke.ts","../src/models/Character.ts","../src/parseCharData.ts","../src/Positioner.ts","../src/strokeMatches.ts","../src/models/UserStroke.ts","../src/Mutation.ts","../src/characterActions.ts","../src/quizActions.ts","../src/Quiz.ts","../src/renderers/svg/svgUtils.ts","../src/renderers/StrokeRendererBase.ts","../src/renderers/svg/StrokeRenderer.ts","../src/renderers/svg/CharacterRenderer.ts","../src/renderers/svg/UserStrokeRenderer.ts","../src/renderers/svg/HanziWriterRenderer.ts","../src/renderers/RenderTargetBase.ts","../src/renderers/svg/RenderTarget.ts","../src/renderers/svg/index.ts","../src/renderers/canvas/canvasUtils.ts","../src/renderers/canvas/StrokeRenderer.ts","../src/renderers/canvas/CharacterRenderer.ts","../src/renderers/canvas/renderUserStroke.ts","../src/renderers/canvas/HanziWriterRenderer.ts","../src/renderers/canvas/RenderTarget.ts","../src/renderers/canvas/index.ts","../src/defaultCharDataLoader.ts","../src/defaultOptions.ts","../src/LoadingManager.ts","../src/HanziWriter.ts"],"names":["globalObj","performanceNow","Date","requestAnimationFrame","callback","setTimeout","cancelAnimationFrame","arr","output","base","key","override","baseVal","overrideVal","Array","copyAndMergeDeep","parts","scope","final","current","i","length","cap","count","sum","val","normalizedColor","colorString","hexParts","hexStr","r","parseInt","g","b","a","rgbMatch","parseFloat","trim","string","obj","times","ua","navigator","isMsBrowser","noop","_mutationChains","constructor","onStateChange","_onStateChange","state","options","drawingFadeDuration","drawingWidth","drawingColor","colorStringToVals","strokeColor","outlineColor","radicalColor","highlightColor","character","main","opacity","strokes","outline","highlight","userStrokes","displayPortion","updateState","nextState","run","scopes","mutations","mut","cancelMutations","resolve","mutationChain","_isActive","_index","_resolve","_mutations","_loop","_scopes","push","_run","chain","canceled","activeMutation","_getActiveMutations","pauseAll","forEach","mutation","resumeAll","chainId","scopeToCancel","scopesToCancel","_cancelMutationChain","cancelAll","subtract","x","p1","p2","y","magnitude","point","Math","distance","equals","point1","point2","round","precision","multiplier","points","lastPoint","pointsSansFirst","dist","acc","cosineSimilarity","rawDotProduct","_extendPointOnLine","vect","norm","frechetDist","longCurve","curve1","curve2","shortCurve","calcVal","j","prevResultsCol","lastResult","curResultsCol","subdivideCurve","maxLen","newCurve","curve","prevPoint","segLen","numNewPoints","newSegLen","outlineCurve","numPoints","curveLen","segmentLen","outlinePoints","endPoint","arrLast","remainingCurvePoints","remainingDist","outlinePointFound","nextPointDist","nextPoint","normalizeCurve","outlinedCurve","meanX","average","meanY","mean","translatedCurve","scale","scaledCurve","rotate","_filterParallelPoints","filteredPoints","numFilteredPoints","curVect","prevVect","isParallel","close","start","remainingPoints","pathString","roundedPoint","extendStart","newStart","extendedPoints","isInRadical","path","strokeNum","getStartingPoint","getEndingPoint","getLength","getVectors","vector","getDistance","distances","strokePoint","getAverageDistance","totalDist","symbol","medians","radStrokes","pointData","generateStrokes","CHARACTER_BOUNDS","preScaledWidth","to","from","preScaledHeight","height","padding","width","effectiveWidth","effectiveHeight","scaleX","scaleY","xCenteringBuffer","yCenteringBuffer","xOffset","yOffset","convertExternalPoint","AVG_DIST_THRESHOLD","COSINE_SIMILARITY_THRESHOLD","START_AND_END_DIST_THRESHOLD","FRECHET_THRESHOLD","MIN_LEN_THRESHOLD","stripDuplicates","userStroke","avgDist","getMatchData","isMatch","laterStrokes","closestMatchDist","leniencyAdjustment","leniency","startAndEndMatches","startingDist","closestStroke","endingDist","getEdgeVectors","vectors","directionMatches","edgeVectors","strokeVectors","stroke","similarities","edgeVector","strokeSimilarities","strokeVector","avgSimilarity","lengthMatches","dedupedPoints","rest","SHAPE_FIT_ROTATIONS","shapeFit","normCurve1","normCurve2","minDist","Infinity","theta","isOutlineVisible","distMod","withinDistThresh","startAndEndMatch","directionMatch","shapeMatch","lengthMatch","id","externalPoints","appendPoint","externalPoint","_duration","duration","_startTime","_paused","_runningPromise","_timeout","pause","elapsedDelay","performance","clearTimeout","resume","cancel","undefined","Mutation","_valuesOrCallable","valuesOrCallable","_force","force","_pausedDuration","_startPauseTime","_values","renderState","isAlreadyAtEnd","Promise","_renderState","_startState","_frameHandle","_inflateValues","values","inflate","timing","progress","easedProgress","ease","stateChanges","getPartialValues","target","endValues","endValue","startValue","startValues","showStrokes","charName","objRepeat","showCharacter","hideCharacter","updateColor","highlightStroke","animateStroke","animateSingleStroke","mutationStateFunc","curCharState","mutationState","showStroke","animateCharacter","animateCharacterLoop","startQuiz","characterActions","startUserStroke","updateUserStroke","userStrokeId","removeUserStroke","highlightCompleteChar","getDrawnPath","geometry","_currentStrokeIndex","_mistakesOnStroke","_totalMistakes","_character","_positioner","positioner","_options","quizActions","_userStroke","strokeId","counter","continueUserStroke","nextPoints","endUserStroke","currentStroke","strokeMatches","_handleSuccess","_handleFailure","strokeHighlightSpeed","showHintAfterMisses","_getStrokeData","isCorrect","mistakesOnStroke","totalMistakes","strokesRemaining","drawnPath","strokeHighlightDuration","onCorrectStroke","animation","isComplete","onComplete","highlightOnComplete","onMistake","_getCurrentStroke","document","elm","Object","attrName","attr","attrsMap","prefix","window","href","parentNode","removeChild","StrokeRendererBase","_pathLength","_getStrokeDashoffset","_getColor","STROKE_WIDTH","_oldProps","mount","_animationPath","svg","_clip","_strokePath","maskId","style","extendedMaskPoints","getPathString","fill","appendChild","render","props","strokeDashoffset","color","_strokeRenderers","subTarget","_group","strokeRenderer","display","removeProperty","colorsChanged","_path","destroy","_mainCharRenderer","_outlineCharRenderer","_highlightCharRenderer","_userStrokeRenderers","positionedTarget","group","_positionedTarget","userStrokeProps","strokeWidth","newStrokeRenderer","defs","innerHTML","node","addPointerStartListener","addEventListener","evt","addPointerMoveListener","addPointerEndListener","getBoundingClientRect","_eventify","getPoint","pointFunc","preventDefault","_getMousePoint","top","left","_getTouchPoint","init","elmOrId","element","nodeType","createElm","attrs","_pt","createSubRenderTarget","clientX","clientY","localPt","createRenderTarget","RenderTarget","drawPath","ctx","pathStringToCanvas","pathParts","part","commands","params","rawParams","param","cmd","usePath2D","Path2D","_path2D","_pathCmd","_extendedMaskPoints","dashOffset","_target","_animationFrame","cb","draw","renderUserStroke","canvas","getContext","HanziWriterRenderer","VERSION","getCharDataUrl","char","defaultCharDataLoader","xhr","overrideMimeType","event","onError","onLoad","JSON","defaultOptions","charDataLoader","onLoadCharDataError","onLoadCharDataSuccess","showOutline","renderer","strokeAnimationSpeed","strokeFadeDuration","delayBetweenStrokes","delayBetweenLoops","highlightCompleteColor","outlineWidth","rendererOverride","_loadCounter","_isLoading","loadingFailed","_debouncedLoad","wrappedResolve","data","wrappedReject","reason","_reject","returnedData","_setupLoadingPromise","reject","Error","err","loadCharData","_loadingChar","promise","create","writer","HanziWriter","loadCharacterData","loadingManager","_loadingOptions","_loadingManager","getScalingTransform","transform","svgRenderer","_renderer","_setupListeners","res","cancelQuiz","loopCharacterAnimation","loop","pauseAnimation","resumeAnimation","hideOutline","fixedColorVal","colorName","colorVal","mappedColor","quiz","quizOptions","_quiz","setCharacter","_char","_hanziWriterRenderer","_withDataPromise","pathStrings","parseCharData","hanziWriterRenderer","getCharacterData","_assignOptions","mergedOptions","_fillWidthAndHeight","filledOpts","minDim","_withData","func"],"mappings":"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","sourcesContent":["import { ColorObject, RecursivePartial } from './typings/types';\n\n// hacky way to get around rollup not properly setting `global` to `window` in browser\nconst globalObj = typeof window === 'undefined' ? global : window;\n\nexport const performanceNow =\n  (globalObj.performance && (() => globalObj.performance.now())) || (() => Date.now());\nexport const requestAnimationFrame =\n  globalObj.requestAnimationFrame ||\n  ((callback) => setTimeout(() => callback(performanceNow()), 1000 / 60));\nexport const cancelAnimationFrame = globalObj.cancelAnimationFrame || clearTimeout;\n\n// Object.assign polyfill, because IE :/\nexport const _assign = function (target: any, ...overrides: any[]) {\n  const overrideTarget = Object(target);\n  overrides.forEach((override) => {\n    if (override != null) {\n      for (const key in override) {\n        if (Object.prototype.hasOwnProperty.call(override, key)) {\n          overrideTarget[key] = override[key];\n        }\n      }\n    }\n  });\n  return overrideTarget;\n};\n\nexport const assign = Object.assign || _assign;\n\nexport function arrLast<TValue>(arr: Array<TValue>) {\n  return arr[arr.length - 1];\n}\n\nexport function copyAndMergeDeep<T>(base: T, override: RecursivePartial<T> | undefined) {\n  const output = { ...base };\n  for (const key in override) {\n    const baseVal = base[key];\n    const overrideVal = override[key];\n    if (baseVal === overrideVal) {\n      continue;\n    }\n    if (\n      baseVal &&\n      overrideVal &&\n      typeof baseVal === 'object' &&\n      typeof overrideVal === 'object' &&\n      !Array.isArray(overrideVal)\n    ) {\n      output[key] = copyAndMergeDeep(baseVal, overrideVal);\n    } else {\n      // @ts-ignore\n      output[key] = overrideVal;\n    }\n  }\n  return output;\n}\n\n/** basically a simplified version of lodash.get, selects a key out of an object like 'a.b' from {a: {b: 7}} */\nexport function inflate(scope: string, obj: any): any {\n  const parts = scope.split('.');\n  const final: any = {};\n  let current = final;\n  for (let i = 0; i < parts.length; i++) {\n    const cap = i === parts.length - 1 ? obj : {};\n    current[parts[i]] = cap;\n    current = cap;\n  }\n  return final;\n}\n\nlet count = 0;\n\nexport function counter() {\n  count++;\n  return count;\n}\n\nexport function average(arr: number[]) {\n  const sum = arr.reduce((acc, val) => val + acc, 0);\n  return sum / arr.length;\n}\n\nexport function timeout(duration = 0) {\n  return new Promise((resolve) => setTimeout(resolve, duration));\n}\n\nexport function colorStringToVals(colorString: string): ColorObject {\n  const normalizedColor = colorString.toUpperCase().trim();\n  // based on https://stackoverflow.com/a/21648508\n  if (/^#([A-F0-9]{3}){1,2}$/.test(normalizedColor)) {\n    let hexParts = normalizedColor.substring(1).split('');\n    if (hexParts.length === 3) {\n      hexParts = [\n        hexParts[0],\n        hexParts[0],\n        hexParts[1],\n        hexParts[1],\n        hexParts[2],\n        hexParts[2],\n      ];\n    }\n    const hexStr = `${hexParts.join('')}`;\n    return {\n      r: parseInt(hexStr.slice(0, 2), 16),\n      g: parseInt(hexStr.slice(2, 4), 16),\n      b: parseInt(hexStr.slice(4, 6), 16),\n      a: 1,\n    };\n  }\n  const rgbMatch = normalizedColor.match(\n    /^RGBA?\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(?:\\s*,\\s*(\\d*\\.?\\d+))?\\)$/,\n  );\n  if (rgbMatch) {\n    return {\n      r: parseInt(rgbMatch[1], 10),\n      g: parseInt(rgbMatch[2], 10),\n      b: parseInt(rgbMatch[3], 10),\n      // @ts-expect-error ts-migrate(2554) FIXME: Expected 1 arguments, but got 2.\n      a: parseFloat(rgbMatch[4] || 1, 10),\n    };\n  }\n  throw new Error(`Invalid color: ${colorString}`);\n}\n\nexport const trim = (string: string) => string.replace(/^\\s+/, '').replace(/\\s+$/, '');\n\n// return a new array-like object with int keys where each key is item\n// ex: objRepeat({x: 8}, 3) === {0: {x: 8}, 1: {x: 8}, 2: {x: 8}}\nexport function objRepeat<T>(item: T, times: number) {\n  const obj: Record<number, T> = {};\n  for (let i = 0; i < times; i++) {\n    obj[i] = item;\n  }\n  return obj;\n}\n\nconst ua = globalObj.navigator?.userAgent || '';\n\nexport const isMsBrowser =\n  ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop = () => {};\n","import Character from './models/Character';\nimport { GenericMutation } from './Mutation';\nimport {\n  ColorObject,\n  OnCompleteFunction,\n  Point,\n  RecursivePartial,\n} from './typings/types';\nimport { copyAndMergeDeep, colorStringToVals, noop } from './utils';\n\nexport type StrokeRenderState = {\n  opacity: number;\n  displayPortion: number;\n};\n\nexport type CharacterRenderState = {\n  opacity: number;\n  strokes: Record<number | string, StrokeRenderState>;\n};\n\nexport type RenderStateObject = {\n  options: {\n    drawingFadeDuration: number;\n    drawingWidth: number;\n    drawingColor: ColorObject;\n    strokeColor: ColorObject;\n    outlineColor: ColorObject;\n    radicalColor: ColorObject;\n    highlightColor: ColorObject;\n  };\n  character: {\n    main: CharacterRenderState;\n    outline: CharacterRenderState;\n    highlight: CharacterRenderState;\n  };\n  userStrokes: Record<\n    string,\n    | {\n        points: Point[];\n        opacity: number;\n      }\n    | undefined\n  > | null;\n};\n\nexport type CharacterName = keyof RenderStateObject['character'];\n\ntype OnStateChangeCallback = (\n  nextState: RenderStateObject,\n  currentState: RenderStateObject,\n) => void;\n\ntype MutationChain = {\n  _isActive: boolean;\n  _index: number;\n  _resolve: OnCompleteFunction;\n  _mutations: GenericMutation[];\n  _loop: boolean | undefined;\n  _scopes: string[];\n};\n\nexport type RenderStateOptions = {\n  strokeColor: string;\n  radicalColor: string | null;\n  highlightColor: string;\n  outlineColor: string;\n  drawingColor: string;\n  drawingFadeDuration: number;\n  drawingWidth: number;\n  outlineWidth: number;\n  showCharacter: boolean;\n  showOutline: boolean;\n};\n\nexport default class RenderState {\n  _mutationChains: MutationChain[] = [];\n  _onStateChange: OnStateChangeCallback;\n\n  state: RenderStateObject;\n\n  constructor(\n    character: Character,\n    options: RenderStateOptions,\n    onStateChange: OnStateChangeCallback = noop,\n  ) {\n    this._onStateChange = onStateChange;\n\n    this.state = {\n      options: {\n        drawingFadeDuration: options.drawingFadeDuration,\n        drawingWidth: options.drawingWidth,\n        drawingColor: colorStringToVals(options.drawingColor),\n        strokeColor: colorStringToVals(options.strokeColor),\n        outlineColor: colorStringToVals(options.outlineColor),\n        radicalColor: colorStringToVals(options.radicalColor || options.strokeColor),\n        highlightColor: colorStringToVals(options.highlightColor),\n      },\n      character: {\n        main: {\n          opacity: options.showCharacter ? 1 : 0,\n          strokes: {},\n        },\n        outline: {\n          opacity: options.showOutline ? 1 : 0,\n          strokes: {},\n        },\n        highlight: {\n          opacity: 1,\n          strokes: {},\n        },\n      },\n      userStrokes: null,\n    };\n\n    for (let i = 0; i < character.strokes.length; i++) {\n      this.state.character.main.strokes[i] = {\n        opacity: 1,\n        displayPortion: 1,\n      };\n\n      this.state.character.outline.strokes[i] = {\n        opacity: 1,\n        displayPortion: 1,\n      };\n\n      this.state.character.highlight.strokes[i] = {\n        opacity: 0,\n        displayPortion: 1,\n      };\n    }\n  }\n\n  updateState(stateChanges: RecursivePartial<RenderStateObject>) {\n    const nextState = copyAndMergeDeep(this.state, stateChanges);\n    this._onStateChange(nextState, this.state);\n    this.state = nextState;\n  }\n\n  run(\n    mutations: GenericMutation[],\n    options: {\n      loop?: boolean;\n    } = {},\n  ) {\n    const scopes = mutations.map((mut) => mut.scope);\n\n    this.cancelMutations(scopes);\n\n    return new Promise((resolve: OnCompleteFunction) => {\n      const mutationChain: MutationChain = {\n        _isActive: true,\n        _index: 0,\n        _resolve: resolve,\n        _mutations: mutations,\n        _loop: options.loop,\n        _scopes: scopes,\n      };\n      this._mutationChains.push(mutationChain);\n      this._run(mutationChain);\n    });\n  }\n\n  _run(mutationChain: MutationChain) {\n    if (!mutationChain._isActive) {\n      return;\n    }\n\n    const mutations = mutationChain._mutations;\n    if (mutationChain._index >= mutations.length) {\n      if (mutationChain._loop) {\n        mutationChain._index = 0; // eslint-disable-line no-param-reassign\n      } else {\n        mutationChain._isActive = false; // eslint-disable-line no-param-reassign\n        this._mutationChains = this._mutationChains.filter(\n          (chain) => chain !== mutationChain,\n        );\n        // The chain is done - resolve the promise to signal it finished successfully\n        mutationChain._resolve({ canceled: false });\n        return;\n      }\n    }\n\n    const activeMutation = mutationChain._mutations[mutationChain._index];\n\n    activeMutation.run(this).then(() => {\n      if (mutationChain._isActive) {\n        mutationChain._index++; // eslint-disable-line no-param-reassign\n        this._run(mutationChain);\n      }\n    });\n  }\n\n  _getActiveMutations() {\n    return this._mutationChains.map((chain) => chain._mutations[chain._index]);\n  }\n\n  pauseAll() {\n    this._getActiveMutations().forEach((mutation) => mutation.pause());\n  }\n\n  resumeAll() {\n    this._getActiveMutations().forEach((mutation) => mutation.resume());\n  }\n\n  cancelMutations(scopesToCancel: string[]) {\n    for (const chain of this._mutationChains) {\n      for (const chainId of chain._scopes) {\n        for (const scopeToCancel of scopesToCancel) {\n          if (chainId.startsWith(scopeToCancel) || scopeToCancel.startsWith(chainId)) {\n            this._cancelMutationChain(chain);\n          }\n        }\n      }\n    }\n  }\n\n  cancelAll() {\n    this.cancelMutations(['']);\n  }\n\n  _cancelMutationChain(mutationChain: MutationChain) {\n    mutationChain._isActive = false;\n    for (let i = mutationChain._index; i < mutationChain._mutations.length; i++) {\n      mutationChain._mutations[i].cancel(this);\n    }\n\n    mutationChain._resolve?.({ canceled: true });\n\n    this._mutationChains = this._mutationChains.filter(\n      (chain) => chain !== mutationChain,\n    );\n  }\n}\n","import { Point } from './typings/types';\nimport { average, arrLast } from './utils';\n\nexport const subtract = (p1: Point, p2: Point) => ({ x: p1.x - p2.x, y: p1.y - p2.y });\n\nexport const magnitude = (point: Point) =>\n  Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\n\nexport const distance = (point1: Point, point2: Point) =>\n  magnitude(subtract(point1, point2));\n\nexport const equals = (point1: Point, point2: Point) =>\n  point1.x === point2.x && point1.y === point2.y;\n\nexport const round = (point: Point, precision = 1) => {\n  const multiplier = precision * 10;\n  return {\n    x: Math.round(multiplier * point.x) / multiplier,\n    y: Math.round(multiplier * point.y) / multiplier,\n  };\n};\n\nexport const length = (points: Point[]) => {\n  let lastPoint = points[0];\n  const pointsSansFirst = points.slice(1);\n  return pointsSansFirst.reduce((acc, point) => {\n    const dist = distance(point, lastPoint);\n    lastPoint = point;\n    return acc + dist;\n  }, 0);\n};\n\nexport const cosineSimilarity = (point1: Point, point2: Point) => {\n  const rawDotProduct = point1.x * point2.x + point1.y * point2.y;\n  return rawDotProduct / magnitude(point1) / magnitude(point2);\n};\n\n/**\n * return a new point, p3, which is on the same line as p1 and p2, but distance away\n * from p2. p1, p2, p3 will always lie on the line in that order\n */\nexport const _extendPointOnLine = (p1: Point, p2: Point, dist: number) => {\n  const vect = subtract(p2, p1);\n  const norm = dist / magnitude(vect);\n  return { x: p2.x + norm * vect.x, y: p2.y + norm * vect.y };\n};\n\n/** based on http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf */\nexport const frechetDist = (curve1: Point[], curve2: Point[]) => {\n  const longCurve = curve1.length >= curve2.length ? curve1 : curve2;\n  const shortCurve = curve1.length >= curve2.length ? curve2 : curve1;\n\n  const calcVal = (\n    i: number,\n    j: number,\n    prevResultsCol: number[],\n    curResultsCol: number[],\n  ): number => {\n    if (i === 0 && j === 0) {\n      return distance(longCurve[0], shortCurve[0]);\n    }\n\n    if (i > 0 && j === 0) {\n      return Math.max(prevResultsCol[0], distance(longCurve[i], shortCurve[0]));\n    }\n\n    const lastResult = curResultsCol[curResultsCol.length - 1];\n\n    if (i === 0 && j > 0) {\n      return Math.max(lastResult, distance(longCurve[0], shortCurve[j]));\n    }\n\n    return Math.max(\n      Math.min(prevResultsCol[j], prevResultsCol[j - 1], lastResult),\n      distance(longCurve[i], shortCurve[j]),\n    );\n  };\n\n  let prevResultsCol: number[] = [];\n  for (let i = 0; i < longCurve.length; i++) {\n    const curResultsCol: number[] = [];\n    for (let j = 0; j < shortCurve.length; j++) {\n      // we only need the results from i - 1 and j - 1 to continue the calculation\n      // so we only need to hold onto the last column of calculated results\n      // prevResultsCol is results[i-1][:] in the original algorithm\n      // curResultsCol is results[i][:j-1] in the original algorithm\n      curResultsCol.push(calcVal(i, j, prevResultsCol, curResultsCol));\n    }\n    prevResultsCol = curResultsCol;\n  }\n\n  return prevResultsCol[shortCurve.length - 1];\n};\n\n/** break up long segments in the curve into smaller segments of len maxLen or smaller */\nexport const subdivideCurve = (curve: Point[], maxLen = 0.05) => {\n  const newCurve = curve.slice(0, 1);\n\n  for (const point of curve.slice(1)) {\n    const prevPoint = newCurve[newCurve.length - 1];\n    const segLen = distance(point, prevPoint);\n    if (segLen > maxLen) {\n      const numNewPoints = Math.ceil(segLen / maxLen);\n      const newSegLen = segLen / numNewPoints;\n      for (let i = 0; i < numNewPoints; i++) {\n        newCurve.push(_extendPointOnLine(point, prevPoint, -1 * newSegLen * (i + 1)));\n      }\n    } else {\n      newCurve.push(point);\n    }\n  }\n\n  return newCurve;\n};\n\n/** redraw the curve using numPoints equally spaced out along the length of the curve */\nexport const outlineCurve = (curve: Point[], numPoints = 30) => {\n  const curveLen = length(curve);\n  const segmentLen = curveLen / (numPoints - 1);\n  const outlinePoints = [curve[0]];\n  const endPoint = arrLast(curve);\n  const remainingCurvePoints = curve.slice(1);\n\n  for (let i = 0; i < numPoints - 2; i++) {\n    let lastPoint: Point = arrLast(outlinePoints);\n    let remainingDist = segmentLen;\n    let outlinePointFound = false;\n    while (!outlinePointFound) {\n      const nextPointDist = distance(lastPoint, remainingCurvePoints[0]);\n      if (nextPointDist < remainingDist) {\n        remainingDist -= nextPointDist;\n        lastPoint = remainingCurvePoints.shift()!;\n      } else {\n        const nextPoint = _extendPointOnLine(\n          lastPoint,\n          remainingCurvePoints[0],\n          remainingDist - nextPointDist,\n        );\n        outlinePoints.push(nextPoint);\n        outlinePointFound = true;\n      }\n    }\n  }\n\n  outlinePoints.push(endPoint);\n\n  return outlinePoints;\n};\n\n/** translate and scale from https://en.wikipedia.org/wiki/Procrustes_analysis */\nexport const normalizeCurve = (curve: Point[]) => {\n  const outlinedCurve = outlineCurve(curve);\n  const meanX = average(outlinedCurve.map((point) => point.x));\n  const meanY = average(outlinedCurve.map((point) => point.y));\n  const mean = { x: meanX, y: meanY };\n  const translatedCurve = outlinedCurve.map((point) => subtract(point, mean));\n  const scale = Math.sqrt(\n    average([\n      Math.pow(translatedCurve[0].x, 2) + Math.pow(translatedCurve[0].y, 2),\n      Math.pow(arrLast(translatedCurve).x, 2) + Math.pow(arrLast(translatedCurve).y, 2),\n    ]),\n  );\n  const scaledCurve = translatedCurve.map((point) => ({\n    x: point.x / scale,\n    y: point.y / scale,\n  }));\n  return subdivideCurve(scaledCurve);\n};\n\n// rotate around the origin\nexport const rotate = (curve: Point[], theta: number) => {\n  return curve.map((point) => ({\n    x: Math.cos(theta) * point.x - Math.sin(theta) * point.y,\n    y: Math.sin(theta) * point.x + Math.cos(theta) * point.y,\n  }));\n};\n\n// remove intermediate points that are on the same line as the points to either side\nexport const _filterParallelPoints = (points: Point[]) => {\n  if (points.length < 3) return points;\n  const filteredPoints = [points[0], points[1]];\n  points.slice(2).forEach((point) => {\n    const numFilteredPoints = filteredPoints.length;\n    const curVect = subtract(point, filteredPoints[numFilteredPoints - 1]);\n    const prevVect = subtract(\n      filteredPoints[numFilteredPoints - 1],\n      filteredPoints[numFilteredPoints - 2],\n    );\n    // this is the z coord of the cross-product. If this is 0 then they're parallel\n    const isParallel = curVect.y * prevVect.x - curVect.x * prevVect.y === 0;\n    if (isParallel) {\n      filteredPoints.pop();\n    }\n    filteredPoints.push(point);\n  });\n  return filteredPoints;\n};\n\nexport function getPathString(points: Point[], close = false) {\n  const start = round(points[0]);\n  const remainingPoints = points.slice(1);\n  let pathString = `M ${start.x} ${start.y}`;\n  remainingPoints.forEach((point) => {\n    const roundedPoint = round(point);\n    pathString += ` L ${roundedPoint.x} ${roundedPoint.y}`;\n  });\n  if (close) {\n    pathString += 'Z';\n  }\n  return pathString;\n}\n\n/** take points on a path and move their start point backwards by distance */\nexport const extendStart = (points: Point[], dist: number) => {\n  const filteredPoints = _filterParallelPoints(points);\n  if (filteredPoints.length < 2) return filteredPoints;\n  const p1 = filteredPoints[1];\n  const p2 = filteredPoints[0];\n  const newStart = _extendPointOnLine(p1, p2, dist);\n  const extendedPoints = filteredPoints.slice(1);\n  extendedPoints.unshift(newStart);\n  return extendedPoints;\n};\n","import { subtract, distance, length } from '../geometry';\nimport { Point } from '../typings/types';\n\nexport default class Stroke {\n  path: string;\n  points: Point[];\n  strokeNum: number;\n  isInRadical: boolean;\n\n  constructor(path: string, points: Point[], strokeNum: number, isInRadical = false) {\n    this.path = path;\n    this.points = points;\n    this.strokeNum = strokeNum;\n    this.isInRadical = isInRadical;\n  }\n\n  getStartingPoint() {\n    return this.points[0];\n  }\n\n  getEndingPoint() {\n    return this.points[this.points.length - 1];\n  }\n\n  getLength(): number {\n    return length(this.points);\n  }\n\n  getVectors() {\n    let lastPoint = this.points[0];\n    const pointsSansFirst = this.points.slice(1);\n    return pointsSansFirst.map((point) => {\n      const vector = subtract(point, lastPoint);\n      lastPoint = point;\n      return vector;\n    });\n  }\n\n  getDistance(point: Point) {\n    const distances = this.points.map((strokePoint) => distance(strokePoint, point));\n    return Math.min(...distances);\n  }\n\n  getAverageDistance(points: Point[]) {\n    const totalDist = points.reduce((acc, point) => acc + this.getDistance(point), 0);\n    return totalDist / points.length;\n  }\n}\n","import Stroke from './Stroke';\n\nexport default class Character {\n  symbol: string;\n  strokes: Stroke[];\n\n  constructor(symbol: string, strokes: Stroke[]) {\n    this.symbol = symbol;\n    this.strokes = strokes;\n  }\n}\n","import Stroke from './models/Stroke';\nimport Character from './models/Character';\nimport { CharacterJson } from './typings/types';\n\nfunction generateStrokes({ radStrokes, strokes, medians }: CharacterJson) {\n  const isInRadical = (strokeNum: number) => (radStrokes?.indexOf(strokeNum) ?? -1) >= 0;\n  return strokes.map((path, index) => {\n    const points = medians[index].map((pointData) => {\n      const [x, y] = pointData;\n      return { x, y };\n    });\n    return new Stroke(path, points, index, isInRadical(index));\n  });\n}\n\nexport default function parseCharData(symbol: string, charJson: CharacterJson) {\n  const strokes = generateStrokes(charJson);\n  return new Character(symbol, strokes);\n}\n","import { Point } from './typings/types';\n\n// All makemeahanzi characters have the same bounding box\nconst CHARACTER_BOUNDS = [\n  { x: 0, y: -124 },\n  { x: 1024, y: 900 },\n];\nconst [from, to] = CHARACTER_BOUNDS;\nconst preScaledWidth = to.x - from.x;\nconst preScaledHeight = to.y - from.y;\n\nexport type PositionerOptions = {\n  /** Default: 0 */\n  width: number;\n  /** Default: 0 */\n  height: number;\n  /** Default: 20 */\n  padding: number;\n};\n\nexport default class Positioner {\n  padding: number;\n  width: number;\n  height: number;\n  xOffset: number;\n  yOffset: number;\n  scale: number;\n\n  constructor(options: PositionerOptions) {\n    const { padding, width, height } = options;\n    this.padding = padding;\n    this.width = width;\n    this.height = height;\n\n    const effectiveWidth = width - 2 * padding;\n    const effectiveHeight = height - 2 * padding;\n    const scaleX = effectiveWidth / preScaledWidth;\n    const scaleY = effectiveHeight / preScaledHeight;\n\n    this.scale = Math.min(scaleX, scaleY);\n\n    const xCenteringBuffer = padding + (effectiveWidth - this.scale * preScaledWidth) / 2;\n    const yCenteringBuffer =\n      padding + (effectiveHeight - this.scale * preScaledHeight) / 2;\n\n    this.xOffset = -1 * from.x * this.scale + xCenteringBuffer;\n    this.yOffset = -1 * from.y * this.scale + yCenteringBuffer;\n  }\n\n  convertExternalPoint(point: Point) {\n    const x = (point.x - this.xOffset) / this.scale;\n    const y = (this.height - this.yOffset - point.y) / this.scale;\n    return { x, y };\n  }\n}\n","import { average } from './utils';\nimport {\n  cosineSimilarity,\n  equals,\n  frechetDist,\n  distance,\n  subtract,\n  normalizeCurve,\n  rotate,\n  length,\n} from './geometry';\nimport { Point } from './typings/types';\nimport UserStroke from './models/UserStroke';\nimport Stroke from './models/Stroke';\nimport Character from './models/Character';\n\nconst AVG_DIST_THRESHOLD = 350; // bigger = more lenient\nconst COSINE_SIMILARITY_THRESHOLD = 0; // -1 to 1, smaller = more lenient\nconst START_AND_END_DIST_THRESHOLD = 250; // bigger = more lenient\nconst FRECHET_THRESHOLD = 0.4; // bigger = more lenient\nconst MIN_LEN_THRESHOLD = 0.35; // smaller = more lenient\n\nexport default function strokeMatches(\n  userStroke: UserStroke,\n  character: Character,\n  strokeNum: number,\n  options: {\n    leniency?: number;\n    isOutlineVisible?: boolean;\n  } = {},\n) {\n  const strokes = character.strokes;\n  const points = stripDuplicates(userStroke.points);\n\n  if (points.length < 2) {\n    return null;\n  }\n\n  const { isMatch, avgDist } = getMatchData(points, strokes[strokeNum], options);\n\n  if (!isMatch) {\n    return false;\n  }\n\n  // if there is a better match among strokes the user hasn't drawn yet, the user probably drew the wrong stroke\n  const laterStrokes = strokes.slice(strokeNum + 1);\n  let closestMatchDist = avgDist;\n\n  for (let i = 0; i < laterStrokes.length; i++) {\n    const { isMatch, avgDist } = getMatchData(points, laterStrokes[i], options);\n    if (isMatch && avgDist < closestMatchDist) {\n      closestMatchDist = avgDist;\n    }\n  }\n  // if there's a better match, rather that returning false automatically, try reducing leniency instead\n  // if leniency is already really high we can allow some similar strokes to pass\n  if (closestMatchDist < avgDist) {\n    // adjust leniency between 0.3 and 0.6 depending on how much of a better match the new match is\n    const leniencyAdjustment = (0.6 * (closestMatchDist + avgDist)) / (2 * avgDist);\n    const { isMatch } = getMatchData(points, strokes[strokeNum], {\n      ...options,\n      leniency: (options.leniency || 1) * leniencyAdjustment,\n    });\n    return isMatch;\n  }\n  return true;\n}\n\nconst startAndEndMatches = (points: Point[], closestStroke: Stroke, leniency: number) => {\n  const startingDist = distance(closestStroke.getStartingPoint(), points[0]);\n  const endingDist = distance(closestStroke.getEndingPoint(), points[points.length - 1]);\n  return (\n    startingDist <= START_AND_END_DIST_THRESHOLD * leniency &&\n    endingDist <= START_AND_END_DIST_THRESHOLD * leniency\n  );\n};\n\n// returns a list of the direction of all segments in the line connecting the points\nconst getEdgeVectors = (points: Point[]) => {\n  const vectors: Point[] = [];\n  let lastPoint = points[0];\n  points.slice(1).forEach((point) => {\n    vectors.push(subtract(point, lastPoint));\n    lastPoint = point;\n  });\n  return vectors;\n};\n\nconst directionMatches = (points: Point[], stroke: Stroke) => {\n  const edgeVectors = getEdgeVectors(points);\n  const strokeVectors = stroke.getVectors();\n  const similarities = edgeVectors.map((edgeVector) => {\n    const strokeSimilarities = strokeVectors.map((strokeVector) =>\n      cosineSimilarity(strokeVector, edgeVector),\n    );\n    return Math.max(...strokeSimilarities);\n  });\n  const avgSimilarity = average(similarities);\n  return avgSimilarity > COSINE_SIMILARITY_THRESHOLD;\n};\n\nconst lengthMatches = (points: Point[], stroke: Stroke, leniency: number) => {\n  return (\n    (leniency * (length(points) + 25)) / (stroke.getLength() + 25) >= MIN_LEN_THRESHOLD\n  );\n};\n\nconst stripDuplicates = (points: Point[]) => {\n  if (points.length < 2) return points;\n  const [firstPoint, ...rest] = points;\n  const dedupedPoints = [firstPoint];\n\n  for (const point of rest) {\n    if (!equals(point, dedupedPoints[dedupedPoints.length - 1])) {\n      dedupedPoints.push(point);\n    }\n  }\n\n  return dedupedPoints;\n};\n\nconst SHAPE_FIT_ROTATIONS = [\n  Math.PI / 16,\n  Math.PI / 32,\n  0,\n  (-1 * Math.PI) / 32,\n  (-1 * Math.PI) / 16,\n];\n\nconst shapeFit = (curve1: Point[], curve2: Point[], leniency: number) => {\n  const normCurve1 = normalizeCurve(curve1);\n  const normCurve2 = normalizeCurve(curve2);\n  let minDist = Infinity;\n  SHAPE_FIT_ROTATIONS.forEach((theta) => {\n    const dist = frechetDist(normCurve1, rotate(normCurve2, theta));\n    if (dist < minDist) {\n      minDist = dist;\n    }\n  });\n  return minDist <= FRECHET_THRESHOLD * leniency;\n};\n\nconst getMatchData = (\n  points: Point[],\n  stroke: Stroke,\n  options: { leniency?: number; isOutlineVisible?: boolean },\n) => {\n  const { leniency = 1, isOutlineVisible = false } = options;\n  const avgDist = stroke.getAverageDistance(points);\n  const distMod = isOutlineVisible || stroke.strokeNum > 0 ? 0.5 : 1;\n  const withinDistThresh = avgDist <= AVG_DIST_THRESHOLD * distMod * leniency;\n  // short circuit for faster matching\n  if (!withinDistThresh) {\n    return { isMatch: false, avgDist };\n  }\n  const startAndEndMatch = startAndEndMatches(points, stroke, leniency);\n  const directionMatch = directionMatches(points, stroke);\n  const shapeMatch = shapeFit(points, stroke.points, leniency);\n  const lengthMatch = lengthMatches(points, stroke, leniency);\n  return {\n    isMatch:\n      withinDistThresh && startAndEndMatch && directionMatch && shapeMatch && lengthMatch,\n    avgDist,\n  };\n};\n","import { Point } from '../typings/types';\n\nexport default class UserStroke {\n  id: number;\n  points: Point[];\n  externalPoints: Point[];\n\n  constructor(id: number, startingPoint: Point, startingExternalPoint: Point) {\n    this.id = id;\n    this.points = [startingPoint];\n    this.externalPoints = [startingExternalPoint];\n  }\n\n  appendPoint(point: Point, externalPoint: Point) {\n    this.points.push(point);\n    this.externalPoints.push(externalPoint);\n  }\n}\n","import {\n  cancelAnimationFrame,\n  requestAnimationFrame,\n  inflate,\n  performanceNow,\n} from './utils';\nimport RenderState from './RenderState';\nimport { RecursivePartial } from './typings/types';\n\n/** Used by `Mutation` & `Delay` */\nexport interface GenericMutation<\n  TRenderStateClass extends GenericRenderStateClass = RenderState\n> {\n  /** Allows mutations starting with the provided string to be cancelled */\n  scope: string;\n  /** Can be useful for checking whether the mutation is running */\n  _runningPromise: Promise<void> | undefined;\n  run(renderState: TRenderStateClass): Promise<void>;\n  pause(): void;\n  resume(): void;\n  cancel(renderState: TRenderStateClass): void;\n}\n\nexport type MutationChain = GenericMutation<any>[];\n\nclass Delay implements GenericMutation {\n  scope: string;\n  _runningPromise: Promise<void> | undefined;\n  _duration: number;\n  _startTime: number | null;\n  _paused: boolean;\n  _timeout!: NodeJS.Timeout;\n  _resolve: (() => void) | undefined;\n\n  constructor(duration: number) {\n    this._duration = duration;\n    this._startTime = null;\n    this._paused = false;\n    this.scope = `delay.${duration}`;\n  }\n\n  run() {\n    this._startTime = performanceNow();\n    this._runningPromise = new Promise((resolve) => {\n      this._resolve = resolve;\n      // @ts-ignore return type of \"setTimeout\" in builds is parsed as `number` instead of `Timeout`\n      this._timeout = setTimeout(() => this.cancel(), this._duration);\n    }) as Promise<void>;\n    return this._runningPromise;\n  }\n\n  pause() {\n    if (this._paused) return;\n    // to pause, clear the timeout and rewrite this._duration with whatever time is remaining\n    const elapsedDelay = performance.now() - (this._startTime || 0);\n    this._duration = Math.max(0, this._duration - elapsedDelay);\n    clearTimeout(this._timeout);\n    this._paused = true;\n  }\n\n  resume() {\n    if (!this._paused) return;\n    this._startTime = performance.now();\n    // @ts-ignore return type of \"setTimeout\" in builds is parsed as `number` instead of `Timeout`\n    this._timeout = setTimeout(() => this.cancel(), this._duration);\n    this._paused = false;\n  }\n\n  cancel() {\n    clearTimeout(this._timeout!);\n    if (this._resolve) {\n      this._resolve();\n    }\n    this._resolve = undefined;\n  }\n}\n\ntype GenericRenderStateClass<T = any> = {\n  state: T;\n  updateState(changes: RecursivePartial<T>): void;\n};\n\nexport default class Mutation<\n  TRenderStateClass extends GenericRenderStateClass,\n  TRenderStateObj = TRenderStateClass['state']\n> implements GenericMutation<TRenderStateClass> {\n  static Delay = Delay;\n\n  scope: string;\n  _runningPromise: Promise<void> | undefined;\n  _valuesOrCallable: any;\n  _duration: number;\n  _force: boolean | undefined;\n  _pausedDuration: number;\n  _startPauseTime: number | null;\n\n  // Only set on .run()\n  _startTime: number | undefined;\n  _startState: RecursivePartial<TRenderStateObj> | undefined;\n  _renderState: TRenderStateClass | undefined;\n  _frameHandle: number | undefined;\n  _values: RecursivePartial<TRenderStateObj> | undefined;\n  _resolve: ((_val?: any) => void) | undefined;\n\n  /**\n   *\n   * @param scope a string representation of what fields this mutation affects from the state. This is used to cancel conflicting mutations\n   * @param valuesOrCallable a thunk containing the value to set, or a callback which will return those values\n   */\n  constructor(\n    scope: string,\n    valuesOrCallable: any,\n    options: {\n      duration?: number;\n      /** Updates render state regardless if cancelled */\n      force?: boolean;\n    } = {},\n  ) {\n    this.scope = scope;\n    this._valuesOrCallable = valuesOrCallable;\n    this._duration = options.duration || 0;\n    this._force = options.force;\n    this._pausedDuration = 0;\n    this._startPauseTime = null;\n  }\n\n  run(renderState: TRenderStateClass): Promise<void> {\n    if (!this._values) this._inflateValues(renderState);\n    if (this._duration === 0) renderState.updateState(this._values!);\n    if (this._duration === 0 || isAlreadyAtEnd(renderState.state, this._values)) {\n      return Promise.resolve();\n    }\n    this._renderState = renderState;\n    this._startState = renderState.state;\n    this._startTime = performance.now();\n    this._frameHandle = requestAnimationFrame(this._tick);\n    return new Promise((resolve) => {\n      this._resolve = resolve;\n    });\n  }\n\n  private _inflateValues(renderState: TRenderStateClass) {\n    let values = this._valuesOrCallable;\n    if (typeof this._valuesOrCallable === 'function') {\n      values = this._valuesOrCallable(renderState.state);\n    }\n    this._values = inflate(this.scope, values);\n  }\n\n  pause() {\n    if (this._startPauseTime !== null) {\n      return;\n    }\n    if (this._frameHandle) {\n      cancelAnimationFrame(this._frameHandle);\n    }\n    this._startPauseTime = performance.now();\n  }\n\n  resume() {\n    if (this._startPauseTime === null) {\n      return;\n    }\n    this._frameHandle = requestAnimationFrame(this._tick);\n    this._pausedDuration += performance.now() - this._startPauseTime;\n    this._startPauseTime = null;\n  }\n\n  private _tick = (timing: number) => {\n    if (this._startPauseTime !== null) {\n      return;\n    }\n\n    const progress = Math.min(\n      1,\n      (timing - this._startTime! - this._pausedDuration) / this._duration,\n    );\n\n    if (progress === 1) {\n      this._renderState!.updateState(this._values!);\n      this._frameHandle = undefined;\n      this.cancel(this._renderState!);\n    } else {\n      const easedProgress = ease(progress);\n      const stateChanges = getPartialValues(\n        this._startState as TRenderStateObj,\n        this._values!,\n        easedProgress,\n      );\n\n      this._renderState!.updateState(stateChanges);\n      this._frameHandle = requestAnimationFrame(this._tick);\n    }\n  };\n\n  cancel(renderState: TRenderStateClass) {\n    this._resolve?.();\n    this._resolve = undefined;\n\n    cancelAnimationFrame(this._frameHandle || -1);\n    this._frameHandle = undefined;\n\n    if (this._force) {\n      if (!this._values) this._inflateValues(renderState);\n      renderState.updateState(this._values!);\n    }\n  }\n}\n\nfunction getPartialValues<T>(\n  startValues: T | undefined,\n  endValues: RecursivePartial<T> | undefined,\n  progress: number,\n) {\n  const target: RecursivePartial<T> = {};\n\n  for (const key in endValues) {\n    const endValue = endValues[key];\n    const startValue = startValues?.[key];\n    if (typeof startValue === 'number' && typeof endValue === 'number' && endValue >= 0) {\n      target[key] = progress * (endValue - startValue) + startValue;\n    } else {\n      target[key] = getPartialValues(startValue, endValue, progress);\n    }\n  }\n  return target;\n}\n\nfunction isAlreadyAtEnd<T>(\n  startValues: T | undefined,\n  endValues: RecursivePartial<T> | undefined,\n) {\n  for (const key in endValues) {\n    const endValue = endValues[key];\n    const startValue = startValues?.[key];\n    if (endValue >= 0) {\n      if (endValue !== startValue) {\n        return false;\n      }\n    } else if (!isAlreadyAtEnd(startValue, endValue)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// from https://github.com/maxwellito/vivus\nconst ease = (x: number) => -Math.cos(x * Math.PI) / 2 + 0.5;\n","import Stroke from './models/Stroke';\nimport { ColorObject, RecursivePartial } from './typings/types';\nimport Character from './models/Character';\nimport Mutation, { MutationChain } from './Mutation';\nimport { objRepeat } from './utils';\nimport { CharacterName, CharacterRenderState, RenderStateObject } from './RenderState';\n\nexport const showStrokes = (\n  charName: CharacterName,\n  character: Character,\n  duration: number,\n): MutationChain => {\n  return [\n    new Mutation(\n      `character.${charName}.strokes`,\n      objRepeat(\n        { opacity: 1, displayPortion: 1 },\n        character.strokes.length,\n      ) as CharacterRenderState['strokes'],\n      { duration, force: true },\n    ),\n  ];\n};\n\nexport const showCharacter = (\n  charName: CharacterName,\n  character: Character,\n  duration: number,\n): MutationChain => {\n  return [\n    new Mutation(\n      `character.${charName}`,\n      {\n        opacity: 1,\n        strokes: objRepeat({ opacity: 1, displayPortion: 1 }, character.strokes.length),\n      },\n      { duration, force: true },\n    ),\n  ];\n};\n\nexport const hideCharacter = (\n  charName: CharacterName,\n  character: Character,\n  duration?: number,\n): MutationChain => {\n  return [\n    new Mutation(`character.${charName}.opacity`, 0, { duration, force: true }),\n    ...showStrokes(charName, character, 0),\n  ];\n};\n\nexport const updateColor = (\n  colorName: string,\n  colorVal: ColorObject | null,\n  duration: number,\n) => {\n  return [new Mutation(`options.${colorName}`, colorVal, { duration })];\n};\n\nexport const highlightStroke = (\n  stroke: Stroke,\n  color: ColorObject | null,\n  speed: number,\n): MutationChain => {\n  const strokeNum = stroke.strokeNum;\n  const duration = (stroke.getLength() + 600) / (3 * speed);\n  return [\n    new Mutation('character.highlight.strokeColor', color),\n    new Mutation('character.highlight', {\n      opacity: 1,\n      strokes: {\n        [strokeNum]: {\n          displayPortion: 0,\n          opacity: 0,\n        },\n      },\n    }),\n    new Mutation(\n      `character.highlight.strokes.${strokeNum}`,\n      {\n        displayPortion: 1,\n        opacity: 1,\n      },\n      { duration },\n    ),\n    new Mutation(`character.highlight.strokes.${strokeNum}.opacity`, 0, { duration }),\n  ];\n};\n\nexport const animateStroke = (\n  charName: CharacterName,\n  stroke: Stroke,\n  speed: number,\n): MutationChain => {\n  const strokeNum = stroke.strokeNum;\n  const duration = (stroke.getLength() + 600) / (3 * speed);\n  return [\n    new Mutation(`character.${charName}`, {\n      opacity: 1,\n      strokes: {\n        [strokeNum]: {\n          displayPortion: 0,\n          opacity: 1,\n        },\n      },\n    }),\n    new Mutation(`character.${charName}.strokes.${strokeNum}.displayPortion`, 1, {\n      duration,\n    }),\n  ];\n};\n\nexport const animateSingleStroke = (\n  charName: CharacterName,\n  character: Character,\n  strokeNum: number,\n  speed: number,\n): MutationChain => {\n  const mutationStateFunc = (state: RenderStateObject) => {\n    const curCharState = state.character[charName];\n    const mutationState: RecursivePartial<CharacterRenderState> = {\n      opacity: 1,\n      strokes: {},\n    };\n    for (let i = 0; i < character.strokes.length; i++) {\n      mutationState.strokes![i] = {\n        opacity: curCharState.opacity * curCharState.strokes[i].opacity,\n      };\n    }\n    return mutationState;\n  };\n  const stroke = character.strokes[strokeNum];\n  return [\n    new Mutation(`character.${charName}`, mutationStateFunc),\n    ...animateStroke(charName, stroke, speed),\n  ];\n};\n\nexport const showStroke = (\n  charName: CharacterName,\n  strokeNum: number,\n  duration: number,\n): MutationChain => {\n  return [\n    new Mutation(\n      `character.${charName}.strokes.${strokeNum}`,\n      {\n        displayPortion: 1,\n        opacity: 1,\n      },\n      { duration, force: true },\n    ),\n  ];\n};\n\nexport const animateCharacter = (\n  charName: CharacterName,\n  character: Character,\n  fadeDuration: number,\n  speed: number,\n  delayBetweenStrokes: number,\n): MutationChain => {\n  let mutations: MutationChain = hideCharacter(charName, character, fadeDuration);\n  mutations = mutations.concat(showStrokes(charName, character, 0));\n  mutations.push(\n    new Mutation(\n      `character.${charName}`,\n      {\n        opacity: 1,\n        strokes: objRepeat({ opacity: 0 }, character.strokes.length),\n      },\n      { force: true },\n    ),\n  );\n  character.strokes.forEach((stroke, i) => {\n    if (i > 0) mutations.push(new Mutation.Delay(delayBetweenStrokes));\n    mutations = mutations.concat(animateStroke(charName, stroke, speed));\n  });\n  return mutations;\n};\n\nexport const animateCharacterLoop = (\n  charName: CharacterName,\n  character: Character,\n  fadeDuration: number,\n  speed: number,\n  delayBetweenStrokes: number,\n  delayBetweenLoops: number,\n): MutationChain => {\n  const mutations = animateCharacter(\n    charName,\n    character,\n    fadeDuration,\n    speed,\n    delayBetweenStrokes,\n  );\n  mutations.push(new Mutation.Delay(delayBetweenLoops));\n  return mutations;\n};\n","import Mutation, { MutationChain } from './Mutation';\nimport * as characterActions from './characterActions';\nimport { objRepeat } from './utils';\nimport Character from './models/Character';\nimport { Point } from './typings/types';\n\nexport const startQuiz = (character: Character, fadeDuration: number): MutationChain => {\n  return [\n    ...characterActions.hideCharacter('main', character, fadeDuration),\n    new Mutation(\n      'character.highlight',\n      {\n        opacity: 1,\n        strokes: objRepeat({ opacity: 0 }, character.strokes.length),\n      },\n      { force: true },\n    ),\n    new Mutation(\n      'character.main',\n      {\n        opacity: 1,\n        strokes: objRepeat({ opacity: 0 }, character.strokes.length),\n      },\n      { force: true },\n    ),\n  ];\n};\n\nexport const startUserStroke = (id: string | number, point: Point): MutationChain => {\n  return [\n    new Mutation('quiz.activeUserStrokeId', id, { force: true }),\n    new Mutation(\n      `userStrokes.${id}`,\n      {\n        points: [point],\n        opacity: 1,\n      },\n      { force: true },\n    ),\n  ];\n};\n\nexport const updateUserStroke = (\n  userStrokeId: string | number,\n  points: Point[],\n): MutationChain => {\n  return [new Mutation(`userStrokes.${userStrokeId}.points`, points, { force: true })];\n};\n\nexport const removeUserStroke = (\n  userStrokeId: string | number,\n  duration: number,\n): MutationChain => {\n  return [\n    new Mutation(`userStrokes.${userStrokeId}.opacity`, 0, { duration }),\n    new Mutation(`userStrokes.${userStrokeId}`, null, { force: true }),\n  ];\n};\n\nexport const highlightCompleteChar = (\n  character: Character,\n  duration: number,\n): MutationChain => {\n  return [\n    ...characterActions.hideCharacter('highlight', character),\n    ...characterActions.showCharacter('highlight', character, duration / 2),\n    ...characterActions.hideCharacter('highlight', character, duration / 2),\n  ];\n};\n\nexport const highlightStroke = characterActions.highlightStroke;\n","import strokeMatches from './strokeMatches';\nimport UserStroke from './models/UserStroke';\nimport Positioner from './Positioner';\nimport { counter, colorStringToVals } from './utils';\nimport * as quizActions from './quizActions';\nimport * as geometry from './geometry';\nimport * as characterActions from './characterActions';\nimport Character from './models/Character';\nimport { ParsedHanziWriterOptions, Point, StrokeData } from './typings/types';\nimport RenderState from './RenderState';\nimport { MutationChain } from './Mutation';\n\nconst getDrawnPath = (userStroke: UserStroke) => ({\n  pathString: geometry.getPathString(userStroke.externalPoints),\n  points: userStroke.points.map((point) => geometry.round(point)),\n});\n\nexport default class Quiz {\n  _character: Character;\n  _renderState: RenderState;\n  _isActive: boolean;\n  _positioner: Positioner;\n\n  /** Set on startQuiz */\n  _options: ParsedHanziWriterOptions | undefined;\n  _currentStrokeIndex = 0;\n  _mistakesOnStroke = 0;\n  _totalMistakes = 0;\n  _userStroke: UserStroke | undefined;\n\n  constructor(character: Character, renderState: RenderState, positioner: Positioner) {\n    this._character = character;\n    this._renderState = renderState;\n    this._isActive = false;\n    this._positioner = positioner;\n  }\n\n  startQuiz(options: ParsedHanziWriterOptions) {\n    this._isActive = true;\n    this._options = options;\n    this._currentStrokeIndex = 0;\n    this._mistakesOnStroke = 0;\n    this._totalMistakes = 0;\n\n    return this._renderState.run(\n      quizActions.startQuiz(this._character, options.strokeFadeDuration),\n    );\n  }\n\n  startUserStroke(externalPoint: Point) {\n    if (!this._isActive) {\n      return null;\n    }\n    if (this._userStroke) {\n      return this.endUserStroke();\n    }\n    const point = this._positioner.convertExternalPoint(externalPoint);\n    const strokeId = counter();\n    this._userStroke = new UserStroke(strokeId, point, externalPoint);\n    return this._renderState.run(quizActions.startUserStroke(strokeId, point));\n  }\n\n  continueUserStroke(externalPoint: Point) {\n    if (!this._userStroke) {\n      return Promise.resolve();\n    }\n    const point = this._positioner.convertExternalPoint(externalPoint);\n    this._userStroke.appendPoint(point, externalPoint);\n    const nextPoints = this._userStroke.points.slice(0);\n    return this._renderState.run(\n      quizActions.updateUserStroke(this._userStroke.id, nextPoints),\n    );\n  }\n\n  endUserStroke() {\n    if (!this._userStroke) return;\n\n    this._renderState.run(\n      quizActions.removeUserStroke(\n        this._userStroke.id,\n        this._options!.drawingFadeDuration ?? 300,\n      ),\n    );\n\n    // skip single-point strokes\n    if (this._userStroke.points.length === 1) {\n      this._userStroke = undefined;\n      return;\n    }\n\n    const currentStroke = this._getCurrentStroke();\n    const isMatch = strokeMatches(\n      this._userStroke,\n      this._character,\n      this._currentStrokeIndex,\n      {\n        isOutlineVisible: this._renderState.state.character.outline.opacity > 0,\n        leniency: this._options!.leniency,\n      },\n    );\n\n    if (isMatch) {\n      this._handleSuccess();\n    } else {\n      this._handleFailure();\n\n      const {\n        showHintAfterMisses,\n        highlightColor,\n        strokeHighlightSpeed,\n      } = this._options!;\n\n      if (\n        showHintAfterMisses !== false &&\n        this._mistakesOnStroke >= showHintAfterMisses\n      ) {\n        this._renderState.run(\n          characterActions.highlightStroke(\n            currentStroke,\n            colorStringToVals(highlightColor),\n            strokeHighlightSpeed,\n          ),\n        );\n      }\n    }\n\n    this._userStroke = undefined;\n  }\n\n  cancel() {\n    this._isActive = false;\n    if (this._userStroke) {\n      this._renderState.run(\n        quizActions.removeUserStroke(\n          this._userStroke.id,\n          this._options!.drawingFadeDuration,\n        ),\n      );\n    }\n  }\n\n  _getStrokeData(isCorrect = false): StrokeData {\n    return {\n      character: this._character.symbol,\n      strokeNum: this._currentStrokeIndex,\n      mistakesOnStroke: this._mistakesOnStroke,\n      totalMistakes: this._totalMistakes,\n      strokesRemaining:\n        this._character.strokes.length - this._currentStrokeIndex - (isCorrect ? 1 : 0),\n      drawnPath: getDrawnPath(this._userStroke!),\n    };\n  }\n\n  _handleSuccess() {\n    if (!this._options) return;\n\n    const { strokes, symbol } = this._character;\n\n    const {\n      onCorrectStroke,\n      onComplete,\n      highlightOnComplete,\n      strokeFadeDuration,\n      strokeHighlightDuration,\n    } = this._options;\n\n    onCorrectStroke?.(this._getStrokeData(true));\n\n    let animation: MutationChain = characterActions.showStroke(\n      'main',\n      this._currentStrokeIndex,\n      strokeFadeDuration,\n    );\n\n    this._mistakesOnStroke = 0;\n    this._currentStrokeIndex += 1;\n\n    const isComplete = this._currentStrokeIndex === strokes.length;\n\n    if (isComplete) {\n      this._isActive = false;\n      onComplete?.({\n        character: symbol,\n        totalMistakes: this._totalMistakes,\n      });\n      if (highlightOnComplete) {\n        animation = animation.concat(\n          quizActions.highlightCompleteChar(\n            this._character,\n            (strokeHighlightDuration || 0) * 2,\n          ),\n        );\n      }\n    }\n\n    this._renderState.run(animation);\n  }\n\n  _handleFailure() {\n    this._mistakesOnStroke += 1;\n    this._totalMistakes += 1;\n    this._options!.onMistake?.(this._getStrokeData());\n  }\n\n  _getCurrentStroke() {\n    return this._character.strokes[this._currentStrokeIndex];\n  }\n}\n","export function createElm(elmType: string) {\n  return document.createElementNS('http://www.w3.org/2000/svg', elmType);\n}\n\nexport function attr(elm: Element, name: string, value: string) {\n  elm.setAttributeNS(null, name, value);\n}\n\nexport function attrs(elm: Element, attrsMap: Record<string, string>) {\n  Object.keys(attrsMap).forEach((attrName) => attr(elm, attrName, attrsMap[attrName]));\n}\n\n// inspired by https://talk.observablehq.com/t/hanzi-writer-renders-incorrectly-inside-an-observable-notebook-on-a-mobile-browser/1898\nexport function urlIdRef(id: string) {\n  let prefix = '';\n  if (window.location && window.location.href) {\n    prefix = window.location.href.replace(/#[^#]*$/, '').replace(/\"/gi, '%22');\n  }\n  return `url(\"${prefix}#${id}\")`;\n}\n\nexport function removeElm(elm: Element | undefined) {\n  elm?.parentNode?.removeChild(elm);\n}\n","import Stroke from '../models/Stroke';\nimport { ColorObject } from '../typings/types';\n\nexport default class StrokeRendererBase {\n  _pathLength: number;\n  stroke: Stroke;\n  static STROKE_WIDTH = 200;\n\n  constructor(stroke: Stroke) {\n    this.stroke = stroke;\n    this._pathLength = stroke.getLength() + StrokeRendererBase.STROKE_WIDTH / 2;\n  }\n\n  _getStrokeDashoffset(displayPortion: number) {\n    return this._pathLength * 0.999 * (1 - displayPortion);\n  }\n\n  _getColor({\n    strokeColor,\n    radicalColor,\n  }: {\n    strokeColor: ColorObject;\n    radicalColor?: ColorObject | null;\n  }) {\n    return radicalColor && this.stroke.isInRadical ? radicalColor : strokeColor;\n  }\n}\n","import { counter } from '../../utils';\nimport * as svg from './svgUtils';\nimport { extendStart, getPathString } from '../../geometry';\nimport StrokeRendererBase from '../StrokeRendererBase';\nimport Stroke from '../../models/Stroke';\nimport SVGRenderTarget from './RenderTarget';\nimport { ColorObject } from '../../typings/types';\n\nconst STROKE_WIDTH = 200;\n\ntype StrokeRenderProps = {\n  strokeColor: ColorObject;\n  radicalColor: ColorObject | null;\n  displayPortion: number;\n  opacity: number;\n};\n\n/** This is a stroke composed of several stroke parts **/\nexport default class StrokeRenderer extends StrokeRendererBase {\n  _oldProps: StrokeRenderProps | undefined = undefined;\n\n  _animationPath: SVGPathElement | undefined;\n  _clip: SVGClipPathElement | undefined;\n  _strokePath: SVGPathElement | undefined;\n\n  constructor(stroke: Stroke) {\n    super(stroke);\n  }\n\n  mount(target: SVGRenderTarget) {\n    this._animationPath = svg.createElm('path') as SVGPathElement;\n    this._clip = svg.createElm('clipPath') as SVGClipPathElement;\n    this._strokePath = svg.createElm('path') as SVGPathElement;\n    const maskId = `mask-${counter()}`;\n    svg.attr(this._clip, 'id', maskId);\n\n    svg.attr(this._strokePath, 'd', this.stroke.path);\n    this._animationPath.style.opacity = '0';\n    svg.attr(this._animationPath, 'clip-path', svg.urlIdRef(maskId));\n\n    const extendedMaskPoints = extendStart(this.stroke.points, STROKE_WIDTH / 2);\n    svg.attr(this._animationPath, 'd', getPathString(extendedMaskPoints));\n    svg.attrs(this._animationPath, {\n      stroke: '#FFFFFF',\n      'stroke-width': STROKE_WIDTH.toString(),\n      fill: 'none',\n      'stroke-linecap': 'round',\n      'stroke-linejoin': 'miter',\n      'stroke-dasharray': `${this._pathLength},${this._pathLength}`,\n    });\n\n    this._clip.appendChild(this._strokePath);\n    target.defs.appendChild(this._clip);\n    target.svg.appendChild(this._animationPath);\n    return this;\n  }\n\n  render(props: StrokeRenderProps) {\n    if (props === this._oldProps || !this._animationPath) {\n      return;\n    }\n\n    if (props.displayPortion !== this._oldProps?.displayPortion) {\n      this._animationPath.style.strokeDashoffset = this._getStrokeDashoffset(\n        props.displayPortion,\n      ).toString();\n    }\n\n    const color = this._getColor(props);\n\n    if (!this._oldProps || color !== this._getColor(this._oldProps)) {\n      const { r, g, b, a } = color;\n      svg.attrs(this._animationPath, { stroke: `rgba(${r},${g},${b},${a})` });\n    }\n\n    if (props.opacity !== this._oldProps?.opacity) {\n      this._animationPath.style.opacity = props.opacity.toString();\n    }\n    this._oldProps = props;\n  }\n}\n","import { isMsBrowser } from '../../utils';\nimport StrokeRenderer from './StrokeRenderer';\nimport SVGRenderTarget from './RenderTarget';\nimport Character from '../../models/Character';\nimport { ColorObject } from '../../typings/types';\nimport { StrokeRenderState } from '../../RenderState';\n\ntype SvgCharacterRenderProps = {\n  opacity: number;\n  strokes: Record<number, StrokeRenderState>;\n  strokeColor: ColorObject;\n  radicalColor?: ColorObject | null;\n};\n\nexport default class CharacterRenderer {\n  _oldProps: SvgCharacterRenderProps | undefined = undefined;\n  _strokeRenderers: StrokeRenderer[];\n\n  // set on mount()\n  _group: SVGElement | SVGSVGElement | undefined;\n\n  constructor(character: Character) {\n    this._strokeRenderers = character.strokes.map((stroke) => new StrokeRenderer(stroke));\n  }\n\n  mount(target: SVGRenderTarget) {\n    const subTarget = target.createSubRenderTarget();\n    this._group = subTarget.svg;\n    this._strokeRenderers.forEach((strokeRenderer) => {\n      strokeRenderer.mount(subTarget);\n    });\n  }\n\n  render(props: SvgCharacterRenderProps) {\n    if (props === this._oldProps || !this._group) {\n      return;\n    }\n    const { opacity, strokes, strokeColor, radicalColor = null } = props;\n    if (opacity !== this._oldProps?.opacity) {\n      this._group.style.opacity = opacity.toString();\n      // MS browsers seem to have a bug where if SVG is set to display:none, it sometimes breaks.\n      // More info: https://github.com/chanind/hanzi-writer/issues/164\n      // this is just a perf improvement, so disable for MS browsers\n      if (!isMsBrowser) {\n        if (opacity === 0) {\n          this._group.style.display = 'none';\n        } else if (this._oldProps?.opacity === 0) {\n          this._group.style.removeProperty('display');\n        }\n      }\n    }\n    const colorsChanged =\n      !this._oldProps ||\n      strokeColor !== this._oldProps.strokeColor ||\n      radicalColor !== this._oldProps.radicalColor;\n\n    if (colorsChanged || strokes !== this._oldProps?.strokes) {\n      for (let i = 0; i < this._strokeRenderers.length; i++) {\n        if (\n          !colorsChanged &&\n          this._oldProps?.strokes &&\n          strokes[i] === this._oldProps.strokes[i]\n        ) {\n          continue;\n        }\n        this._strokeRenderers[i].render({\n          strokeColor,\n          radicalColor,\n          opacity: strokes[i].opacity,\n          displayPortion: strokes[i].displayPortion,\n        });\n      }\n    }\n    this._oldProps = props;\n  }\n}\n","import * as svg from './svgUtils';\nimport { getPathString } from '../../geometry';\nimport { ColorObject, Point } from '../../typings/types';\nimport SVGRenderTarget from './RenderTarget';\n\nexport type UserStrokeProps = {\n  strokeWidth: number;\n  strokeColor: ColorObject;\n  opacity: number;\n  points: Point[];\n};\n\nexport default class UserStrokeRenderer {\n  _oldProps: UserStrokeProps | undefined = undefined;\n  _path: SVGElement | undefined;\n\n  mount(target: SVGRenderTarget) {\n    this._path = svg.createElm('path');\n    target.svg.appendChild(this._path);\n  }\n\n  render(props: UserStrokeProps) {\n    if (!this._path || props === this._oldProps) {\n      return;\n    }\n    if (\n      props.strokeColor !== this._oldProps?.strokeColor ||\n      props.strokeWidth !== this._oldProps?.strokeWidth\n    ) {\n      const { r, g, b, a } = props.strokeColor;\n      svg.attrs(this._path, {\n        fill: 'none',\n        stroke: `rgba(${r},${g},${b},${a})`,\n        'stroke-width': props.strokeWidth.toString(),\n        'stroke-linecap': 'round',\n        'stroke-linejoin': 'round',\n      });\n    }\n    if (props.opacity !== this._oldProps?.opacity) {\n      svg.attr(this._path, 'opacity', props.opacity.toString());\n    }\n    if (props.points !== this._oldProps?.points) {\n      svg.attr(this._path, 'd', getPathString(props.points));\n    }\n    this._oldProps = props;\n  }\n\n  destroy() {\n    svg.removeElm(this._path);\n  }\n}\n","import CharacterRenderer from './CharacterRenderer';\nimport UserStrokeRenderer, { UserStrokeProps } from './UserStrokeRenderer';\nimport * as svg from './svgUtils';\nimport Character from '../../models/Character';\nimport Positioner from '../../Positioner';\nimport SVGRenderTarget from './RenderTarget';\nimport HanziWriterRendererBase from '../HanziWriterRendererBase';\nimport { RenderStateObject } from '../../RenderState';\n\nexport default class HanziWriterRenderer\n  implements HanziWriterRendererBase<SVGElement | SVGSVGElement, SVGRenderTarget> {\n  _character: Character;\n  _positioner: Positioner;\n  _mainCharRenderer: CharacterRenderer;\n  _outlineCharRenderer: CharacterRenderer;\n  _highlightCharRenderer: CharacterRenderer;\n  _userStrokeRenderers: Record<string, UserStrokeRenderer | undefined>;\n  _positionedTarget: SVGRenderTarget | undefined;\n\n  constructor(character: Character, positioner: Positioner) {\n    this._character = character;\n    this._positioner = positioner;\n    this._mainCharRenderer = new CharacterRenderer(character);\n    this._outlineCharRenderer = new CharacterRenderer(character);\n    this._highlightCharRenderer = new CharacterRenderer(character);\n    this._userStrokeRenderers = {};\n  }\n\n  mount(target: SVGRenderTarget) {\n    const positionedTarget = target.createSubRenderTarget();\n    const group = positionedTarget.svg;\n    const { xOffset, yOffset, height, scale } = this._positioner;\n\n    svg.attr(\n      group,\n      'transform',\n      `translate(${xOffset}, ${height - yOffset}) scale(${scale}, ${-1 * scale})`,\n    );\n    this._outlineCharRenderer.mount(positionedTarget);\n    this._mainCharRenderer.mount(positionedTarget);\n    this._highlightCharRenderer.mount(positionedTarget);\n    this._positionedTarget = positionedTarget;\n  }\n\n  render(props: RenderStateObject) {\n    const { main, outline, highlight } = props.character;\n    const {\n      outlineColor,\n      radicalColor,\n      highlightColor,\n      strokeColor,\n      drawingWidth,\n      drawingColor,\n    } = props.options;\n\n    this._outlineCharRenderer.render({\n      opacity: outline.opacity,\n      strokes: outline.strokes,\n      strokeColor: outlineColor,\n    });\n\n    this._mainCharRenderer.render({\n      opacity: main.opacity,\n      strokes: main.strokes,\n      strokeColor,\n      radicalColor: radicalColor,\n    });\n\n    this._highlightCharRenderer.render({\n      opacity: highlight.opacity,\n      strokes: highlight.strokes,\n      strokeColor: highlightColor,\n    });\n\n    const userStrokes = props.userStrokes || {};\n\n    for (const userStrokeId in this._userStrokeRenderers) {\n      if (!userStrokes[userStrokeId]) {\n        this._userStrokeRenderers[userStrokeId]?.destroy();\n        delete this._userStrokeRenderers[userStrokeId];\n      }\n    }\n\n    for (const userStrokeId in userStrokes) {\n      const stroke = userStrokes[userStrokeId];\n      if (!stroke) {\n        continue;\n      }\n      const userStrokeProps: UserStrokeProps = {\n        strokeWidth: drawingWidth,\n        strokeColor: drawingColor,\n        ...stroke,\n      };\n\n      const strokeRenderer = (() => {\n        if (this._userStrokeRenderers[userStrokeId]) {\n          return this._userStrokeRenderers[userStrokeId]!;\n        }\n        const newStrokeRenderer = new UserStrokeRenderer();\n        newStrokeRenderer.mount(this._positionedTarget!);\n        this._userStrokeRenderers[userStrokeId] = newStrokeRenderer;\n        return newStrokeRenderer;\n      })();\n\n      strokeRenderer.render(userStrokeProps);\n    }\n  }\n\n  destroy() {\n    svg.removeElm(this._positionedTarget!.svg);\n    this._positionedTarget!.defs.innerHTML = '';\n  }\n}\n","import { Point } from '../typings/types';\n\ntype BoundEvent = {\n  getPoint(): Point;\n  preventDefault(): void;\n};\n\n/** Generic render target */\nexport default class RenderTargetBase<\n  TElement extends\n    | HTMLElement\n    | SVGElement\n    | SVGSVGElement\n    | HTMLCanvasElement = HTMLElement\n> {\n  node: TElement;\n\n  constructor(node: TElement) {\n    this.node = node;\n  }\n\n  addPointerStartListener(callback: (arg: BoundEvent) => void) {\n    this.node.addEventListener('mousedown', (evt) => {\n      callback(this._eventify(evt as MouseEvent, this._getMousePoint));\n    });\n    this.node.addEventListener('touchstart', (evt) => {\n      callback(this._eventify(evt as TouchEvent, this._getTouchPoint));\n    });\n  }\n\n  addPointerMoveListener(callback: (arg: BoundEvent) => void) {\n    this.node.addEventListener('mousemove', (evt) => {\n      callback(this._eventify(evt as MouseEvent, this._getMousePoint));\n    });\n    this.node.addEventListener('touchmove', (evt) => {\n      callback(this._eventify(evt as TouchEvent, this._getTouchPoint));\n    });\n  }\n\n  addPointerEndListener(callback: () => void) {\n    // TODO: find a way to not need global listeners\n    document.addEventListener('mouseup', callback);\n    document.addEventListener('touchend', callback);\n  }\n\n  getBoundingClientRect() {\n    return this.node.getBoundingClientRect();\n  }\n\n  _eventify<TEvent extends Event>(evt: TEvent, pointFunc: (event: TEvent) => Point) {\n    return {\n      getPoint: () => pointFunc.call(this, evt),\n      preventDefault: () => evt.preventDefault(),\n    };\n  }\n\n  _getMousePoint(evt: MouseEvent): Point {\n    const { left, top } = this.getBoundingClientRect();\n    const x = evt.clientX - left;\n    const y = evt.clientY - top;\n    return { x, y };\n  }\n\n  _getTouchPoint(evt: TouchEvent): Point {\n    const { left, top } = this.getBoundingClientRect();\n    const x = evt.touches[0].clientX - left;\n    const y = evt.touches[0].clientY - top;\n    return { x, y };\n  }\n}\n","import { createElm, attrs } from './svgUtils';\nimport RenderTargetBase from '../RenderTargetBase';\n\nexport default class RenderTarget extends RenderTargetBase<SVGSVGElement | SVGElement> {\n  static init(elmOrId: Element | string, width = '100%', height = '100%') {\n    const element = (() => {\n      if (typeof elmOrId === 'string') {\n        return document.getElementById(elmOrId);\n      }\n      return elmOrId;\n    })();\n\n    if (!element) {\n      throw new Error(`HanziWriter target element not found: ${elmOrId}`);\n    }\n    const nodeType = element.nodeName.toUpperCase();\n\n    const svg = (() => {\n      if (nodeType === 'SVG' || nodeType === 'G') {\n        return element;\n      } else {\n        const svg = createElm('svg');\n        element.appendChild(svg);\n        return svg;\n      }\n    })() as SVGSVGElement;\n\n    attrs(svg, { width, height });\n    const defs = createElm('defs');\n    svg.appendChild(defs);\n\n    return new RenderTarget(svg, defs);\n  }\n\n  svg: SVGSVGElement | SVGElement;\n  defs: SVGElement;\n  _pt: DOMPoint | undefined;\n\n  constructor(svg: SVGElement | SVGSVGElement, defs: SVGElement) {\n    super(svg);\n\n    this.svg = svg;\n    this.defs = defs;\n\n    if ('createSVGPoint' in svg) {\n      this._pt = svg.createSVGPoint();\n    }\n  }\n\n  createSubRenderTarget() {\n    const group = createElm('g');\n    this.svg.appendChild(group);\n    return new RenderTarget(group, this.defs);\n  }\n\n  _getMousePoint(evt: MouseEvent) {\n    if (this._pt) {\n      this._pt.x = evt.clientX;\n      this._pt.y = evt.clientY;\n      if ('getScreenCTM' in this.node) {\n        const localPt = this._pt.matrixTransform(this.node.getScreenCTM()?.inverse());\n        return { x: localPt.x, y: localPt.y };\n      }\n    }\n    return super._getMousePoint.call(this, evt);\n  }\n\n  _getTouchPoint(evt: TouchEvent) {\n    if (this._pt) {\n      this._pt.x = evt.touches[0].clientX;\n      this._pt.y = evt.touches[0].clientY;\n      if ('getScreenCTM' in this.node) {\n        const localPt = this._pt.matrixTransform(\n          (this.node as SVGSVGElement).getScreenCTM()?.inverse(),\n        );\n        return { x: localPt.x, y: localPt.y };\n      }\n    }\n    return super._getTouchPoint(evt);\n  }\n}\n","import { RenderTargetInitFunction } from '../../typings/types';\nimport HanziWriterRenderer from './HanziWriterRenderer';\nimport RenderTarget from './RenderTarget';\n\nexport default {\n  HanziWriterRenderer,\n  createRenderTarget: RenderTarget.init as RenderTargetInitFunction<\n    SVGSVGElement | SVGElement\n  >,\n};\n","import { Point } from '../../typings/types';\n\nexport const drawPath = (ctx: CanvasRenderingContext2D, points: Point[]) => {\n  ctx.beginPath();\n  const start = points[0];\n  const remainingPoints = points.slice(1);\n  ctx.moveTo(start.x, start.y);\n  for (const point of remainingPoints) {\n    ctx.lineTo(point.x, point.y);\n  }\n  ctx.stroke();\n};\n\n/**\n * Break a path string into a series of canvas path commands\n *\n * Note: only works with the subset of SVG paths used by MakeMeAHanzi data\n * @param pathString\n */\nexport const pathStringToCanvas = (pathString: string) => {\n  const pathParts = pathString.split(/(^|\\s+)(?=[A-Z])/).filter((part) => part !== ' ');\n  const commands = [(ctx: CanvasRenderingContext2D) => ctx.beginPath()];\n  for (const part of pathParts) {\n    const [cmd, ...rawParams] = part.split(/\\s+/);\n    const params = rawParams.map((param) => parseFloat(param)) as any[];\n    if (cmd === 'M') {\n      commands.push((ctx) => ctx.moveTo(...(params as [number, number])));\n    } else if (cmd === 'L') {\n      commands.push((ctx) => ctx.lineTo(...(params as [number, number])));\n    } else if (cmd === 'C') {\n      commands.push((ctx) =>\n        ctx.bezierCurveTo(...(params as Parameters<typeof ctx.bezierCurveTo>)),\n      );\n    } else if (cmd === 'Q') {\n      commands.push((ctx) =>\n        ctx.quadraticCurveTo(...(params as Parameters<typeof ctx.quadraticCurveTo>)),\n      );\n    } else if (cmd === 'Z') {\n      // commands.push((ctx) => ctx.closePath());\n    }\n  }\n  return (ctx: CanvasRenderingContext2D) => commands.forEach((cmd) => cmd(ctx));\n};\n","import { extendStart } from '../../geometry';\nimport { drawPath, pathStringToCanvas } from './canvasUtils';\nimport StrokeRendererBase from '../StrokeRendererBase';\nimport Stroke from '../../models/Stroke';\nimport { ColorObject, Point } from '../../typings/types';\n\n/** this is a stroke composed of several stroke parts */\nexport default class StrokeRenderer extends StrokeRendererBase {\n  _extendedMaskPoints: Point[];\n\n  // Conditionally set on constructor\n  _path2D: Path2D | undefined;\n  _pathCmd: ((ctx: CanvasRenderingContext2D) => void) | undefined;\n\n  constructor(stroke: Stroke, usePath2D = true) {\n    super(stroke);\n\n    if (usePath2D && Path2D) {\n      this._path2D = new Path2D(this.stroke.path);\n    } else {\n      this._pathCmd = pathStringToCanvas(this.stroke.path);\n    }\n    this._extendedMaskPoints = extendStart(\n      this.stroke.points,\n      StrokeRendererBase.STROKE_WIDTH / 2,\n    );\n  }\n\n  render(\n    ctx: CanvasRenderingContext2D,\n    props: {\n      opacity: number;\n      strokeColor: ColorObject;\n      radicalColor?: ColorObject | null;\n      displayPortion: number;\n    },\n  ) {\n    if (props.opacity < 0.05) {\n      return;\n    }\n    ctx.save();\n\n    if (this._path2D) {\n      ctx.clip(this._path2D);\n    } else {\n      this._pathCmd?.(ctx);\n      // wechat bugs out if the clip path isn't stroked or filled\n      ctx.globalAlpha = 0;\n      ctx.stroke();\n      ctx.clip();\n    }\n\n    const { r, g, b, a } = this._getColor(props);\n    const color = a === 1 ? `rgb(${r},${g},${b})` : `rgb(${r},${g},${b},${a})`;\n    const dashOffset = this._getStrokeDashoffset(props.displayPortion);\n    ctx.globalAlpha = props.opacity;\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    ctx.lineWidth = StrokeRendererBase.STROKE_WIDTH;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    // wechat sets dashOffset as a second param here. Should be harmless for browsers to add here too\n    // @ts-ignore\n    ctx.setLineDash([this._pathLength, this._pathLength], dashOffset);\n    ctx.lineDashOffset = dashOffset;\n    drawPath(ctx, this._extendedMaskPoints);\n\n    ctx.restore();\n  }\n}\n","import Character from '../../models/Character';\nimport { StrokeRenderState } from '../../RenderState';\nimport { ColorObject } from '../../typings/types';\nimport StrokeRenderer from './StrokeRenderer';\n\nexport default class CharacterRenderer {\n  _strokeRenderers: StrokeRenderer[];\n\n  constructor(character: Character) {\n    this._strokeRenderers = character.strokes.map((stroke) => new StrokeRenderer(stroke));\n  }\n\n  render(\n    ctx: CanvasRenderingContext2D,\n    props: {\n      opacity: number;\n      strokes: Record<number, StrokeRenderState>;\n      strokeColor: ColorObject;\n      radicalColor?: ColorObject | null;\n    },\n  ) {\n    if (props.opacity < 0.05) return;\n\n    const { opacity, strokeColor, radicalColor, strokes } = props;\n\n    for (let i = 0; i < this._strokeRenderers.length; i++) {\n      this._strokeRenderers[i].render(ctx, {\n        strokeColor,\n        radicalColor,\n        opacity: strokes[i].opacity * opacity,\n        displayPortion: strokes[i].displayPortion || 0,\n      });\n    }\n  }\n}\n","import { ColorObject, Point } from '../../typings/types';\nimport { drawPath } from './canvasUtils';\n\nexport default function renderUserStroke(\n  ctx: CanvasRenderingContext2D,\n  props: {\n    opacity: number;\n    strokeWidth: number;\n    strokeColor: ColorObject;\n    points: Point[];\n  },\n) {\n  if (props.opacity < 0.05) {\n    return;\n  }\n  const { opacity, strokeWidth, strokeColor, points } = props;\n  const { r, g, b, a } = strokeColor;\n\n  ctx.save();\n  ctx.globalAlpha = opacity;\n  ctx.lineWidth = strokeWidth;\n  ctx.strokeStyle = `rgba(${r},${g},${b},${a})`;\n  ctx.lineCap = 'round';\n  ctx.lineJoin = 'round';\n  drawPath(ctx, points);\n  ctx.restore();\n}\n","import Character from '../../models/Character';\nimport Positioner from '../../Positioner';\nimport HanziWriterRendererBase from '../HanziWriterRendererBase';\nimport CanvasRenderTarget from '../canvas/RenderTarget';\nimport CharacterRenderer from './CharacterRenderer';\nimport renderUserStroke from './renderUserStroke';\nimport { RenderStateObject } from '../../RenderState';\nimport { noop } from '../../utils';\n\nexport default class HanziWriterRenderer\n  implements HanziWriterRendererBase<HTMLCanvasElement, CanvasRenderTarget> {\n  _character: Character;\n  _positioner: Positioner;\n  _mainCharRenderer: CharacterRenderer;\n  _outlineCharRenderer: CharacterRenderer;\n  _highlightCharRenderer: CharacterRenderer;\n  _target: CanvasRenderTarget | undefined;\n\n  constructor(character: Character, positioner: Positioner) {\n    this._character = character;\n    this._positioner = positioner;\n    this._mainCharRenderer = new CharacterRenderer(character);\n    this._outlineCharRenderer = new CharacterRenderer(character);\n    this._highlightCharRenderer = new CharacterRenderer(character);\n  }\n\n  mount(target: CanvasRenderTarget) {\n    this._target = target;\n  }\n\n  destroy = noop;\n\n  _animationFrame(cb: (ctx: CanvasRenderingContext2D) => void) {\n    const { width, height, scale, xOffset, yOffset } = this._positioner;\n    const ctx = this._target!.getContext()!;\n    ctx.clearRect(0, 0, width, height);\n    ctx.save();\n    ctx.translate(xOffset, height - yOffset);\n    ctx.transform(1, 0, 0, -1, 0, 0);\n    ctx.scale(scale, scale);\n    cb(ctx);\n    ctx.restore();\n    // @ts-expect-error Verify if this is still needed for the \"wechat miniprogram\".\n    if (ctx.draw) {\n      // @ts-expect-error\n      ctx.draw();\n    }\n  }\n\n  render(props: RenderStateObject) {\n    const { outline, main, highlight } = props.character;\n    const {\n      outlineColor,\n      strokeColor,\n      radicalColor,\n      highlightColor,\n      drawingColor,\n      drawingWidth,\n    } = props.options;\n\n    this._animationFrame((ctx) => {\n      this._outlineCharRenderer.render(ctx, {\n        opacity: outline.opacity,\n        strokes: outline.strokes,\n        strokeColor: outlineColor,\n      });\n      this._mainCharRenderer.render(ctx, {\n        opacity: main.opacity,\n        strokes: main.strokes,\n        strokeColor: strokeColor,\n        radicalColor: radicalColor,\n      });\n      this._highlightCharRenderer.render(ctx, {\n        opacity: highlight.opacity,\n        strokes: highlight.strokes,\n        strokeColor: highlightColor,\n      });\n\n      const userStrokes = props.userStrokes || {};\n\n      for (const userStrokeId in userStrokes) {\n        const userStroke = userStrokes[userStrokeId];\n        if (userStroke) {\n          const userStrokeProps = {\n            strokeWidth: drawingWidth,\n            strokeColor: drawingColor,\n            ...userStroke,\n          };\n          renderUserStroke(ctx, userStrokeProps);\n        }\n      }\n    });\n  }\n}\n","import RenderTargetBase from '../RenderTargetBase';\n\nexport default class RenderTarget extends RenderTargetBase<HTMLCanvasElement> {\n  constructor(canvas: HTMLCanvasElement) {\n    super(canvas);\n  }\n\n  static init(elmOrId: string | HTMLCanvasElement, width = '100%', height = '100%') {\n    const element = (() => {\n      if (typeof elmOrId === 'string') {\n        return document.getElementById(elmOrId);\n      }\n      return elmOrId;\n    })();\n\n    if (!element) {\n      throw new Error(`HanziWriter target element not found: ${elmOrId}`);\n    }\n\n    const nodeType = element.nodeName.toUpperCase();\n\n    const canvas = (() => {\n      if (nodeType === 'CANVAS') {\n        return element as HTMLCanvasElement;\n      }\n      const canvas = document.createElement('canvas');\n      element.appendChild(canvas);\n      return canvas;\n    })();\n\n    canvas.setAttribute('width', width);\n    canvas.setAttribute('height', height);\n\n    return new RenderTarget(canvas);\n  }\n\n  getContext() {\n    return this.node.getContext('2d');\n  }\n}\n","import { RenderTargetInitFunction } from '../../typings/types';\nimport HanziWriterRenderer from './HanziWriterRenderer';\nimport RenderTarget from './RenderTarget';\n\nexport default {\n  HanziWriterRenderer,\n  createRenderTarget: RenderTarget.init as RenderTargetInitFunction<HTMLCanvasElement>,\n};\n","import { CharacterJson } from './typings/types';\n\nconst VERSION = '2.0';\nconst getCharDataUrl = (char: string) =>\n  `https://cdn.jsdelivr.net/npm/hanzi-writer-data@${VERSION}/${char}.json`;\n\nconst defaultCharDataLoader = (\n  char: string,\n  onLoad: (parsedJson: CharacterJson) => void,\n  onError: (error?: any, context?: any) => void,\n) => {\n  // load char data from hanziwriter cdn (currently hosted on jsdelivr)\n  const xhr = new XMLHttpRequest();\n  if (xhr.overrideMimeType) {\n    // IE 9 and 10 don't seem to support this...\n    xhr.overrideMimeType('application/json');\n  }\n  xhr.open('GET', getCharDataUrl(char), true);\n  xhr.onerror = (event) => {\n    onError(xhr, event);\n  };\n  xhr.onreadystatechange = () => {\n    // TODO: error handling\n    if (xhr.readyState !== 4) return;\n\n    if (xhr.status === 200) {\n      onLoad(JSON.parse(xhr.responseText));\n    } else if (xhr.status !== 0 && onError) {\n      onError(xhr);\n    }\n  };\n  xhr.send(null);\n};\n\nexport default defaultCharDataLoader;\n","import { HanziWriterOptions } from './typings/types';\nimport defaultCharDataLoader from './defaultCharDataLoader';\n\nconst defaultOptions: HanziWriterOptions = {\n  charDataLoader: defaultCharDataLoader,\n  onLoadCharDataError: null,\n  onLoadCharDataSuccess: null,\n  showOutline: true,\n  showCharacter: true,\n  renderer: 'svg',\n\n  // positioning options\n\n  width: 0,\n  height: 0,\n  padding: 20,\n\n  // animation options\n\n  strokeAnimationSpeed: 1,\n  strokeFadeDuration: 400,\n  strokeHighlightDuration: 200,\n  strokeHighlightSpeed: 2,\n  delayBetweenStrokes: 1000,\n  delayBetweenLoops: 2000,\n\n  // colors\n\n  strokeColor: '#555',\n  radicalColor: null,\n  highlightColor: '#AAF',\n  outlineColor: '#DDD',\n  drawingColor: '#333',\n\n  // quiz options\n\n  leniency: 1,\n  showHintAfterMisses: 3,\n  highlightOnComplete: true,\n  highlightCompleteColor: null,\n\n  // undocumented obscure options\n\n  drawingFadeDuration: 300,\n  drawingWidth: 4,\n  strokeWidth: 2,\n  outlineWidth: 2,\n  rendererOverride: {},\n};\n\nexport default defaultOptions;\n","import { CharacterJson, LoadingManagerOptions } from './typings/types';\n\ntype CustomError = Error & { reason: string };\n\nexport default class LoadingManager {\n  _loadCounter = 0;\n  _isLoading = false;\n  _resolve: ((data: CharacterJson) => void) | undefined;\n  _reject: ((error?: Error | CustomError | string) => void) | undefined;\n  _options: LoadingManagerOptions;\n\n  /** Set when calling LoadingManager.loadCharData  */\n  _loadingChar: string | undefined;\n  /** use this to attribute to determine if there was a problem with loading */\n  loadingFailed = false;\n\n  constructor(options: LoadingManagerOptions) {\n    this._options = options;\n  }\n\n  _debouncedLoad(char: string, count: number) {\n    // these wrappers ignore all responses except the most recent.\n    const wrappedResolve = (data: CharacterJson) => {\n      if (count === this._loadCounter) {\n        this._resolve?.(data);\n      }\n    };\n    const wrappedReject = (reason?: Error | string) => {\n      if (count === this._loadCounter) {\n        this._reject?.(reason);\n      }\n    };\n\n    const returnedData = this._options.charDataLoader(\n      char,\n      wrappedResolve,\n      wrappedReject,\n    );\n\n    if (returnedData) {\n      if ('then' in returnedData) {\n        returnedData.then(wrappedResolve).catch(wrappedReject);\n      } else {\n        wrappedResolve(returnedData);\n      }\n    }\n  }\n\n  _setupLoadingPromise() {\n    return new Promise(\n      (\n        resolve: (data: CharacterJson) => void,\n        reject: (err?: Error | CustomError | string) => void,\n      ) => {\n        this._resolve = resolve;\n        this._reject = reject;\n      },\n    )\n      .then((data: CharacterJson) => {\n        this._isLoading = false;\n        this._options.onLoadCharDataSuccess?.(data);\n        return data;\n      })\n      .catch((reason) => {\n        this._isLoading = false;\n        this.loadingFailed = true;\n\n        // If the user has provided an \"onLoadCharDataError\", call this function\n        // Otherwise, throw the promise\n        if (this._options.onLoadCharDataError) {\n          this._options.onLoadCharDataError(reason);\n          return;\n        }\n\n        // If error callback wasn't provided, throw an error so the developer will be aware something went wrong\n        if (reason instanceof Error) {\n          throw reason;\n        }\n\n        const err = new Error(\n          `Failed to load char data for ${this._loadingChar}`,\n        ) as CustomError;\n\n        err.reason = reason;\n\n        throw err;\n      });\n  }\n\n  loadCharData(char: string) {\n    this._loadingChar = char;\n    const promise = this._setupLoadingPromise();\n    this.loadingFailed = false;\n    this._isLoading = true;\n    this._loadCounter++;\n    this._debouncedLoad(char, this._loadCounter);\n    return promise;\n  }\n}\n","import RenderState from './RenderState';\nimport parseCharData from './parseCharData';\nimport Positioner from './Positioner';\nimport Quiz from './Quiz';\nimport svgRenderer from './renderers/svg';\nimport canvasRenderer from './renderers/canvas';\nimport defaultOptions from './defaultOptions';\nimport LoadingManager from './LoadingManager';\nimport * as characterActions from './characterActions';\nimport { trim, colorStringToVals } from './utils';\nimport Character from './models/Character';\nimport HanziWriterRendererBase, {\n  HanziWriterRendererConstructor,\n} from './renderers/HanziWriterRendererBase';\nimport RenderTargetBase from './renderers/RenderTargetBase';\nimport { GenericMutation } from './Mutation';\n\n// Typings\nimport {\n  ColorOptions,\n  HanziWriterOptions,\n  LoadingManagerOptions,\n  OnCompleteFunction,\n  ParsedHanziWriterOptions,\n  QuizOptions,\n  RenderTargetInitFunction,\n} from './typings/types';\n\n// Export type interfaces\nexport * from './typings/types';\n\nexport default class HanziWriter {\n  _options: ParsedHanziWriterOptions;\n  _loadingManager: LoadingManager;\n  /** Only set when calling .setCharacter() */\n  _char: string | undefined;\n  /** Only set when calling .setCharacter() */\n  _renderState: RenderState | undefined;\n  /** Only set when calling .setCharacter() */\n  _character: Character | undefined;\n  /** Only set when calling .setCharacter() */\n  _positioner: Positioner | undefined;\n  /** Only set when calling .setCharacter() */\n  _hanziWriterRenderer: HanziWriterRendererBase<HTMLElement, any> | null | undefined;\n  /** Only set when calling .setCharacter() */\n  _withDataPromise: Promise<void> | undefined;\n\n  _quiz: Quiz | undefined;\n  _renderer: {\n    HanziWriterRenderer: HanziWriterRendererConstructor;\n    createRenderTarget: RenderTargetInitFunction<any>;\n  };\n\n  target: RenderTargetBase;\n\n  /** Main entry point */\n  static create(\n    element: string | HTMLElement,\n    character: string,\n    options?: Partial<HanziWriterOptions>,\n  ) {\n    const writer = new HanziWriter(element, options);\n    writer.setCharacter(character);\n\n    return writer;\n  }\n\n  /** Singleton instance of LoadingManager. Only set in `loadCharacterData` */\n  static _loadingManager: LoadingManager | null = null;\n  /** Singleton loading options. Only set in `loadCharacterData` */\n  static _loadingOptions: Partial<HanziWriterOptions> | null = null;\n\n  static loadCharacterData(\n    character: string,\n    options: Partial<LoadingManagerOptions> = {},\n  ) {\n    const loadingManager = (() => {\n      const { _loadingManager, _loadingOptions } = HanziWriter;\n      if (_loadingManager?._loadingChar === character && _loadingOptions === options) {\n        return _loadingManager;\n      }\n      return new LoadingManager({ ...defaultOptions, ...options });\n    })();\n\n    HanziWriter._loadingManager = loadingManager;\n    HanziWriter._loadingOptions = options;\n    return loadingManager.loadCharData(character);\n  }\n\n  static getScalingTransform(width: number, height: number, padding = 0) {\n    const positioner = new Positioner({ width, height, padding });\n    return {\n      x: positioner.xOffset,\n      y: positioner.yOffset,\n      scale: positioner.scale,\n      transform: trim(`\n        translate(${positioner.xOffset}, ${positioner.height - positioner.yOffset})\n        scale(${positioner.scale}, ${-1 * positioner.scale})\n      `).replace(/\\s+/g, ' '),\n    };\n  }\n\n  constructor(element: string | HTMLElement, options: Partial<HanziWriterOptions> = {}) {\n    const { HanziWriterRenderer, createRenderTarget } =\n      options.renderer === 'canvas' ? canvasRenderer : svgRenderer;\n    const rendererOverride = options.rendererOverride || {};\n\n    this._renderer = {\n      HanziWriterRenderer: rendererOverride.HanziWriterRenderer || HanziWriterRenderer,\n      createRenderTarget: rendererOverride.createRenderTarget || createRenderTarget,\n    };\n    // wechat miniprogram component needs direct access to the render target, so this is public\n    this.target = this._renderer.createRenderTarget(\n      element,\n      options.width,\n      options.height,\n    );\n    this._options = this._assignOptions(options);\n    this._loadingManager = new LoadingManager(this._options);\n    this._setupListeners();\n  }\n\n  showCharacter(\n    options: {\n      onComplete?: OnCompleteFunction;\n      duration?: number;\n    } = {},\n  ) {\n    this._options.showCharacter = true;\n    return this._withData(() =>\n      this._renderState\n        ?.run(\n          characterActions.showCharacter(\n            'main',\n            this._character!,\n            typeof options.duration === 'number'\n              ? options.duration\n              : this._options.strokeFadeDuration,\n          ),\n        )\n        .then((res) => {\n          options.onComplete?.(res);\n          return res;\n        }),\n    );\n  }\n\n  hideCharacter(\n    options: {\n      onComplete?: OnCompleteFunction;\n      duration?: number;\n    } = {},\n  ) {\n    this._options.showCharacter = false;\n    return this._withData(() =>\n      this._renderState\n        ?.run(\n          characterActions.hideCharacter(\n            'main',\n            this._character!,\n            typeof options.duration === 'number'\n              ? options.duration\n              : this._options.strokeFadeDuration,\n          ),\n        )\n        .then((res) => {\n          options.onComplete?.(res);\n          return res;\n        }),\n    );\n  }\n\n  animateCharacter(\n    options: {\n      onComplete?: OnCompleteFunction;\n    } = {},\n  ) {\n    this.cancelQuiz();\n\n    return this._withData(() =>\n      this._renderState\n        ?.run(\n          characterActions.animateCharacter(\n            'main',\n            this._character!,\n            this._options.strokeFadeDuration,\n            this._options.strokeAnimationSpeed,\n            this._options.delayBetweenStrokes,\n          ),\n        )\n        .then((res) => {\n          options.onComplete?.(res);\n          return res;\n        }),\n    );\n  }\n\n  animateStroke(\n    strokeNum: number,\n    options: {\n      onComplete?: OnCompleteFunction;\n    } = {},\n  ) {\n    this.cancelQuiz();\n    return this._withData(() =>\n      this._renderState\n        ?.run(\n          characterActions.animateSingleStroke(\n            'main',\n            this._character!,\n            strokeNum,\n            this._options.strokeAnimationSpeed,\n          ),\n        )\n        .then((res) => {\n          options.onComplete?.(res);\n          return res;\n        }),\n    );\n  }\n\n  highlightStroke(\n    strokeNum: number,\n    options: {\n      onComplete?: OnCompleteFunction;\n    } = {},\n  ) {\n    const promise = () => {\n      if (!this._character || !this._renderState) {\n        return;\n      }\n\n      return this._renderState\n        .run(\n          characterActions.highlightStroke(\n            this._character.strokes[strokeNum],\n            colorStringToVals(this._options.highlightColor),\n            this._options.strokeHighlightSpeed,\n          ),\n        )\n        .then((res) => {\n          options.onComplete?.(res);\n          return res;\n        });\n    };\n\n    return this._withData(promise);\n  }\n\n  async loopCharacterAnimation() {\n    this.cancelQuiz();\n    return this._withData(() =>\n      this._renderState!.run(\n        characterActions.animateCharacterLoop(\n          'main',\n          this._character!,\n          this._options.strokeFadeDuration,\n          this._options.strokeAnimationSpeed,\n          this._options.delayBetweenStrokes,\n          this._options.delayBetweenLoops,\n        ),\n        { loop: true },\n      ),\n    );\n  }\n\n  pauseAnimation() {\n    return this._withData(() => this._renderState?.pauseAll());\n  }\n\n  resumeAnimation() {\n    return this._withData(() => this._renderState?.resumeAll());\n  }\n\n  showOutline(\n    options: {\n      duration?: number;\n      onComplete?: OnCompleteFunction;\n    } = {},\n  ) {\n    this._options.showOutline = true;\n    return this._withData(() =>\n      this._renderState\n        ?.run(\n          characterActions.showCharacter(\n            'outline',\n            this._character!,\n            typeof options.duration === 'number'\n              ? options.duration\n              : this._options.strokeFadeDuration,\n          ),\n        )\n        .then((res) => {\n          options.onComplete?.(res);\n          return res;\n        }),\n    );\n  }\n\n  hideOutline(\n    options: {\n      duration?: number;\n      onComplete?: OnCompleteFunction;\n    } = {},\n  ) {\n    this._options.showOutline = false;\n    return this._withData(() =>\n      this._renderState\n        ?.run(\n          characterActions.hideCharacter(\n            'outline',\n            this._character!,\n            typeof options.duration === 'number'\n              ? options.duration\n              : this._options.strokeFadeDuration,\n          ),\n        )\n        .then((res) => {\n          options.onComplete?.(res);\n          return res;\n        }),\n    );\n  }\n\n  updateColor(\n    colorName: keyof ColorOptions,\n    colorVal: string | null,\n    options: {\n      duration?: number;\n      onComplete?: OnCompleteFunction;\n    } = {},\n  ) {\n    let mutations: GenericMutation[] = [];\n\n    const fixedColorVal = (() => {\n      // If we're removing radical color, tween it to the stroke color\n      if (colorName === 'radicalColor' && !colorVal) {\n        return this._options.strokeColor;\n      }\n      return colorVal;\n    })();\n\n    const mappedColor = colorStringToVals(fixedColorVal as string);\n\n    this._options[colorName] = colorVal as any;\n\n    const duration = options.duration ?? this._options.strokeFadeDuration;\n\n    mutations = mutations.concat(\n      characterActions.updateColor(colorName, mappedColor, duration),\n    );\n\n    // make sure to set radicalColor back to null after the transition finishes if val == null\n    if (colorName === 'radicalColor' && !colorVal) {\n      mutations = mutations.concat(characterActions.updateColor(colorName, null, 0));\n    }\n\n    return this._withData(() =>\n      this._renderState?.run(mutations).then((res) => {\n        options.onComplete?.(res);\n        return res;\n      }),\n    );\n  }\n\n  quiz(quizOptions: Partial<QuizOptions> = {}) {\n    return this._withData(async () => {\n      if (this._character && this._renderState && this._positioner) {\n        this.cancelQuiz();\n        this._quiz = new Quiz(this._character, this._renderState, this._positioner);\n        this._options = {\n          ...this._options,\n          ...quizOptions,\n        };\n        this._quiz.startQuiz(this._options);\n      }\n    });\n  }\n\n  cancelQuiz() {\n    if (this._quiz) {\n      this._quiz.cancel();\n      this._quiz = undefined;\n    }\n  }\n\n  setCharacter(char: string) {\n    this.cancelQuiz();\n    this._char = char;\n    if (this._hanziWriterRenderer) {\n      this._hanziWriterRenderer.destroy();\n    }\n    if (this._renderState) {\n      this._renderState.cancelAll();\n    }\n    this._hanziWriterRenderer = null;\n    this._withDataPromise = this._loadingManager\n      .loadCharData(char)\n      .then((pathStrings) => {\n        // if \"pathStrings\" isn't set, \".catch()\"\" was probably called and loading likely failed\n        if (!pathStrings || this._loadingManager.loadingFailed) {\n          return;\n        }\n\n        this._character = parseCharData(char, pathStrings);\n        const { width, height, padding } = this._options;\n        this._positioner = new Positioner({ width, height, padding });\n        const hanziWriterRenderer = new this._renderer.HanziWriterRenderer(\n          this._character,\n          this._positioner,\n        );\n        this._hanziWriterRenderer = hanziWriterRenderer;\n        this._renderState = new RenderState(this._character, this._options, (nextState) =>\n          hanziWriterRenderer.render(nextState),\n        );\n        this._hanziWriterRenderer.mount(this.target);\n        this._hanziWriterRenderer.render(this._renderState.state);\n      });\n    return this._withDataPromise;\n  }\n\n  async getCharacterData(): Promise<Character> {\n    if (!this._char) {\n      throw new Error('setCharacter() must be called before calling getCharacterData()');\n    }\n    const character = await this._withData(() => this._character);\n    return character!;\n  }\n\n  _assignOptions(options: Partial<HanziWriterOptions>): ParsedHanziWriterOptions {\n    const mergedOptions = {\n      ...defaultOptions,\n      ...options,\n    };\n\n    // backfill strokeAnimationSpeed if deprecated strokeAnimationDuration is provided instead\n    if (options.strokeAnimationDuration && !options.strokeAnimationSpeed) {\n      mergedOptions.strokeAnimationSpeed = 500 / options.strokeAnimationDuration;\n    }\n    if (options.strokeHighlightDuration && !options.strokeHighlightSpeed) {\n      mergedOptions.strokeHighlightSpeed = 500 / mergedOptions.strokeHighlightDuration;\n    }\n\n    if (!options.highlightCompleteColor) {\n      mergedOptions.highlightCompleteColor = mergedOptions.highlightColor;\n    }\n\n    return this._fillWidthAndHeight(mergedOptions);\n  }\n\n  /** returns a new options object with width and height filled in if missing */\n  _fillWidthAndHeight(options: HanziWriterOptions): ParsedHanziWriterOptions {\n    const filledOpts = { ...options };\n    if (filledOpts.width && !filledOpts.height) {\n      filledOpts.height = filledOpts.width;\n    } else if (filledOpts.height && !filledOpts.width) {\n      filledOpts.width = filledOpts.height;\n    } else if (!filledOpts.width && !filledOpts.height) {\n      const { width, height } = this.target.getBoundingClientRect();\n      const minDim = Math.min(width, height);\n      filledOpts.width = minDim;\n      filledOpts.height = minDim;\n    }\n    return filledOpts as ParsedHanziWriterOptions;\n  }\n\n  _withData<T>(func: () => T) {\n    // if this._loadingManager.loadingFailed, then loading failed before this method was called\n    if (this._loadingManager.loadingFailed) {\n      throw Error('Failed to load character data. Call setCharacter and try again.');\n    }\n\n    if (this._withDataPromise) {\n      return this._withDataPromise.then(() => {\n        if (!this._loadingManager.loadingFailed) {\n          return func();\n        }\n      });\n    }\n    return Promise.resolve().then(func);\n  }\n\n  _setupListeners() {\n    this.target.addPointerStartListener((evt) => {\n      if (this._quiz) {\n        evt.preventDefault();\n        this._quiz.startUserStroke(evt.getPoint());\n      }\n    });\n    this.target.addPointerMoveListener((evt) => {\n      if (this._quiz) {\n        evt.preventDefault();\n        this._quiz.continueUserStroke(evt.getPoint());\n      }\n    });\n    this.target.addPointerEndListener(() => {\n      this._quiz?.endUserStroke();\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}